# Chapter 1: Understanding GraphQL Through REST

Chapter contents:

* [Introduction](1.md#introduction)
* [GraphQL as an alternative to a REST API](1.md#graphql-as-an-alternative-to-a-rest-api)
* [A simple REST API server](1.md#a-simple-rest-api-server)
* [A simple GraphQL server](1.md#a-simple-graphql-server)
* [Querying a set of data](1.md#querying-a-set-of-data)
* [Filtering the data](1.md#filtering-the-data)
* [Async data loading](1.md#async-data-loading)
* [Multiple types of data](1.md#multiple-types-of-data)
* [Security & error handling](1.md#security-&-error-handling)
* [Tying this all together](1.md#tying-this-all-together)

---

# Introduction

GraphQL is a modern, flexible specification for querying and modifying data that is on track to eclipse REST as a best practice for API design. You can write a single elegant query for all the data you need—no more cobbling together responses from a handful of REST endpoints. 

When describing GraphQL, it’s easier to start by saying what it isn’t. It isn’t a database—nothing is stored in it. It has little to do with graphs. While it is especially popular in the Node.js and React/Redux communities, GraphQL is a specification, which means it can be used in any language or framework. GraphQL is a query language (hence the “QL”)—it’s an abstraction for querying and modifying data, and it’s typically used by the client to fetch data from the server. It’s an explicit, type-safe, and flexible alternative to traditional JSON REST APIs.

Why use GraphQL? It turns out that GraphQL is amazingly useful—it combines a number of features that have existed in well-designed REST APIs and presents them as a single, easy-to-understand package:

- **Flexible, explicit queries:** GraphQL puts the consumer of the API in full control over what data they receive. Instead of a REST endpoint that returns all the properties you could possibly want (and often links to more), you only get the properties you ask for.
- **Type-safe, self-documenting API:** GraphQL APIs are type-safe and self-documenting: the schema you define is exposed as interactive documentation for private or public consumption.
- **No more API endpoint sprawl:** Backend engineers also love GraphQL. Once you write the code for accessing a data type, you won’t have to re-implement it. You don’t have to make a new endpoint for each view—you can leave that work up to the client and the GraphQL execution model, which is implemented by your GraphQL server library. And you don’t have to make a new API for each new app—you can have a single GraphQL API that covers all your business data.
- **Query consolidation:** A request for multiple data types can be combined into a single query that is executed in parallel on the server.
- **Static query analysis:** GraphQL schemas allow you to statically analyze the queries in your codebase and guarantee that you’ll never break them.

All together you end up with an API that is a delight to use and allows you to write expressive queries with understandable results:

![GraphiQL web interface](/img/graphiql.jpg)
*A GraphQL query (left) and the results from the server (right) inside the [GraphiQL web interface](https://ch1.graphql.guide/graphql).*

By reading this book, you’ll learn why you should use GraphQL in production and how to do it, and some best practices and common pitfalls. To start, we’ll dip our toes in the water: we’ll see the power of GraphQL through examples and answer the most obvious questions. Then we’ll dive deep into the intricacies of how this system was designed.

# GraphQL as an alternative to a REST API

This chapter examines how to build a fully-functional API using REST techniques and how that compares to building an equivalent API using GraphQL.

A basic REST API (where we perform a HTTP GET request to a particular URL and get back some JSON data) is one of the simplest API designs in existence. The complications appear when we want to have greater control over the results returned from the server. This is where GraphQL’s abilities really shine.

While a GraphQL API starts out more complex than a REST API, its complexity doesn’t increase as quickly because GraphQL implementations implicitly handle many of the challenging aspects of API design. Once we understand the basics of GraphQL, we understand enough to do pretty much anything we want, which is an exciting proposition. On the other hand, while a REST API starts off simple, it quickly ratchets up in complexity to levels that can be challenging to maintain, as we’ll see later in this chapter.

GraphQL’s developers have taken all the best practices of an excellently designed REST API and built them into a single system. It may seem like there is a lot of abstraction to it, but that  abstraction guides us toward practices that will make our APIs better designed and more consistent.

Going through building a REST API may seem like unnecessary work, but if we look at GraphQL as a REST API taken to its logical conclusion (a REST API with all the bells and whistles included), then a lot of the decisions that were made in designing GraphQL make a lot of sense. GraphQL is truly the best version of a REST API.

We recommend following along with the code, which can be found [on GitHub](https://github.com/GraphQLGuide/graphql-rest-api-demo).

# A simple REST API server

We’ll start our process of understanding GraphQL by building a simple REST API using Node.js and the popular Express web framework. We’ll be retrieving data from a MongoDB database and using Mongoose as our object-relational mapping (ORM) to simplify querying the data we have stored.

In this application, our server will listen for requests to the `/users/:id` URL. We use the ID passed as a parameter in the URL (as specified by the `:id`) to query a user record from the database and return it as a JSON string. If we encounter any errors, we return a 500 error, and if we can’t find the user, we return a 404—all standard REST practices.

[`rest-server.js`](https://github.com/GraphQLGuide/graphql-rest-api-demo/blob/master/rest-server.js):

```js
const express = require('express')
const server = express()

// Get the Mongoose models used for querying the database
const { User } = require('./models.js')

// Listen for all GET requests to /users/:id URL (where the
// ID is the ID of the user account)
server.get('/users/:id', (req, res) => {
  // Try to find the user by their id (_id field), using the ID
  // parameter from the URL.
  User.findById(req.params.id, (err, user) => {
    if (err) {
      // The DB returned an error so we return a 500 error
      return res.status(500).end()
    }

    if (!user) {
      // No user was found so we return a 404 error
      return res.status(404).end()
    }

    // Return the user to the client (automatically serialized
    // as a JSON string)
    res.send(user)
  })
})

// Start the application, listening on port 3000
server.listen(3000)


```

The Mongoose data models are stored in a separate file:

[`models.js`](https://github.com/GraphQLGuide/graphql-rest-api-demo/blob/master/models.js)

```js
const mongoose = require('mongoose')

// Connect to the local MongoDB database named "testdb"
mongoose.connect('mongodb://localhost/testdb')

// Create a User schema to be stored in the MongoDB database
const UserSchema = new mongoose.Schema({
  _id: String,
  username: String
})

// Turn that schema into a model that we can query
const User = mongoose.model('User', UserSchema)

module.exports = { User }
```

We connect to the database and implement a schema for the User that has two fields, `_id` (the default ID field for MongoDB) and `username`, and we turn that schema into a model that lets Mongoose know that users should be stored in the `users` collection (it takes the given model name `'User'` and lowercases and pluralizes).

We’ll need to have some data in our database to start, so we’ll insert a couple of simple documents with string `_id` and `username` fields, looking something like this (in [Robo 3T](https://robomongo.org/), a desktop graphical interface for running MongoDB queries against a database):

![users collection in MongoDB](/img/mongo-users.jpg)
*The two records stored in the “users” collection of the MongoDB database.*

To query this endpoint would be quite simple—we can run `curl` from the command line to verify that the endpoint’s response matches our expectations:

```sh
$ curl http://localhost:3000/users/123
{"_id":"123","username":"jeresig"}

$ curl -I http://localhost:3000/users/abc
HTTP/1.1 404 Not Found
X-Powered-By: Express
Date: Sat, 02 Dec 2017 19:11:52 GMT
Connection: keep-alive
```

Querying for a user by their ID returns the expected JSON object, and if we try to find a user that’s not in the database, we get the expected 404 error. Perfect!

# A simple GraphQL server

What does our REST server look like in the world of GraphQL? GraphQL has the concept of a schema—it’s similar to those in Mongoose and other data model libraries, but a GraphQL schema is used differently. In Mongoose the schema is a representation of the data that’s stored in the MongoDB database, but that’s not necessarily the case for a GraphQL schema. A GraphQL schema doesn’t need to match the storage format and can represent data from more than one source. To represent our basic User:

```gql
type User {
  _id: String
  username: String
}
```

This tells GraphQL that we have a type named `User` with two fields: `_id` and `username`, both strings. This alone doesn’t really do anything, though. GraphQL doesn’t know how to fetch this data or what interface(s) to set up for the client to query. We’ll write a function for the former in a bit, and we can do the latter—define a simple query interface—using the same schema syntax as above:

```gql
type Query {
  user(id: String!): User
}
```

In this case, we’re saying that we want a single query field (named `user`) that accepts a single argument (a required string named `id`) and returns a `User` type. This tells GraphQL how we want the client to be able to interact with the data, but GraphQL still doesn’t know how to actually get that data out of our database. Thankfully, we can make good use of the Mongoose models that we built before. GraphQL just needs to know what to do when the client sends a `user(id)` query. The Node.js GraphQL implementation makes smart use of Promises—we only need to return a Promise that resolves to a User, like this:

```js
function user({ id }) {
  return User.findById(id)
}
```

Putting it all together, we end up with a full GraphQL server:

[`graphql-server.js`](https://github.com/GraphQLGuide/graphql-rest-api-demo/blob/master/graphql-server.js)
```js
const graphqlHTTP = require('express-graphql')
const { buildSchema } = require('graphql')
const express = require('express')
const server = express()

// Get the Mongoose models used for querying the database
const { User } = require('./models.js')

// Start up a GraphQL endpoint listening at /graphql
server.use(
  '/graphql',
  graphqlHTTP({
    // We construct our GraphQL schema which has two types:
    // The User type and the Query type (through which all
    // queries for data are defined)
    schema: buildSchema(`
        type User {
            _id: String
            username: String
        }

        type Query {
            user(id: String!): User
        }
    `),
    // The methods that we'll use to get the data for our
    // main queries
    rootValue: {
      // Get a user based on the ID and return it as a Promise
      user({ id }) {
        return User.findById(id)
      }
    },
    // Display the GraphiQL web interface (for easy usage!)
    graphiql: true
  })
)

// Start the application, listening on port 3000
server.listen(3000)
```

As before, this program creates an Express server, but instead of making a `'/users/:id'` endpoint, it sets up an endpoint at `'/graphql'` that, using the schema we provide, allows clients to make the `user(id)` query. 

We can see now how an API consumer makes their query:

```gql
query {
  user(id: "123") {
    _id
    username
  }
}
```

In addition to having a custom language for specifying the schema, GraphQL also has a language for specifying queries. This is more verbose than a REST API: with REST, the query is embedded in the URL itself; in GraphQL, we specify the endpoint that we’re calling (`user`) along with the argument (`id` with a value of `"123"`), and we also list every `User` field we want the server to return. This extra syntax is what makes GraphQL so flexible and explicit: it gives us an exact list of the data we are attempting to fetch.

We have a couple options if we want to run this query and get the data back from the server. To start, let’s use the command line to show how a typical query might be executed:

```sh
$ curl -X POST -H "Content-Type:application/json" \
>     -d '{"query": "{user(id: \"123\"){_id username}}"}' \`
>     http://localhost:3000/graphql
{"data":{"user":{"_id":"123","username":"jeresig"}}}
```

We’re submitting our query as a POST request to the GraphQL endpoint and getting back a JSON response, like with the REST API. The response format is a bit different—our data is returned inside the `"data"` property, and the structure of the data matches our GraphQL query.

What happens when we attempt to query for a user that doesn’t exist? Does it return a 404 like with a REST API?

```sh
$ curl -X POST -H "Content-Type:application/json" \
>     -d '{"query": "{user(id: \"123\"){_id username}}"}' \
>     http://localhost:3000/graphql
{"data":{"user":null}}
```
No, in fact! Every time we query a GraphQL endpoint, we get a valid JSON response. In this case `"user"` is `null`, as its value wasn’t able to be determined. This becomes very useful when we handle permissions and errors, which we’ll get into [later](#security-&-error-handling).

When we run our server (`node graphql-server.js`) and visit [localhost:3000/graphql](http://localhost:3000/graphql) in the browser, we see the fantastic, easy-to-use web interface called GraphiQL (with an “i” and pronounced “graphical”):

![GraphiQL web interface](/img/graphiql.jpg)
*The results returned from a query inside the GraphiQL web interface.*

> You can also try out a hosted version here: [ch1.graphql.guide/graphql](https://ch1.graphql.guide/graphql)

Seeing or using GraphiQL for the first time is often the moment that software engineers become GraphQL converts.  It offers an an intuitive interface to read the documentation for and query a GraphQL schema. We can write a query, see the results returned from the server, and explore the documentation on the right that’s been automatically generated from the schema. This is something that REST can’t replicate without a ton of extra work or an additional framework. GraphQL is only just starting to pay off, though—we’ll see that as the REST API becomes more and more complex, the complexity of the equivalent GraphQL API remains the same.

# Querying a set of data

If we want to expand our REST API to allow for querying all of the users in our database, we need to add a new endpoint:

[`rest-server.js`](https://github.com/GraphQLGuide/graphql-rest-api-demo/blob/master/rest-server.js):

```js
// Listen for all GET requests to /users
server.get('/users', (req, res) => {
  // Find all of the users in the database collection (we pass in
  // an empty collection as we aren't filtering the results)
  User.find({}, (err, users) => {
    if (err) {
      // The DB returned an error so we return a 500 error
      return res.status(500).end()
    }

    // Return the array of users to the client (automatically
    // serialized as a JSON string)
    res.send(users)
  })
})
```

Like before, we can do a GET request to the new `/users` endpoint to see the user data returned as an array of objects:

```sh
$ curl http://localhost:3000/users
[{"_id":"123","username":"jeresig"},{"_id":"456","username":"lorensr"}]
```

With our GraphQL endpoint, we can achieve a similar result by adding a `users` query to our schema:

```gql
type Query {
  user(id: String!): User
  users: [User]
}
```

And by adding an associated loader for that data, which is just a single function:

[`graphql-server.js`](https://github.com/GraphQLGuide/graphql-rest-api-demo/blob/master/graphql-server.js)

```js
// The query fields that we'll use to get the data for our
// main queries
rootValue: {
  user({ id }) { … },
  // Get an array of users and return them as a Promise
  users() {
    return User.find({})
  }
},
```

And that’s all we need! The query syntax changes ever so slightly to make this new `users` query, but the rest of it stays intact. We still ask for the fields on the `User` type that we want, but we do so with the same syntax, even though we’re operating against a set of users (rather than a single object). The query:

```gql
query {
  users {
    _id
    username
  }
}
```

This is one of the beauties of GraphQL: it’s designed to scale easily from a single object to multiple with little change in our code. The result is as we would expect—it’s just an array of user objects on the `"users"` attribute.

```json
{"data":{"users":[{"_id":"123","username":"jeresig"},{"_id":"456","username":"lorensr"}]}}
```

Now that we have the basics out of the way, let’s look at some of the advanced features of REST APIs that GraphQL makes trivial.

# Filtering the data

In most REST APIs we are implicitly asking the endpoint to return all data, completely unfiltered. This could result in a potentially large request being sent back to the user along with a number of time- or resource-intensive sub-queries being executed to load particular fields or child data. All together that means a slow response time, especially on mobile. Many large REST APIs will end up adding a process for filtering the fields returned. For example, if we pass in a query string to our REST API that was something like `?fields=username` then we’d expect that the returned object(s) would only include the `username` field. We can achieve this by writing a function to filter the fields:

[`rest-server.js`](https://github.com/GraphQLGuide/graphql-rest-api-demo/blob/master/rest-server.js)

```js
// Filter a user object based on the requested fields
const filterFields = (req, user) => {
  const { fields } = req.query

  // If no fields were specified we return all of them
  if (!fields) {
    return user
  }

  // Otherwise we assume the fields are a comma-separated
  // list of field names, and we generate a new object that
  // contains only those fields.
  const filteredUser = {}
  for (const field of fields.split(',')) {
    filteredUser[field] = user[field]
  }
  return filteredUser
}
```

And then we need to ensure that every time we send a user object, we filter it to only contain the fields requested by the client. Note the altered `res.send()` lines at the end of each endpoint’s handler function:

```js
// Listen for all GET requests to /users/:id URL (where the
// ID is the ID of the user account)
server.get('/users/:id', (req, res) => {
  // Try to find the user by their id (_id field), using the ID
  // parameter from the URL.
  User.findById(req.params.id, (err, user) => {
    if (err) {
      // The DB returned an error so we return a 500 error
      return res.status(500).end()
    }

    if (!user) {
      // No user was found so we return a 404 error
      return res.status(404).end()
    }

    // Return the user to the client (automatically serialized
    // as a JSON string)
    res.send(filterFields(req, user))
  })
})

// Listen for all GET requests to /users
server.get('/users', (req, res) => {
  // Find all of the users in the database collection (we pass in
  // an empty collection as we aren't filtering the results)
  User.find({}, (err, users) => {
    if (err) {
      // The DB returned an error so we return a 500 error
      return res.status(500).end()
    }

    // Return the array of users to the client (automatically
    // serialized as a JSON string)
    res.send(users.map(user => filterFields(req, user)))
  })
})
```

We can test to ensure it’s working when querying a single user:

```sh
$ curl http://localhost:3000/users/123
{"_id":"123","username":"jeresig"}

$ curl http://localhost:3000/users/123?fields=username
{"username":"jeresig"}

$ curl http://localhost:3000/users/123?fields=_id,username
{"_id":"123","username":"jeresig"}
```

And also when querying all users:

```sh
$ curl http://localhost:3000/users
[{"_id":"123","username":"jeresig"},{"_id":"456","username":"lorensr"}]

$ curl http://localhost:3000/users?fields=username
[{"username":"jeresig"},{"username":"lorensr"}]

$ curl http://localhost:3000/users?fields=_id,username
[{"_id":"123","username":"jeresig"},{"_id":"456","username":"lorensr"}]
```

With GraphQL, filtering is available by default. Remember how we had to specify which user fields we wished returned? GraphQL effectively requires that we specify a “fields” filter for every object. If we wanted to just fetch the `username` fields with GraphQL, the query would look like this:

```gql
query {
  users {
    username
  }
}
```

And the response would only include the fields that were specified:

```json
{"data":{"users":[{"username":"jeresig"},{"username":"lorensr"}]}}
```

Our field-filtering example is trivial: an object without any child objects. What would happen if the user object had a child object that also had fields we wished to include or exclude? What if some excluded fields took extra time to fetch from the database, and instead of just filtering them out, we wanted to avoid fetching them in the first place? The implementation of these things in the REST API sounds quite intimidating, so we’ll leave that as an exercise to the reader 😁. With GraphQL, it’s just a matter of specifying the fields we wish to include in our query. Having a standard method of field specification means that it’s easier for the server to avoid loading or querying unnecessary data from the database, and we can track precisely which fields are being used and which aren’t. This is exciting, as we can use the field usage information to improve our database or help with migrating to a new schema. All of these benefits will be discussed in depth in this book.

# Async data loading

The data-loading code we’ve written so far has a simplistic structure: all of the data is held directly by the model. That’s easy to manage in a REST API, but it gets harder when we want to return subobjects. For example, if each user were in a group, and we wanted that group’s object to be returned along with the user, the code would become much more complex. Let’s see what that would look like.

We need to update the `users` collection with a new `groupId` field:

![users collection with groupIds in MongoDB](/img/users-groupid-mongo.jpg)
*The updated user models with a new `groupId` field in the MongoDB database.*

`groupId` refers to a group in the `groups` collection. A group has `_id` and `name` fields:

![groups collection in MongoDB](/img/groups-mongo.jpg)
*The new group models in the MongoDB database.*

We’d like to have the group object available as a property on the User model instead of the `groupId`:

```sh
$ curl http://localhost:3000/users/123
{"_id":"123","username":"jeresig","group":{"_id":"dev","name":"Developers"}}
```

Our first coding step is creating a Group model (which we’ll use for both the REST and GraphQL implementations) to hold the Group details, and then we’ll add a method to the User model for retrieving its associated Group (returning a Promise that resolves to that group).

[`models.js`](https://github.com/GraphQLGuide/graphql-rest-api-demo/blob/master/models.js):

```js
// Create a Group schema to be stored in the MongoDB database
const GroupSchema = new mongoose.Schema({
  _id: String,
  name: String
})

// Turn that schema into a model that we can query
const Group = mongoose.model('Group', GroupSchema)

// Create a User schema to be stored in the MongoDB database
const UserSchema = new mongoose.Schema({
  _id: String,
  username: String,
  groupId: String
})

// Retrieve the group associated with the user
UserSchema.methods.group = function() {
  // Use .exec() to ensure a true Promise is returned
  return Group.findById(this.groupId).exec()
}

// Turn that schema into a model that we can query
const User = mongoose.model('User', UserSchema)

module.exports = { User, Group }
```

We don’t want to ever return the `groupId` field—instead we just want to return the group object (which can only be obtained by resolving the Promise returned from the `.group()` method). We’ll need to update our application code in a number of ways to handle all of this asynchronous data loading. To start, we can update `filterFields()` to work asynchronously and resolve the Promises if they exist:

[`rest-server.js`](https://github.com/GraphQLGuide/graphql-rest-api-demo/blob/master/rest-server.js)

```js
// A list of the fields that are allowed to be accessed
const defaultFields = ['_id', 'username', 'group']

// Filter a user object based on the requested fields
const filterFields = async function(req, user) {
  // We assume the fields are a comma-separated list of field
  // names, if none is specified then we return all fields.
  const fieldKeys = req.query.fields
    ? req.query.fields.split(',')
    : defaultFields

  // Generate a new object that contains only those fields.
  const filteredUser = {}
  for (const field of fieldKeys) {
    // If the field is a function then we expect it to return
    // a Promise which we will immediately resolve.
    if (typeof user[field] === 'function') {
      filteredUser[field] = await user[field]()
    } else {
      filteredUser[field] = user[field]
    }
  }
  return filteredUser
}
```

We have to add a list of `defaultFields`, as we want to ensure that `group` is included and `groupId` is excluded. Now we can use our new asynchronous function in our API endpoints. For the first, we just make the `findById` callback `async` and `await filterFields()` before sending the response. For the second, we have to use `Promise.all()`:

```js
// Listen for all GET requests to /users/:id URL (where the
// ID is the ID of the user account)
server.get('/users/:id', (req, res) => {
    // Try to find the user by their id (_id field), using the ID
    // parameter from the URL.
    User.findById(req.params.id, async (err, user) => {
        if (err) {
            // The DB returned an error so we return a 500 error
            return res.status(500).end()
        }

        if (!user) {
            // No user was found so we return a 404 error
            return res.status(404).end()
        }

        // Return the user to the client (automatically serialized
        // as a JSON string). We need to wait for all of the fields
        // to load before we can return the results.
        res.send(await filterFields(req, user))
    })
})

// Listen for all GET requests to /users
server.get('/users', (req, res) => {
  // Find all of the users in the database collection (we pass in
  // an empty collection as we aren't filtering the results)
  User.find({}, async (err, users) => {
    if (err) {
      // The DB returned an error so we return a 500 error
      return res.status(500).end()
    }

    // Return the array of users to the client (automatically
    // serialized as a JSON string) We need to wait for all
    // of the Promises to resolve for all of the users.
    res.send(await Promise.all(users.map(user => filterFields(req, user))))
  })
})
```

This solution works exactly as we expect it to, returning a group object along with the other fields:

```sh
$ curl http://localhost:3000/users/123
{"_id":"123","username":"jeresig","group":{"_id":"dev","name":"Developers"}}

$ curl http://localhost:3000/users/123?fields=username,group
{"username":"jeresig","group":{"_id":"dev","name":"Developers"}}

$ curl http://localhost:3000/users
[{"_id":"123","username":"jeresig","group":{"_id":"dev","name":"Developers"}},{"_id":"456","username":"lorensr","group":{"_id":"author","name":"Authors"}}]

$ curl http://localhost:3000/users?fields=username,group
[{"username":"jeresig","group":{"_id":"dev","name":"Developers"},{"username":"lorensr","group":{"_id":"author","name":"Authors"}}]
```

The code has become harder to follow and understand—there’s no longer a clean one-to-one relationship between the data on the model and what we want to return, and handling asynchronous functions ramped up the complexity.

Let’s compare this solution with how it would work in GraphQL. We already have the changes to the Mongoose models, so we start out by updating the GraphQL schema to represent the new Group type:

```gql
type Group {
  _id: String
  name: String
}

type User {
  _id: String
  username: String
  group: Group
}
```

And… that’s it. That’s all the work that we need to do (beyond the minor changes that were made to the Mongoose models). We can open GraphiQL to try out our new field and see that it works immediately:

![Users with their groups in GraphiQL](/img/users-with-groups.jpg)
*The results for all users and their groups inside the GraphiQL web interface.*

GraphQL automatically handles values that are returned as Promises. The GraphQL server attempted to resolve the `group` field by executing the User model’s `.group` method and waiting until the Promise resolved before including the value.

Notice that because GraphQL requires filtering fields by specifying their names, we also have field filtering on the group submodel. We don’t have this in our REST API implementation.

It’s also important to note that GraphQL follows a best practice: it doesn’t query for any data that it doesn’t need. If the user never explicitly requests the `group` field, then the server won’t perform the database query to retrieve it. Following GraphQL’s patterns will result in an API that’s designed correctly—and optimally—from the get-go.

As the complexity of our data model starts to increase, so does the complexity of the implementation of our REST API (which is, due to all the features we’ve added to it, arguably already approaching unmaintainable levels of complexity). In contrast, GraphQL scales very gracefully: multiple models are no more challenging than one, and asynchronous data is just as easy as synchronous.

# Multiple types of data

Thus far we’ve been retrieving data in a way that is stylistically similar to the REST API endpoint: we request a single user, or a list of users, and that’s it. Retrieving data in this way aligns well with the expectations of a normal, well-designed REST API. However, fundamentally, a REST API is not designed for the data requirements of a modern application. Modern applications need to access many different types of data simultaneously in order to successfully render a result. An app might need to show not just a User but also their Posts and the Comments.

The client should be in control of requesting the data they want from the server. Ideally, this should be done in a single HTTP request. With REST, we can either make multiple HTTP requests to get the different types of data we need for a page, or we can design a custom REST endpoint that returns everything all at once. GraphQL employs a different strategy: a GraphQL endpoint can return many types and execute many queries, not just one. This gives the caller the power of being able to fetch any and all data needed in a single request.

If we want to request multiple types of data with a basic REST API—one in which each endpoint deals with a single type—our client code might look something like this:

```js
const getUserWithGroup = user =>
  fetch(`http://localhost:3000/groups/${user.groupId}`)
    .then(response => response.json())
    .then(group => ({
      ...user,
      group
    }))

fetch('http://localhost:3000/users')
  .then(response => response.json())
  .then(users => Promise.all(users.map(getUserWithGroup)))
  .then(usersWithGroups => {
    console.log(usersWithGroups)
  })
```

First we request the users from the server, and once they’ve been returned, we request each user’s group. Once all the groups are returned, we have an array of full user objects to use. Here is the equivalent code using our GraphQL API:

```js
import { request } from 'graphql-request'

const query = `{ 
  users { 
    username 
    group { 
      name 
    } 
  } 
}`

request('http://localhost:3000/graphql', query).then(({ users }) => {
  console.log(users)
})
```

We don’t have to wait for two round-trip requests to the server, and we don’t have to write code to manage the Promises or combine the data in the response objects. 

As the complexity of a query scales, the conciseness of GraphQL becomes increasingly compelling. Let’s say we wanted to get the current `User`, their `Post`s, and each posts’s `Comment`s:


```js
import { request } from 'graphql-request'

const query = `{ 
  currentUser { 
    username 
    posts {
      title
      comments {
        text
        createdAt
      }
    }
  } 
}`

request('http://localhost:3000/graphql', query).then(({ currentUser }) => {
  console.log(currentUser)
})
```

We get back a user object that has a list of posts, and each post has a list of comments. The equivalent REST logic is even more complicated than our `usersWithGroups` example, the latency would increase to three round trips (first for the user, then for their posts, and then once we have the posts, for the posts’ comments), and the total number of requests would be very high. For example, if the user had 5 posts, each of which had 4 comments, we’d be sending 26 requests: 1 to get the user, 5 to get the posts, and 5 * 4 = 20 to get all the comments.

We could simplify the REST client code and reduce latency by adding more complexity to our REST API. Instead of our endpoints dealing with a single type, we could have them return multiple types, as we did for the user’s `group` field in the last section. We could also get all the current user’s post and comment data with `http://localhost:3000/currentUser?fields=posts,posts_comments`, but it would require more complex logic for filtering nested fields.

We’ve looked at the differences between using a REST API and a GraphQL API to fetch a single type that has fields of other types, but what about fetching multiple different top-level types? If we’re implementing an app’s homepage, we might want the current user’s name and photo, a list of their recent notifications, and a list of the most recent posts. We could fetch that in three requests with `/currentUser`, `/notifications`, and `/posts`, but if we wanted to fetch all the data in a single request, we would need a view-specific endpoint, for example `/homepage`. There are a few issues with building and maintaining view-specific endpoints. Between all our client platforms—for example, web, iOS, and Android—we could have a lot of views, which means a lot of endpoints to code. Even if the endpoints are all using the same model layer for database access, there’s still the logic of putting together the response object and supporting any query parameters we might want. When we remove a part of a view—for instance, the recent posts from the homepage—the client is overfetching (getting more data than it needs) until we update the `/homepage` endpoint. And when we want to add new parts to views, we need to wait for the backend team to add the required data to the endpoint. Add versioning to all these changing endpoints in order to keep supporting older native clients (or older developer integrations, in the case of public APIs), and we’ve got a huge mess.

Fetching multiple top-level types from a GraphQL API doesn’t require that much new code. Let’s say we wanted to get a list of all of the Users and Groups in our database in a single request. We have to add in the new access points to get the Group data, like we did for the User:

[`graphql-server.js`](https://github.com/GraphQLGuide/graphql-rest-api-demo/blob/master/graphql-server.js):

```js
// Get the Mongoose models used for querying the database
const {User, Group} = require('./models.js')

// Start up a GraphQL endpoint listening at /graphql
server.use(
  '/graphql',
  graphqlHTTP({
    schema: buildSchema(`
        …

        type Query {
            user(id: String!): User
            users: [User]
            group(id: String!): Group
            groups: [Group]
        }
    `),
    // The query fields that we'll use to get the data for our
    // main queries
    rootValue: {
      user({id}) { … },
      users() { … },

      // Get a group based on the ID and return it as a Promise
      group({id}) {
        return Group.findById(id)
      },
      // Get an array of groups and return them as a Promise
      groups() {
        return Group.find({})
      }
    }
  })
)
```

And now it works! If we load up our GraphiQL web interface, we can see that we not only have access to the existing `user` and `users` query fields, but also to the new `group` and `groups` fields. More importantly, we can include multiple query fields in a single request:

![One query for both users and groups in GraphiQL](/img/users-and-groups.jpg)
*The results for all users and all groups inside the GraphiQL web interface.*

Here, we’ve retrieved a list of all the users along with the group they’re in. Additionally, we’ve retrieved a complete list of all the groups in the database, and all of this information was retrieved in parallel.

What’s especially nice is that we don’t have to limit ourselves to just lists of data—we can mix in any number of query fields, like the `group` query field:

![One query for users, groups, and a group in GraphiQL](/img/users-groups-and-group.jpg)
*The results for all users, groups, and a single group inside the GraphiQL web interface.*

In this case, we’re requesting three query fields simultaneously (getting a list of all users, a list of all groups, and also a specific group) and returning all the data in a single request. This represents a level of customization and flexibility that is quite challenging to implement with a traditional REST API. 

In summary, the advantages of using GraphQL for fetching multiple data types are:

- **The client retains control over its data requirements:** Instead of the REST endpoint dictating the queries being run and the data returned, the client can specify the queries and the desired data and get it all back in a single request.
- **Simpler server:** The server doesn’t have to attempt to permute all of the possible desired endpoints. This helps reduce the cost and surface area for the API. We don’t have to know about all the use cases or platforms that the data will eventually appear in, so the implementation becomes much simpler and easier to maintain.
- **Fewer requests:** It reduces the number of distinct requests for data, and thus the burden on both the client and the server. If we were to request three different pieces of data from a REST API, it could potentially require three different endpoints and three distinct HTTP requests. With GraphQL, we’re guaranteed to have a single request and the same unchanged implementation.
- **Faster:** It reduces the latency in the overall request by allowing most of the data loading to be done on the server rather than the client (which has to wait for the current HTTP request to complete before initiating any other requests that depend on the current request’s response).

# Security & error handling

When it comes to the security of our data (validating the permissions of those that are attempting to access it) and the handling of errors, REST APIs have an idiomatic solution: returning a specific error code. For example, if we attempt to access data which we don’t have permission to access, we might get an HTTP 403 Forbidden code in response. If our request results in an error, then we might get an HTTP 500 Internal Server Error code. Some REST APIs might include detailed information on the failure inside the response body (such as the error message or the specific data that we don’t have permission to access), but the error codes are generally used to designate the class of error, not the specific error itself.

In GraphQL every request is expected to return a result, even if that result doesn’t have the data we request. GraphQL tends to treat security and error-handling issues similarly. If there’s a problem with accessing a specific piece of data, then `null` is returned in its place. This calls for a defensive, but smart, way of coding an application. Since no field is guaranteed to be there, we need to ensure that it exists before attempting to use it.

For example, let’s say the MongoDB server wasn’t running. The output from our server might look something like this:

```json
{
  "errors": [
    {
      "message": "failed to reconnect after 30 attempts with interval 1000 ms",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": [
        "users"
      ]
    }
  ],
  "data": {
    "users": null
  }
}
```

In this case, the `"users"` property ends up being `null`, and there’s an additional `"errors"` property that has a list of errors that were thrown, including where each error came from—the field name and the location in the query.

Whether a user doesn’t have permission to access a piece of information or the data doesn’t exist, the end result is similar: the user doesn’t get that data and is given a `null` result instead, like in the following:

![null group result in GraphiQL](/img/null-group.jpg)
*An example of a failed load for a group child object inside the GraphiQL web interface.*

In this case, we either didn’t have an associated group or we didn’t have permission to access that group, so we were given a `null` value. GraphQL gives the user as much data as it possibly can, leaving out anything that’s missing (for one reason or other). This also allows the application to render a version of the site that has some portion of the interface available, and allows it to make note of missing information, rather than displaying a general “Error!” message that contains no context.

GraphQL’s design provides a level of consistency that should be greatly appreciated by all developers. Every request will return a valid JSON response (unless something goes very wrong). There is no guarantee that the response will contain all of the data we request, so we end up building more resilience into our application. This should be a best practice, as it provides an optimal experience to the user.

# Tying this all together

REST APIs have served us well for many years. They’ve made data access for many applications easy to understand and implement. However, as we’ve seen in this chapter, this simplistic approach belies the true complexity of implementing a full API that supports a modern web or mobile application.

In a modern application, the consumer needs to be in control of what data they can request. A single page may have many different data models represented in it, and short of writing a unique REST endpoint for every page of a site, REST simply doesn’t have the flexibility to allow applications to request the data they need at all times.

While GraphQL has a number of new concepts to learn (GraphQL schemas, the query language, etc.), these features are designed to help us write our applications correctly from the start—whereas the prospect of building a comparable REST API can be absolutely overwhelming in its complexity.

GraphQL truly is the most developer-friendly way of building an API. It puts the consumer in full control of the data requested, and as such we avoid querying data that we don’t need. As an added bonus, there is clear, automatically-generated documentation we can browse to understand any new GraphQL API.

The developers of GraphQL learned from REST’s challenges and mistakes over the years, and have turned the best parts into a streamlined interface that will surely be the standard for API design for many years to come. The rest of this book will dive deep into the benefits of GraphQL, how to implement it efficiently, and how to build the best applications using this technology.
