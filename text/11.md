# Chapter 11: Server Dev

Chapter contents:

* [Introduction](11.md#introduction)
  * [Why build a GraphQL server?](11.md#why-build-a-graphql-server)
  * [What kind of GraphQL server should I build?](11.md#what-kind-of-graphql-server-should-i-build)
* [Building](11.md#building)
  * [Project setup](11.md#project-setup)
  * [Types and resolvers](11.md#types-and-resolvers)
  * [Authentication](11.md#authentication)
  * [Data sources](11.md#data-sources)
    * [Setting up](11.md#setting-up)
    * [File structure](11.md#file-structure)
    * [Creating reviews](11.md#creating-reviews)
  * [Custom scalars](11.md#custom-scalars)
  * [Creating users](11.md#creating-users)
    * [Protecting with secret key](11.md#protecting-with-secret-key)
    * [Setting user context](11.md#setting-user-context)
    * [Linking users to reviews](11.md#linking-users-to-reviews)
  * [Authorization](11.md#authorization)
  * [Errors](11.md#errors)
    * [Nullability](11.md#nullability)
    * [Union errors](11.md#union-errors)
    * [formatError](11.md#formaterror)
      * [Logging errors](11.md#logging-errors)
      * [Masking errors](11.md#masking-errors)
    * [Error checking](11.md#error-checking)
    * [Custom errors](11.md#custom-errors)
  * [Subscriptions](11.md#subscriptions)
    * [githubStars](11.md#githubstars)
    * [reviewCreated](11.md#reviewcreated)
  * [Testing](11.md#testing)
    * [Static testing](11.md#static-tests)
    * [Review integration tests](11.md#review-integration-tests)
    * [Code coverage](11.md#code-coverage)
    * [User integration tests](11.md#user-integration-tests)
    * [Unit tests](11.md#unit-tests)
    * [End-to-end tests](11.md#end-to-end-tests)
* [Production]()
  * [Deploying]()
  * [Error reporting]()
  * [Analytics]()
  * [Security]()
* [More data sources]()
  * [SQL]()
  * [REST]()
  * [Redis]()
  * [Elasticsearch]()
  * [Custom data source]()
  * [Prisma]()
* Extended topics
  * Pagination
  * File uploads
  * Mocking
  * Schema design
  * Schema federation
  * Schema change validation
  * Subscription design
  * Auth options
  * Custom schema directives
  * Caching
  * Performance
  * Future

---

# Introduction

Background: [HTTP](bg.md#http), [Server](bg.md#server)

Welcome to the server chapter! This is the last—and longest—chapter. We’ll learn most of the concepts through building the Guide API server, which backs the apps we built in the client chapters. The server will primarily store data in MongoDB, but we’ll also connect to several other data sources, including SQL and REST. We’ll write it in JavaScript, but all server-side GraphQL libraries use [the same execution method](4.md), and most of the concepts in this chapter will apply to writing GraphQL servers in other languages. To see the differences, check out one of these backend tutorials:

- [Java](https://www.howtographql.com/graphql-java/0-introduction/)
- [Python](https://www.howtographql.com/graphql-python/0-introduction/)
- [Ruby](https://www.howtographql.com/graphql-ruby/0-introduction/)
- [Scala](https://www.howtographql.com/graphql-scala/0-introduction)
- [Elixir](https://www.howtographql.com/graphql-elixir/0-introduction/)

There are also GraphQL libraries in these languages:

- [.NET](https://github.com/graphql-dotnet/graphql-dotnet)
- [Clojure](https://github.com/walmartlabs/lacinia)
- [Go](https://github.com/graphql-go/graphql)
- [PHP](https://github.com/webonyx/graphql-php)

This chapter is split into five parts:

* **Introduction**
* **[Building](11.md#building)**
* **[Production]()**
* **[More data sources]()**
* **[Extended topics]()**

In **Building**, we build a GraphQL server from scratch, including authentication and authorization, Query and Mutation resolvers that talk to a database, error handling, subscriptions, and testing. In **Production**, we deploy our server and update it with things that are helpful to have in production, like error reporting, analytics, and security against attack. In **More data sources**, we connect our server to other databases and a REST API. In **Extended topics**, we learn about various new topics and go into more depth on previous topics like the schema, subscriptions, and auth.

## Why build a GraphQL server?

There are three main reasons why we might decide our server should be a GraphQL server:

1. So we can use GraphQL on the client and gain all the client-side benefits of GraphQL.
2. To simplify our server code: instead of setting up many endpoints and implementing fetching and formatting logic for each, we set up one endpoint and write a single resolver for each data type.
3. To avoid having to create new endpoints or new APIs in the future.

For coders, #1 and #2 are often the most compelling, because it improves our quality of life 😄. For companies, #3 is often the most compelling, since they save time and money: they get a single, flexible API that covers all their business data, which means that instead of having to create new endpoints or APIs for new features or apps, they can just use their existing GraphQL API (and in some cases add fields and resolvers).

## What kind of GraphQL server should I build?

There are two situations we might be in:

1. **Existing project**, in which case we’ll either be adding a GraphQL layer in front of our existing servers or adding a GraphQL endpoint to existing servers.
2. **New project** (a.k.a. *greenfield*), in which case we have a choice of which architecture to use.

There are two main architectures:

1. **Microservices** (a collection of servers that each cover a different business capability). GraphQL as the API gateway: the client talks to the GraphQL server API gateway, which talks to services (via GraphQL, REST, gRPC, Thrift, etc), which talk to databases.
2. **Monolith** (a single server that covers all business logic). GraphQL as the application layer: the client talks to the GraphQL server, which talks directly to databases.

Microservices are in vogue and the word “monolith” is often used with a scornful tone, but in most cases, it’s better to have a monolith. Martin Fowler, one of the leaders in software design, [wrote](https://martinfowler.com/bliki/MicroservicePremium.html):

> So my primary guideline would be don’t even consider microservices unless you have a system that’s too complex to manage as a monolith. The majority of software systems should be built as a single monolithic application. Do pay attention to good modularity within that monolith, but don’t try to separate it into separate services.

While there are a lot of huge tech companies that use microservices and are better off for it, they’re better off because they’re huge—not because microservices are a general good practice.

If we have an existing monolith, it often makes sense to add a GraphQL endpoint to that server instead of putting a GraphQL server in front of the monolith. For example, if we have an Express monolith that has a lot of thin REST routes that call model functions that contain the business logic, then it would be easy to add a `/graphql` route with [`apollo-server-express`](https://www.apollographql.com/docs/apollo-server/essentials/server#middleware) and implement resolvers that called the same model functions as the REST routes.

When we’re adding a GraphQL layer in front of an existing backend, whether it’s a microservices or monolith backend, we can make the choice between continuing to develop the existing backend or gradually moving logic to the GraphQL layer. If we’re doing microservices and want to keep that architecture, then it’s easy to keep implementing services (in whatever language(s) we implement services) and expanding the schema in the GraphQL gateway.

Another question is what language to write our GraphQL server in. In the case of adding to an existing monolith, we’ll use the GraphQL server library for the same language. In all other cases (new projects or a GraphQL layer in front of existing microservices or monoliths), we generally recommend JavaScript. It’s by far the most popular type of GraphQL server, and has thus developed the best ecosystem of libraries and services.

The server we’ll be creating in this chapter is a greenfield monolith, so it will talk directly to the database. However, most of the concepts will carry over to the microservice model. The largest difference will be either:

- fetching data and resolving mutations by talking to the services (e.g. with REST) instead of the database
- using schema federation to combine multiple GraphQL services

We’ll go over both of these options later in the chapter.

# Building

Background: [Node & npm & nvm](bg.md#node-&-npm-&-nvm), [git](bg.md#git), [JavaScript](bg#javascript)

* [Project setup](11.md#project-setup)
* [Types and resolvers](11.md#types-and-resolvers)
* [Authentication](11.md#authentication)
* [Data sources](11.md#data-sources)
  * [Setting up](11.md#setting-up)
  * [File structure](11.md#file-structure)
  * [Creating reviews](11.md#creating-reviews)
* [Custom scalars](11.md#custom-scalars)
* [Creating users](11.md#creating-users)
  * [Protecting with secret key](11.md#protecting-with-secret-key)
  * [Setting user context](11.md#setting-user-context)
  * [Linking users to reviews](11.md#linking-users-to-reviews)
* [Authorization](11.md#authorization)
* [Errors](11.md#errors)
  * [Nullability](11.md#nullability)
  * [Union errors](11.md#union-errors)
  * [formatError](11.md#formaterror)
    * [Logging errors](11.md#logging-errors)
    * [Masking errors](11.md#masking-errors)
  * [Error checking](11.md#error-checking)
  * [Custom errors](11.md#custom-errors)
* [Subscriptions](11.md#subscriptions)
  * [githubStars](11.md#githubstars)
  * [reviewCreated](11.md#reviewcreated)
* [Testing](11.md#testing)
  * [Static testing](11.md#static-tests)
  * [Review integration tests](11.md#review-integration-tests)
  * [Code coverage](11.md#code-coverage)
  * [User integration tests](11.md#user-integration-tests)
  * [Unit tests](11.md#unit-tests)
  * [End-to-end tests](11.md#end-to-end-tests)

We’re using Node because it’s the most popular platform for GraphQL Servers and has the best ecosystem. JavaScript is also the most used programming language in the world! Ⓙ🌎Ⓢ

## Project setup

There are a few different things to set up when starting a new Node project. We’ve set them up in branch `0` of our server repo, [github.com/GraphQLGuide/guide-api](https://github.com/GraphQLGuide/guide-api): 

```sh
$ git clone https://github.com/GraphQLGuide/guide-api.git
$ cd guide-api/
$ git checkout 0_0.1.0
$ npm install
```

We now have these files:

```
.babelrc
.git/
.gitignore
.nvmrc
.prettierrc
node_modules/
package-lock.json
package.json
```

Let’s look at each to see what they’re for. 

- [`.babelrc`](https://github.com/GraphQLGuide/guide-api/blob/0_0.1.0/.babelrc):

```json
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "targets": {
          "node": "8.11.3"
        }
      }
    ]
  ],
  "plugins": ["import-graphql"]
}
```

`@babel/preset-env` transpiles JavaScript to work in the target environment—where we’ll be running the code. In chapter 6, that was the browser. For this chapter, the target environment is Node. We’ll target version `8.11.3` so that the transpiled code will work in that or higher versions.

- `.git/`: directory where git stores its data.
- `.gitignore`:

```
node_modules/
dist/
```

A list of which files/folders we don’t want committed to git. We don’t want `node_modules/` because they’re added when we `npm install`. And `dist/` will be generated by a build script in our `package.json`.

- `.nvmrc`: 

```
8
```

The file that tells nvm which version of Node to use. `8` means the latest stable `8.*.*` version.

- `.prettierrc`:

```
singleQuote: true
semi: false
```

Because that’s the One True Way to style JavaScript. 

> Just kidding—there isn’t one right way to style code. This is just author Loren’s preference 😄.

- `node_modules/`: directory to which npm downloads all of the packages our code depends on.
- `package-lock.json`: precise current versions of all the packages.
- [`package.json`](https://github.com/GraphQLGuide/guide-api/blob/0_0.1.0/package.json):

```json
{
  "name": "guide-api",
  "version": "0.1.0",
  "description": "api.graphql.guide",
  "scripts": {
    "dev": "nodemon -e js,graphql --exec 'npm run update-graphql-imports && babel-node src/index.js'",
    "start": "node dist/index.js",
    "build": "babel src -d dist --ignore **/*.test.js",
    "update-graphql-imports": "rm -rf ./node_modules/.cache/@babel"
  },
  "engines": {
    "node": ">=8"
  },
  "dependencies": {
    "apollo-datasource-mongodb": "^0.1.0",
    "apollo-server": "^2.6.9",
    "apollo-server-testing": "^2.8.1",
    "date-fns": "^1.30.1",
    "dotenv": "^8.0.0",
    "graphql": "^14.2.1",
    "graphql-request": "^1.8.2",
    "jsonwebtoken": "^8.5.1",
    "jwks-rsa": "^1.4.0",
    "lodash": "^4.17.11",
    "mongodb": "^3.2.3"
  },
  "devDependencies": {
    "@babel/cli": "^7.4.4",
    "@babel/core": "^7.4.3",
    "@babel/node": "^7.2.2",
    "@babel/preset-env": "^7.4.3",
    "apollo-link": "^1.2.13",
    "apollo-link-http": "^1.5.16",
    "babel-plugin-import-graphql": "^2.7.0",
    "eslint": "^5.16.0",
    "eslint-plugin-node": "^8.0.1",
    "husky": "^3.0.5",
    "jest": "^24.8.0",
    "node-fetch": "^2.6.0",
    "nodemon": "^1.19.0"
  },
  "homepage": "https://github.com/GraphQLGuide/guide-api",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/GraphQLGuide/guide-api"
  },
  "bugs": {
    "url": "https://github.com/GraphQLGuide/guide-api/issues"
  },
  "private": true,
  "author": "The GraphQL Guide <hi@graphql.guide> (https://graphql.guide)"
}
```

Let’s look at the scripts first:

```json
  "scripts": {
    "dev": "nodemon -e js,graphql --exec 'npm run update-graphql-imports && babel-node src/index.js'",
    "start": "node dist/index.js",
    "build": "babel src -d dist --ignore **/*.test.js",
    "update-graphql-imports": "rm -rf ./node_modules/.cache/@babel"
  },
```

- `npm run dev` will watch our JS and GraphQL files, and whenever one of them changes, it will transpile them with Babel and run them with Node.
- `npm start` will start our server in production using the transpiled version of our code located in `dist/`.
- `npm run build` will transpile our code from `src/` to `dist/` (ignoring test files).
- `npm update-graphql-imports` is used by `npm run dev` to clear the babel GraphQL plugin cache.

The [`engines` attribute](https://docs.npmjs.com/files/package.json#engines), similar to `preset-env`’s `target`, describes where the code is meant to be run. For us, it’s meant to be run in any version 8 or higher of Node.

```
  "engines": {
    "node": ">=8"
  },
```

All together, what we’ve got configured is:

- Git
- npm
- nvm
- Babel
- Prettier

## Apollo Server

> If you’re jumping in here, `git checkout 0_0.1.0` (tag [0_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/0_0.1.0), or compare [0...1](https://github.com/GraphQLGuide/guide-api/compare/0_0.1.0...1_0.1.0))

It takes less than 20 lines of JavaScript to get a working GraphQL server up and running! 😃 The best GraphQL server library is [`apollo-server`](https://www.apollographql.com/docs/apollo-server/), and here’s the basic setup:

[`src/index.js`](https://github.com/GraphQLGuide/guide-api/blob/1_0.1.0/src/index.js)

```js
import { ApolloServer, gql } from 'apollo-server'

const server = new ApolloServer({
  typeDefs: gql`
    type Query {
      hello: String!
    }
  `,
  resolvers: {
    Query: {
      hello: () => '🌍🌏🌎'
    }
  }
})

server
  .listen({ port: 4000 })
  .then(({ url }) => console.log(`GraphQL server running at ${url}`))
```

The main export of `apollo-server` is [`ApolloServer`](https://www.apollographql.com/docs/apollo-server/api/apollo-server#apolloserver), and its two required parameters are:
- `typeDefs`: our schema, created with the [`gql`](https://www.apollographql.com/docs/apollo-server/api/apollo-server#gql) template literal tag.
- `resolvers`: an object of [resolver](4.md#resolvers) functions that match our schema in structure. Each type—`Query`, `Mutation`, `User`, `Chapter`, etc.—is a top-level attribute, and the next level is that type’s field names.

We start the server by calling [`.listen()`](https://www.apollographql.com/docs/apollo-server/api/apollo-server#apolloserverlistenoptions-promise) on a port. When it’s done starting up, the promise is resolved with the URL—in our case, `http://localhost:4000`.

We can test it out with our `dev` script:

```sh
$ npm run dev

> guide-api@0.1.0 dev /guide-api
> babel-watch src/index.js

GraphQL server running at http://localhost:4000/
```

After a moment, the program gets to the last line of our code, which logs `Server running at http://localhost:4000/`. When we edit `src/index.js`—for instance by changing `console.log`—the server gets restarted:

```sh
$ npm run dev

> guide-api@0.1.0 dev /guide-api
> babel-watch src/index.js

GraphQL server running at http://localhost:4000/
>>> RESTARTING <<<
GraphQL server running with new console.log statement at http://localhost:4000/
```

To stop the server, we can press the `control-c` key combination.

So we’ve got the server running, but does it work? Let’s open up the URL in a browser:

[http://localhost:4000](http://localhost:4000)

It loads GraphQL Playground, an IDE for writing GraphQL queries. We can see our tiny schema by clicking on “SCHEMA” on the right:

![Schema tab](img/hello-schema.png)

And we can test out our one `Query`:

![hello query](img/hello-world.png)

And it works!

## Types and resolvers

> If you’re jumping in here, `git checkout 1_0.1.0` (tag [1_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/1_0.1.0), or compare [1...2](https://github.com/GraphQLGuide/guide-api/compare/1_0.1.0...2_0.1.0))

The heart of a GraphQL server is the types and resolvers. The schema has the types and each type’s fields, and the resolvers *resolve* each field. We generally resolve fields by fetching data from a data source, formatting fetched data, or enacting mutations. 

Let’s add some more types and fields to get a better sense of how they match up with resolvers. We want people to be able to submit reviews for the book, so we need a mutation:

```gql
type Mutation {
  createReview(text: String!, stars: Int): Review
}
```

The convention for naming a creation mutation is `create<Type>`, and it usually resolves to that type (hence `: Review`). However, it’s best practice to use a single input type as an argument instead of listing out all the scalars needed. So let’s change it to:

```gql
type Mutation {
  createReview(input: CreateReviewInput!): Review
}
input CreateReviewInput {
  text: String!
  stars: Int
}
```

We also want people to be able to read past reviews, so we add a Query field:

```gql
type Query {
  hello: String!
  reviews: [Review!]!
}
```

We don’t have a `Review` type yet, so we need to add that

```
type Review {
  text: String!
  stars: Int
  fullReview: String!
}
```

All together, our new schema looks like this:

[`src/index.js`](https://github.com/GraphQLGuide/guide-api/compare/1_0.1.0...2_0.1.0)

```js
const server = new ApolloServer({
  typeDefs: gql`
    type Query {
      hello: String!
      reviews: [Review!]!
    }
    type Review {
      text: String!
      stars: Int
      fullReview: String!
    }
    type Mutation {
      createReview(review: CreateReviewInput!): Review
    }
    input CreateReviewInput {
      text: String!
      stars: Int
    }
  `,
  resolvers: { ... }
})
```

We need a resolver for each field except for the `input` type. (Input types are only used for mutation arguments. Fields can’t resolve to input types, so input types don’t need resolvers). The structure of our `resolvers` object matches the schema, so it should look like:

```js
const server = new ApolloServer({
  typeDefs: ...
  resolvers: {
    Query: {
      hello: () => 
      reviews: () => 
    },
    Review: {
      text: () => 
      stars: () => 
      fullReview: () => 
    }
    Mutation: {
      createReview: () => 
    },
  }
})
```

Now let’s fill them in! We’ll start with `createReview`:

```js
const reviews = [
  {
    text: 'Super-duper book.',
    stars: 5
  }
]

const server = new ApolloServer({
  typeDefs: ...
  resolvers: {
    ...
    Mutation: {
      createReview: (_, { review }) => {
        reviews.push(review)
        return review
      }
    }
  }
})
```

We don’t need the first resolver parameter, just the second, which contains the mutation argument—the review. We add it to our array of reviews and return it (since our schema says that `createReview` resolves to an object of type `Review`).

Next we can implement the `reviews` Query field:

```js
const reviews = [
  {
    text: 'Super-duper book.',
    stars: 5
  }
]

const server = new ApolloServer({
  typeDefs: ...
  resolvers: {
    Query: {
      hello: ...
      reviews: () => reviews
    }
  }
})
```

For `Query.reviews` we just return our array of reviews. But a GraphQL server doesn’t just return the `reviews` array to the client: it looks at the schema, sees that `Query.reviews` resolves to `[Review!]!`, checks to make sure the `reviews` array is non-null, and then resolves each object in the array as a `Review`. The way it does that is by calling `Review` field resolvers, which we also have to define:

```js
const reviews = [
  {
    text: 'Super-duper book.',
    stars: 5
  }
]

const server = new ApolloServer({
  typeDefs: ...
  resolvers: {
    Query: {
      hello: ...
      reviews: () => reviews
    },
    Review: {
      text: review => review.text
      stars: review => review.stars
      fullReview: review =>
        `Someone on the internet gave ${review.stars} stars, saying: "${
          review.text
        }"`
    }
  }
})
```

When the GraphQL server calls a `Review` field resolver, it provides the array object as the first parameter, for example: 

```js
{
  text: 'Super-duper book.',
  stars: 5
}
```

The `text` and `stars` type fields we can just resolve to the corresponding object properties (for example, `text: review => review.text`). And we can actually take the `text` and `stars` resolvers out, because Apollo Server will do that by default. The `fullReview` field isn’t present in the object, so we need to define it—we create the string using the review object’s properties.

All together, without the extraneous object property resolvers, we have:

[`src/index.js`](https://github.com/GraphQLGuide/guide-api/compare/1_0.1.0...2_0.1.0)

```js
import { ApolloServer, gql } from 'apollo-server'

const reviews = [
  {
    text: 'Super-duper book.',
    stars: 5
  }
]

const server = new ApolloServer({
  typeDefs: gql`
    type Query {
      hello: String!
      reviews: [Review!]!
    }
    type Review {
      text: String!
      stars: Int
      fullReview: String!
    }
    type Mutation {
      createReview(review: CreateReviewInput!): Review
    }
    input CreateReviewInput {
      text: String!
      stars: Int
    }
  `,
  resolvers: {
    Query: {
      hello: () => '🌍🌏🌎',
      reviews: () => reviews
    },
    Review: {
      fullReview: review =>
        `Someone on the internet gave ${review.stars} stars, saying: "${
          review.text
        }"`
    },
    Mutation: {
      createReview: (_, { review }) => {
        reviews.push(review)
        return review
      }
    }
  }
})

server
  .listen({ port: 4000 })
  .then(({ url }) => console.log(`GraphQL server running at ${url}`))
```

We can try it out with `npm run dev`, see that Playground loads, and try out the new query:

```gql
{
  reviews {
    text
    fullReview
  	stars
	}
}
```

![reviews query](img/reviews-playground.png)

[localhost:4000: `{ reviews { text fullReview stars } }`](http://localhost:4000/)

We see our one hard-coded review. Now if we do our mutation followed by the `reviews` query, we’ll see both that and the new review:

![createReview mutation](img/createReview-mutation.png)

[localhost:4000: `mutation { createReview(review: { text: "Passing", stars: 3 }) { text } }`](http://localhost:4000/)

![reviews query with two results](img/reviews-playground-two-results.png)

[localhost:4000: `{ reviews { text fullReview stars } }`](http://localhost:4000/)

Notice how the only things we changed in our server were our types (in the Apollo Server `typeDefs` parameter) and our resolvers. These two things (including code our resolver functions call) will be the bulk of the coding we do for our GraphQL server.

## Authentication

Background: [Authentication](bg.md#authentication)

> If you’re jumping in here, `git checkout 2_0.1.0` (tag [2_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/2_0.1.0), or compare [2...3](https://github.com/GraphQLGuide/guide-api/compare/2_0.1.0...3_0.1.0))

One thing that’s done outside of types and resolvers is creating *context*, which is an object provided to resolvers. We set context using the [`context` param](https://www.apollographql.com/docs/apollo-server/api/apollo-server#constructoroptions-apolloserver) of `ApolloServer()`. The `context` param is either an object or, more commonly, a function that returns an object. The function is called at the beginning of every request. The most common use of the `context` function is authenticating the user making the request and adding their info to the context. Here’s a small example:

[`src/index.js`](https://github.com/GraphQLGuide/guide-api/compare/2_0.1.0...3_0.1.0)

```js
const server = new ApolloServer({
  typeDefs: gql`
    type Query {
      me: User
      ...
    }
    type User {
      firstName: String
      lastName: String
    }
    ...
  `,
  resolvers: {
    Query: {
      me: (_, __, context) => context.user,
      ...
    },
    ...
  },
  context: () => {
    const user = {
      firstName: 'John',
      lastName: 'Resig'
    }

    return { user }
  }
})
```

Context is resolvers’ third parameter. For the `me` resolver, we just return the `user` property, which we hard-coded in the context function. We can try it out:

![me query](img/me-query.png)

[localhost:4000: `{ me { firstName lastName } }`](http://localhost:4000/)

Now let’s figure out the real user. The Guide uses JWTs, so authentication is done by cryptographically verifying the token provided in the request’s authorization header. We get the request as an argument to the [context function](https://www.apollographql.com/docs/apollo-server/api/apollo-server#parameters):

```js
import { getAuthIdFromJWT } from './util/auth'

const server = new ApolloServer({
  ...
  context: async ({ req }) => {
    const context = {}

    const jwt = req.headers.authorization
    const authId = await getAuthIdFromJWT(jwt)
    console.log(authId)

    return context
  }  
})
```

`getAuthIdFromJWT()` verifies the given JWT and returns what we’re calling the user’s *authId*—a unique string identifying the user that we get as the OpenID subject (`verifiedToken.sub` below). Here’s the function’s implementation:

[`src/util/auth.js`](https://github.com/GraphQLGuide/guide-api/blob/3_0.1.0/src/util/auth.js)

```js
import jwt from 'jsonwebtoken'
import jwks from 'jwks-rsa'
import { promisify } from 'util'

const verify = promisify(jwt.verify)

const jwksClient = jwks({
  cache: true,
  rateLimit: true,
  jwksUri: 'https://graphql.auth0.com/.well-known/jwks.json'
})

const getPublicKey = (header, callback) => {
  jwksClient.getSigningKey(header.kid, (e, key) => {
    callback(e, key.publicKey || key.rsaPublicKey)
  })
}

export const getAuthIdFromJWT = async token => {
  if (!token) {
    return
  }

  const verifiedToken = await verify(token, getPublicKey, {
    algorithms: ['RS256'],
    audience: 'https://api.graphql.guide',
    issuer: 'https://graphql.auth0.com/'
  })

  return verifiedToken.sub
}
```

It calls `verify()` from the [`jsonwebtoken` package](https://github.com/auth0/node-jsonwebtoken/). In order to verify, it needs the Guide’s public signing key. To get that, we use the [`jwks-rsa` package](https://github.com/auth0/node-jwks-rsa).

Now if we send a `{ hello }` query in Playground, we see `undefined` in the server logs. `authId` is undefined because `req.headers.authorization` is undefined. Which means that Playground isn’t sending an authorization header with our query. We can set it by clicking “HTTP HEADERS” in the bottom-left to open the JSON headers section. We want to set the authorization header to our JWT, but how do we get that? It’s produced by Auth0 during the login process and saved to localStorage, so we can get it by logging in at [graphql.guide/me](https://graphql.guide/me), opening the console, and entering:

```js
localStorage.getItem('auth.accessToken')
```

And it prints our JWT! It’s a long, random-looking, mostly alphanumeric string with some periods, dashes, and underscores. We can copy it to the Playground headers section:

```json
{ 
  "authorization": "your JWT here"
}
```

![Playground with authorization header filled in](img/authorization-header-playground.png)

> Make note of your authorization header—you’ll need it for making queries in other sections of this chapter.

Now when we run the query, we see our authId logged—something like this:

```sh
$ npm run dev

> guide-api@0.1.0 dev /guide-api
> babel-watch src/index.js

GraphQL server running at http://localhost:4000/
undefined
github|1615
```

The format is `github|N`, where `N` is our primary key in the users table of GitHub’s database (it’s an incrementing integer, which means that author John was GitHub’s 1,615th user 😄). 

The next thing that should happen in the code is looking up the user in our database, something like:

```js
  context: async ({ req }) => {
    const context = {}

    const jwt = req.headers.authorization
    const authId = await getAuthIdFromJWT(jwt)
    context.user = await db.collection('users').findOne({ authId })

    return context
  }
```

But we don’t have a database set up yet (we’ll set it up in the next section and add users in [Setting user context](#setting-user-context)), so let’s just test whether the authId is ours (replacing the strings with your own):

```js
  context: async ({ req }) => {
    const context = {}

    const jwt = req.headers.authorization
    const authId = await getAuthIdFromJWT(jwt)
    if (authId === 'github|1615') {
      context.user = {
        firstName: 'John',
        lastName: 'Resig'
      }
    }

    return context
  }
```

Now if we do a `me` query with our authorization header, we get our name:

![me query with results](img/me-query-with-auth-header.png)

But if we remove the header, we get null:

```json
{
  "data": {
    "me": null
  }
}
```

![me query with null](img/me-query-with-null-results.png)

This is because the `Query.me` resolver returns `context.user`, which is not defined.

In this section we learned how to put our JWT in the authorization header, verify it on the server, add the user to context, and access the context in resolvers. In the next section we’ll look at connecting to a database and creating users.

## Data sources

* [Setting up](11.md#setting-up)
* [File structure](11.md#file-structure)
* [Creating reviews](11.md#creating-reviews)

### Setting up

Background: [MongoDB](bg.md#mongodb), [JavaScript classes](bg.md#javascript-classes)

> If you’re jumping in here, `git checkout 3_0.1.0` (tag [3_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/3_0.1.0), or compare [3...4](https://github.com/GraphQLGuide/guide-api/compare/3_0.1.0...4_0.1.0))

Our reviews are currently stored in a JavaScript array variable. There are a few problems with this storage method. JavaScript variables are part of the Node server process, which means that:

- When the server process restarts (for instance when we deploy), our reviews get erased.
- When the server machine loses power, the data kept in RAM (which requires electricity to remember things) is lost. Since each process’s variables are stored in RAM, our reviews get erased. 
- When we have multiple server processes (common in the age of Heroku, when it’s easy to scale up small containers), the user will see different reviews based on which container each request is routed to.
- When we don’t have a long-running server process (widely introduced by AWS Lambda in 2014 and now, with Now 2.0 and Netlify Functions, becoming the standard way to host “servers” 😄), the process is started up for each request, so every reviews query would return just the single item we started out with.

The solution to all of these problems is to have a database that all of the server processes can talk to—one that stores data on a drive that doesn’t require power to remember things (either a disk drive that stores data on magnetic disks or a solid-state drive that stores data in flash memory). 

We’ll be using MongoDB because it’s the most popular database among Node developers and because it’s simple to use. The object-based API is easy to understand, and we don’t need to create a schema or do migrations. (Of course, just as a schema is useful in GraphQL, it’s useful for databases, and we could enforce a schema for our MongoDB database, for example with the [Mongoose ORM](https://mongoosejs.com), but we’ll be using the simplest model layer possible.) For an introduction to MongoDB, check out the [MongoDB section](bg.md#mongodb) of the Background chapter.

There are two main ways to talk to a database from our GraphQL resolvers: [data sources](https://www.apollographql.com/docs/apollo-server/features/data-sources) and [Prisma](https://www.prisma.io/). We generally recommend Prisma (a next-generation ORM) for ease of use, and we’ll learn how to use it in a [later section](#prisma). For now, we’ll use a MongoDB data source, for the same reasons we used Create React App instead of Next.js or Gatsby in the React chapter—data sources are more basic and familiar.

Data sources are classes that interact with a source of data (a database or a service). They often take care of some amount of batching queries and caching responses. We’ll go into them more deeply in the [More data sources](#more-data-sources) section. 

Usually there are two classes: a superclass that we import from a library that matches our type of database, and a subclass that we implement. There are superclass libraries for MongoDB, [SQL](#sql), and [REST](#rest), and we’ll also learn how to [create our own](#custom-data-source). The MongoDB library is [`apollo-datasource-mongodb`](https://github.com/GraphQLGuide/apollo-datasource-mongodb), and its superclass is called `MongoDataSource`. Let’s use it to create a data source for a reviews MongoDB collection:

[`src/data-sources/Review.js`](https://github.com/GraphQLGuide/guide-api/blob/4_0.1.0/src/data-sources/Review.js)

```js
import { MongoDataSource } from 'apollo-datasource-mongodb'

export default class Reviews extends MongoDataSource {
  all() {
    return this.collection.find().toArray()
  }
}
```
 
Let’s start with a single method `all()` that fetches all reviews from the collection. Where does `this.collection` come from, you might ask? It’s set in the constructor (defined in `MongoDataSource`), which gets the collection as an argument:

```js
const reviews = new Reviews(db.collection('reviews'))
```

But in order to do that, we need to set up the database! We can install and start MongoDB on Windows with [these steps](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/#install-mdb-edition) or with [Homebrew](https://brew.sh/) on a Mac:

```sh

$ brew tap mongodb/brew
$ brew install mongodb-community
$ brew services mongodb-community start
```

The database is now running on our computer. We connect to it with the [`mongodb`](http://mongodb.github.io/node-mongodb-native/) package:

[`src/db.js`](https://github.com/GraphQLGuide/guide-api/blob/4_0.1.0/src/db.js)

```js
import { MongoClient } from 'mongodb'

export let db

const URL = 'mongodb://localhost:27017/guide'

const client = new MongoClient(URL, { useNewUrlParser: true })
client.connect(e => {
  if (e) {
    console.error(`Failed to connect to MongoDB at ${URL}`, e)
    return
  }

  db = client.db()
})
```

`'mongodb://localhost:27017/'` is the default URL of the MongoDB server running on our computer, and `'guide'` is the name of our database. Now we can import `db` and use it to create our data source. Data sources are created in a function that we pass to `ApolloServer`:

[`src/index.js`](https://github.com/GraphQLGuide/guide-api/compare/3_0.1.0...4_0.1.0)

```js
import Reviews from './data-sources/Reviews'
import { db } from './db'

const server = new ApolloServer({
  typeDefs: ...
  resolvers: ...
  dataSources: () => ({
    reviews: new Reviews(db.collection('reviews'))
  }),
  context: ...
})
```

Like the `context` function, the `dataSources` function is run for each request, so each request gets a new instance of each data source. `ApolloServer` adds data sources to the context so that we can access them in our resolvers like this:

```js
const server = new ApolloServer({
  typeDefs: ...
  resolvers: {
    Query: {
      me: (_, __, context) => context.user,
      hello: () => '🌍🌏🌎',
      reviews: (_, __, { dataSources }) => dataSources.reviews.all()
    },
    ...
  },
  dataSources: () => ({
    reviews: new Reviews(db.collection('reviews'))
  }),
  context: ...
})
```

We always get context as the third argument to our resolvers, and here we’re destructuring context’s `dataSources` property. Then we get the instance of our `Reviews` data source, `dataSources.reviews`, and call its `.all()` method. Now when we do our reviews query again, we get an empty array, since nothing is in the `'reviews'` collection:

![reviews query with empty array result](img/empty-reviews.png)

<!-- { reviews { text } } -->

### File structure

> If you’re jumping in here, `git checkout 4_0.1.0` (tag [4_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/4_0.1.0), or compare [4...5](https://github.com/GraphQLGuide/guide-api/compare/4_0.1.0...5_0.1.0))

Our `src/index.js` file is getting long, and continuing to put most of our code in one file would get ridiculous 😄. Let’s really simplify this file and get our `ApolloServer` creation down to just:

```js
const server = new ApolloServer({
  typeDefs,
  resolvers,
  dataSources,
  context
})
``` 

with each parameter imported from other files. There’s no one right way to structure the other files, but our favorite is:

- directories for the schema, resolvers, and data sources
- one file for each major type (for example, a file in `schema/` for the `Review` type schema, with a file in `resolvers/` for the resolvers associated with the `Review` type and a file in `data-sources/` for the reviews collection data source)

With this structure, our `src/` looks like:

```
.
├── context.js
├── data-sources
│   ├── Reviews.js
│   └── index.js
├── db.js
├── index.js
├── resolvers
│   ├── Review.js
│   ├── User.js
│   └── index.js
├── schema
│   ├── Review.graphql
│   ├── User.graphql
│   └── schema.graphql
└── util
    └── auth.js
```

Some notes on the above:

- We haven’t yet made a data source for the users collection.
- We have context in a single file `context.js`, but if that ever got too long, we could make a `context/` directory and split it into multiple files.
- We have `index.js` files so that we can import the directory (e.g. `import resolvers from './resolvers'` imports from `'./resolvers/index.js'`). 
- We don’t have an `index.js` in `schema/` because they’re `.graphql` files, and you can’t import a directory with GraphQL imports.

For GraphQL imports, we’re using a babel plugin called [`babel-plugin-import-graphql`](https://github.com/detrohutt/babel-plugin-import-graphql) which replaces our imported `.graphql` files with schema objects (the same ones that the `gql` template string tag creates). We could have instead done JS files with template strings and given an array of them as our `typeDefs` parameter, which would look like this:

```js
// schema/Review.js
import gql from 'graphql-tag'

export default gql`
type Review {
  text: String!
  stars: Int
  fullReview: String!  
}
`

// schema/User.js
import gql from 'graphql-tag'

export default gql`
type User {
  firstName: String
  lastName: String
}
`

// schema/index.js
import reviewSchema from './Review.js'
import userSchema from './User.js'

export default [reviewSchema, userSchema]

// index.js
import typeDefs from './schema'

const server = new ApolloServer({
  typeDefs,
  ...
})
```

Instead, we have:

[`src/schema/schema.graphql`](https://github.com/GraphQLGuide/guide-api/blob/5_0.1.0/src/schema/schema.graphql)

```gql
type Query {
  hello: String!
}

# import Review first
#import 'Review.graphql'
#import 'User.graphql'
```

And the babel plugin makes the `#import` statements work, bringing in these files:

[`src/schema/Review.graphql`](https://github.com/GraphQLGuide/guide-api/blob/5_0.1.0/src/schema/Review.graphql)

```gql
type Review {
  text: String!
  stars: Int
  fullReview: String!
}

extend type Query {
  reviews: [Review!]!
}

type Mutation {
  createReview(review: CreateReviewInput!): Review
}

input CreateReviewInput {
  text: String!
  stars: Int
}
```

[`src/schema/User.graphql`](https://github.com/GraphQLGuide/guide-api/blob/5_0.1.0/src/schema/User.graphql)

```gql
type User {
  firstName: String
  lastName: String
}

extend type Query {
  me: User
}
```

`extend type Query` adds fields to the existing `Query` type (which we defined first in `schema.graphql`). `Review.graphl` is the first to define `Mutation`, so it doesn’t use `extend`. And we import it first so that future files we import below can all do `extend type Mutation`. (And we include the `# import Review first` comment in the file so that others—or our future selves 😄—won’t change the order.)

Thanks to our babel plugin, our `schema.graphql` can be imported like this:

```js
import typeDefs from './schema/schema.graphql'
```

In our `resolvers/` directory we have `Review.js` and `User.js`, which just have the resolvers related to the `Review` and `User` types, respectively:

[`src/resolvers/Review.js`](https://github.com/GraphQLGuide/guide-api/blob/5_0.1.0/src/resolvers/Review.js)

```js
export default {
  Query: {
    reviews: (_, __, { dataSources }) => dataSources.reviews.all()
  },
  Review: {
    fullReview: review =>
      `Someone on the internet gave ${review.stars} stars, saying: "${
        review.text
      }"`
  },
  Mutation: {
    createReview: (_, { review }) => {
      reviews.push(review)
      return review
    }
  }
}
```

[`src/resolvers/User.js`](https://github.com/GraphQLGuide/guide-api/blob/5_0.1.0/src/resolvers/User.js)

```js
export default {
  Query: {
    me: (_, __, context) => context.user
  }
}
```

We combine them in `index.js`:

[`src/resolvers/index.js`](https://github.com/GraphQLGuide/guide-api/blob/5_0.1.0/src/resolvers/index.js)

```js
import { merge } from 'lodash'

const resolvers = {
  Query: {
    hello: () => '🌍🌏🌎'
  }
}

import Review from './Review'
import User from './User'

const resolversByType = [Review, User]

resolversByType.forEach(type => merge(resolvers, type))

export default resolvers
```

[`merge(resolvers, Review)`](https://lodash.com/docs/4.17.11#merge) merges all the `Review` properties into the `resolvers` object, including adding `Review.Query.reviews` to `resolver.Query` (alongside `hello`).

We can now import all resolvers with:

```js
import resolvers from './resolvers'
```

Next up is data sources! We already have `src/data-sources/Review.js`, so all we need is an `index.js` that will combine future data sources with our `Review.js` and export the function that creates new instances:

[`src/data-sources/index.js`](https://github.com/GraphQLGuide/guide-api/blob/5_0.1.0/src/data-sources/index.js)

```js
import Reviews from './Reviews'
import { db } from '../db'

export default () => ({
  reviews: new Reviews(db.collection('reviews'))
})
```

The last thing we want to move out of `src/index.js` is our context function. It’s small enough that we can put it in a single file:

[`src/context.js`](https://github.com/GraphQLGuide/guide-api/blob/5_0.1.0/src/context.js)

```js
import { getAuthIdFromJWT } from './util/auth'

export default async ({ req }) => {
  const context = {}

  const jwt = req.headers.authorization
  const authId = await getAuthIdFromJWT(jwt)
  if (authId === 'github|1615') {
    context.user = {
      firstName: 'John',
      lastName: 'Resig'
    }
  }

  return context
}
```

This brings our entire [`src/index.js`](https://github.com/GraphQLGuide/guide-api/blob/5_0.1.0/src/index.js) to just:

```js
import { ApolloServer } from 'apollo-server'
import typeDefs from './schema/schema.graphql'
import resolvers from './resolvers'
import dataSources from './data-sources'
import context from './context'

const server = new ApolloServer({
  typeDefs,
  resolvers,
  dataSources,
  context
})

server
  .listen({ port: 4000 })
  .then(({ url }) => console.log(`GraphQL server running at ${url}`))
```

So clean! ✨

### Creating reviews

> If you’re jumping in here, `git checkout 5_0.1.0` (tag [5_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/5_0.1.0), or compare [5...6](https://github.com/GraphQLGuide/guide-api/compare/5_0.1.0...6_0.1.0))

In [Setting up](#setting-up), we updated our `reviews` query to fetch from MongoDB, but our reviews database collection is empty! So let’s get reviews into the database. API clients usually find it helpful if we give them an ID for objects we send them, so let’s add one to the schema:

[`src/schema/Review.graphql`](https://github.com/GraphQLGuide/guide-api/compare/5_0.1.0...6_0.1.0)

```gql
type Review {
  id: ID!
  text: String!
  stars: Int
  fullReview: String!
}
```

Let’s update our `createReview` mutation to talk to the database:

[`src/resolvers/Review.js`](https://github.com/GraphQLGuide/guide-api/compare/5_0.1.0...6_0.1.0)

```js
export default {
  ...
  Mutation: {
    createReview: (_, { review }, { dataSources }) =>
      dataSources.reviews.create(review)
  }
}
```

It just calls a method on our data source, which we need to define:

[`src/data-sources/Reviews.js`](https://github.com/GraphQLGuide/guide-api/compare/5_0.1.0...6_0.1.0)

```js
export default class Reviews extends MongoDataSource {
  all() {
    return this.collection.find().toArray()
  }

  create(review) {
    this.collection.insertOne(review)
    return review
  }
}
```

`createReview` resolves to a `Review`, so we need to return `review`. And it needs to have an ID. MongoDB’s [`insertOne()`](http://mongodb.github.io/node-mongodb-native/3.2/api/Collection.html#insertOne) synchronously adds a generated `_id` to the argument we give it, so when we `return review`, `review._id` is filled in. We return before the MongoDB node library talks to the database in order to send a response to the client as quickly as possible. If we wanted to wait until after we knew that the database operation had completed successfully, we could `await`:

```js
  async create(review) {
    await this.collection.insertOne(review)
    return review
  }
```

In this case, if there were a problem with the database insertion, `insertOne()` would throw an error, which Apollo Server would format and send to the client. Our method is now `async`, which means it returns a promise, which means our `createReview` resolver returns a promise. Apollo Server waits for promises to resolve before continuing the GraphQL execution process.

While it’s good that in either case, the `_id` property is added to our `review` object, `_id` doesn’t match with our schema (the schema says the `Review` type has a field named `id`, without an underscore). If we create a review and include `id` in the selection set:

```gql
mutation {
  createReview(review: { text: "Passing", stars: 3 }) {
    id
    text
    stars
  }
}
```

then we get this error:

![Review.id error in Playground](img/non-nullable-id-error.png)

Apollo Server is trying to resolve the `id` field in our selection set, looking at the review object we return from the `createReview` resolver, and not finding an `id` property on that object. When it can’t find a property or `Review` field resolver, it normally returns `null`. However, the `Review` type in our schema has an `!` in the type of `id` (`id: ID!`), so it is non-nullable. Hence the error text: `"Cannot return null for non-nullable field Review.id."`

We can fix this by adding a `Review.id` resolver:

[`src/resolvers/Review.js`](https://github.com/GraphQLGuide/guide-api/compare/5_0.1.0...6_0.1.0)

```js
export default {
  ...
  Review: {
    id: review => review._id,
    fullReview: review =>
      `Someone on the internet gave ${review.stars} stars, saying: "${
        review.text
      }"`
  },
  ...
}
```

`review._id` is an object—an instance of [`ObjectId`](http://mongodb.github.io/node-mongodb-native/3.2/api/ObjectId.html), MongoDB’s default ID type. `Review.id` is supposed to resolve to the GraphQL `ID` scalar type, which is serialized as a string. This might make us think that we should be getting an error. But if we try our Playground mutation again, it’s successful. The reason is that because the schema says the `id` resolver should return an `ID`, Apollo Server knows to call `.toString()` on the object we return.

![Successful createReview mutation in Playground](img/createReview-success.png)

We can now see the list of reviews in the database—one for each time we ran the `createReview` mutation:

```gql
{ 
  reviews {
    id
    text
    stars
    fullReview
  }
}
```

![reviews query in Playground](img/reviews-query.png)

## Custom scalars

> If you’re jumping in here, `git checkout 6_0.1.0` (tag [6_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/6_0.1.0), or compare [6...7](https://github.com/GraphQLGuide/guide-api/compare/6_0.1.0...7_0.1.0))

In the last section we mentioned that the `ID` scalar is serialized like a string, but what does that process look like, and how do we make our own scalars? The only built-in scalars are `Int`, `Float`, `String`, `Boolean`, and `ID`. Another scalar type that most apps use is a date. For example, it would be nice to have a `Review.createdAt`. We could make it an `Int`, but then is it seconds or milliseconds since the [Unix epoch](https://en.wikipedia.org/wiki/Epoch_(computing))? Or it could be a `String`, but there are a lot of string date formats out there. And both ways are missing validation (testing whether the string is a valid date string) and the improved understanding that comes from being able to know, looking at the schema, which fields are meant to be dates. So let’s make our own `Date` scalar. We can add it to our schema:

[`src/schema/schema.graphql`](https://github.com/GraphQLGuide/guide-api/compare/6_0.1.0...7_0.1.0)

```gql
scalar Date

type Query {
  hello: String!
  isoString(date: Date!): String!
}

#import 'Review.graphql'
#import 'User.graphql'
```

[`src/schema/Review.graphql`](https://github.com/GraphQLGuide/guide-api/compare/6_0.1.0...7_0.1.0)

```gql
type Review {
  id: ID!
  text: String!
  stars: Int
  fullReview: String!
  createdAt: Date!
  updatedAt: Date!
}

...
```

First we declare the new scalar type (`scalar Date`), and then we use it for a new `isoString` query as well as `createdAt` and `updatedAt` fields on `Review`. We make them non-nullable because all Review objects will have them.

> We can use the word `Date` for our type because we don’t have other types of dates or times in our app. If we also had a `Date` that had no time component, like a birthday, or a `Time` that had no date component, like 14:00 (2 p.m.), we could call our new scalar `DateTime`.

`isoString` takes a `Date` as an argument and returns the date formatted as a string in the ISO format:

[`src/resolvers/index.js`](https://github.com/GraphQLGuide/guide-api/compare/6_0.1.0...7_0.1.0)

```js
const resolvers = {
  Query: {
    hello: () => '🌍🌏🌎',
    isoString: (_, { date }) => date.toISOString()
  }
}
```

Next we add to our resolvers a `GraphQLScalarType`, which tells Apollo Server how to handle a custom scalar. It will look like this:

[`src/resolvers/Date.js`](https://github.com/GraphQLGuide/guide-api/blob/7_0.1.0/src/resolvers/Date.js)

```js
import { GraphQLScalarType } from 'graphql'

export default {
  Date: new GraphQLScalarType({
    name:
    description:
    parseValue(value) {}
    parseLiteral(ast) {}
    serialize(date) {}
  })
}
```

`GraphQLScalarType` takes five parameters:

- `name` matches the scalar name we added to the schema, so `'Date'`
- `description` is shown in the schema section of GraphiQL and Playground. It says what the scalar represents and how it appears in the JSON response from a server. The built-in description for `ID`, for instance, is:

> The `ID` scalar type represents a unique identifier, often used to refetch an object or as a key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.

- `parseValue(value)` is a function called when the server receives a query variable for a Date argument. The variable’s value is passed to `parseValue()`, and the function should return the value in our desired format—in this case, a JavaScript Date object. For example, if the client sends this query:

```gql
query GraphQLReleaseDate($date: Date!) {
  isoString(date: $date)
}
```

With this as the variables JSON:

```json
{
  "date": 1442188800000
}
```

Then `parseValue` is passed the integer `1442188800000` and should return a JS Date object, which Apollo Server will provide to our resolver, which calls `.toISOString()` on the JS Date object:

```
  isoString: (_, { date }) => date.toISOString()
```

![isoString query with a variable](img/isoString-with-variable.png)

- `parseLiteral(ast)` is called when the server receives a query with a literal argument—meaning the argument is written in the query document itself instead of being provided separately in JSON (as variables are). `ast` stands for abstract syntax tree, which is an object that Apollo Server uses to parse the query document. `ast.value` has the literal value, and is always a string. Similar to `parseValue()`, `parseLiteral()` should return the server’s internal representation of the scalar type. If the client sends this query document:

```gql
{
  isoString(date: 1442188800000)
}
```

Then `parseLiteral(ast)` will be called, and `ast.value` will be `"1442188800000"`.

- `serialize(date)` is called when the server is formatting a JSON response for the client. A resolver returns a JS Date object, then Apollo Server calls `serialize()` with that object, and `serialize()` returns the date in a format that can be put into the JSON response—which in our implementation of the `Date` scalar is an integer. For example, if the `Review.createdAt` resolver returns a JS Date, we would see an integer in the response:

![Query for Review.createdAt returning an integer](img/reviews-createdAt.png)

Here’s a basic implementation of the above:

```js
import { GraphQLScalarType } from 'graphql'

export default {
  Date: new GraphQLScalarType({
    name: 'Date',
    description: 'The `Date` scalar type represents a single moment in time. It is serialized as an integer, equal to the number of milliseconds since the Unix epoch.',
    parseValue: value => new Date(value),
    parseLiteral: ast => new Date(parseInt(ast.value)),
    serialize: date => date.getTime()
  })
}
```

`parseValue()` takes the integer and creates a `Date`. `parseLiteral()` gets the `ast.value` string, converts it into an integer, and creates a `Date`. `serialize()` takes the date and returns the milliseconds since epoch.

One important aspect of defining a custom scalar that we’re missing is validation. If we check the values we’re getting and throw errors with descriptive messages, it will help people using our API. Let’s do that:

[`src/resolvers/Date.js`](https://github.com/GraphQLGuide/guide-api/blob/7_0.1.0/src/resolvers/Date.js)

```js
import { GraphQLScalarType } from 'graphql'
import { Kind } from 'graphql/language'

const isValid = date => !isNaN(date.getTime())

export default {
  Date: new GraphQLScalarType({
    name: 'Date',
    description:
      'The `Date` scalar type represents a single moment in time. It is serialized as an integer, equal to the number of milliseconds since the Unix epoch.',

    parseValue(value) {
      if (!Number.isInteger(value)) {
        throw new Error('Date values must be integers')
      }

      const date = new Date(value)
      if (!isValid(date)) {
        throw new Error('Invalid Date value')
      }

      return date
    },

    parseLiteral(ast) {
      if (ast.kind !== Kind.INT) {
        throw new Error('Date literals must be integers')
      }

      const date = new Date(parseInt(ast.value))
      if (!isValid) {
        throw new Error('Invalid Date literal')
      }

      return date
    },

    serialize(date) {
      if (!(date instanceof Date)) {
        throw new Error(
          'Resolvers for Date scalars must return JavaScript Date objects'
        )
      }

      if (!isValid(date)) {
        throw new Error('Invalid Date scalar')
      }

      return date.getTime()
    }
  })
}
```

In `parseValue()` and `parseLiteral()`, we check whether the client sent an integer, then we create a JS Date and check whether it’s valid. In `serialize()` we check that the value returned from a resolver is a JS Date object, then we check if it’s a valid date, and finally we return the milliseconds since epoch.

We add this file to our resolvers in `resolvers/index.js` by importing and adding to our `resolversByType` array:

[`src/resolvers/index.js`](https://github.com/GraphQLGuide/guide-api/compare/6_0.1.0...7_0.1.0)

```js
...

import Review from './Review'
import User from './User'
import Date from './Date'

const resolversByType = [Review, User, Date]

resolversByType.forEach(type => merge(resolvers, type))

export default resolvers
```

We saw our `isoString` query working above, but now if we make a mistake, we get a helpful error message:

![Error passing a string as a date literal](img/date-literal-error.png)

![Error passing a string as a date variable](img/date-variable-value-error.png)

The last part of our schema change for which we have to implement resolvers is `Review`’s `createdAt` and `updatedAt`. In MongoDB, the creation time is included in the default ID format, [ObjectId](https://docs.mongodb.com/manual/reference/method/ObjectId/). The first 4 bytes are the seconds since Unix epoch, so we can get the creation time from that. (And since it’s the first 4 bytes, we can also sort by an ObjectId to order by most/least recently created.) The `mongodb` node library provides a method `ObjectId.getTimestamp()` that extracts the date for us:

[`src/resolvers/Review.js`](https://github.com/GraphQLGuide/guide-api/compare/6_0.1.0...7_0.1.0)

```js
export default {
  Query: ...
  Review: {
    ...
    createdAt: review => review._id.getTimestamp()
  },
  Mutation: ...
}
```

`updatedAt` is a field that we’ll have to store in the database when reviews are created and update when reviews are modified. We don’t have a way of modifying reviews yet, so we’ll just add a line to our creation method:

[`src/data-sources/Reviews.js`](https://github.com/GraphQLGuide/guide-api/compare/6_0.1.0...7_0.1.0)

```js
import { MongoDataSource } from 'apollo-datasource-mongodb'

export default class Reviews extends MongoDataSource {
  ...

  create(review) {
    review.updatedAt = new Date()
    this.collection.insertOne(review)
    return review
  }
}
```

Now we can include `updatedAt` in our `reviews` query, but we get the error `Cannot return null for non-nullable field Review.updatedAt`:

![Error querying for Review.updatedAt](img/review-updatedAt-error.png)

Apollo Server is telling us that it can’t return `null` for `Review.updatedAt` to the client because the schema says it’s a non-nullable field. Why is it *trying* to return `null` for `Review.updatedAt`? It’s not—our resolver is. Our `reviews` resolver is returning reviews fetched from the database, but none of them have an `updatedAt` property because they were inserted before we updated our `Reviews.create()` data source method. We could fix our reviews in the database by adding an `updatedAt` field, but let’s just delete them and re-create. If you’d like a GUI for interacting with MongoDB, we recommend [MongoDB Compass](https://www.mongodb.com/products/compass). Here’s how to delete all of our reviews using the `mongo` command-line shell:

```sh
$ mongo
MongoDB shell version v4.0.3
connecting to: mongodb://127.0.0.1:27017
...

> use guide
switched to db guide
> db.reviews.find({})
{ "_id" : ObjectId("5cdfb1946df8548efb438535"), "text" : "Passing", "stars" : 3 }
{ "_id" : ObjectId("5cdfb1e4a1cf288f4d86dced"), "text" : "Passing", "stars" : 3 }
{ "_id" : ObjectId("5cdfb28e48435b90119bd2c6"), "text" : "Passing", "stars" : 3 }
> db.reviews.remove({})
WriteResult({ "nRemoved" : 3 })
> db.reviews.find({})
> exit
bye
```

Our second call to `db.reviews.find({})` doesn’t show results because the collection is now empty. And when we do our `reviews` query, we get back an empty array. Now if we use Playground to send a `createReview` mutation, then we can do a `reviews` query with the `createdAt` and `updatedAt` fields:

![reviews query with createdAt and updatedAt in the selection set](img/reviews-with-updatedAt.png)

The last three digits of `createdAt` will always be `000` because the API returns milliseconds since Epoch, and all that’s stored in the ObjectId is *seconds* since Epoch.

An alternative to clearing the database collection would have been to add a resolver for `Review.updatedAt` that returns `Review.createdAt` when there’s no `updatedAt` property on the review object. In order to call another resolver, we’d need to name the resolver’s object and move `export default` to the end:

[`src/resolvers/Review.js`](https://github.com/GraphQLGuide/guide-api/compare/6_0.1.0...7_0.1.0)

```js
const resolvers = {
  Query: {
    reviews: ...
  },
  Review: {
    id: ...
    fullReview: ...
    createdAt: review => review._id.getTimestamp(),
    updatedAt: review => review.updatedAt || resolvers.Review.createdAt(review)
  },
  Mutation: {
    createReview: ...
  }
}

export default resolvers
```

Then we could reference another resolver function (`resolvers.Review.createdAt(review)`).

In this section we created a new `Date` scalar type, added `Query.isoString`, which has a `Date` argument, and `Review.createdAt` and `Review.updatedAt`, which resolve to `Date`s. We’ll continue to use the `Date` type in the rest of our app, for instance for `User.createdAt/updatedAt` in the next section.

## Creating users

* [Protecting with secret key](11.md#protecting-with-secret-key)
* [Setting user context](11.md#setting-user-context)
* [Linking users to reviews](11.md#linking-users-to-reviews)

Currently our `User` type just has two fields (`firstName` and `lastName`), and we aren’t storing users in the database. If we wanted to continue without storing users in the database, we could fetch any further information we want, like email address or GitHub username, from Auth0 or GitHub whenever we needed it. However, this would be a little more complicated than querying our database, introduce latency (it takes longer for our server to talk to their servers than to query our database), and introduce another point of failure (if their services went down or there was a network failure between us and them). Furthermore, we’re going to have to store some new user data (for instance which sections they’ve read, or which reviews they’ve favorited), so we might as well have other user data we need stored along with it. In the first part of this section, we’ll create user documents in a new users Mongo collection. In the second part, we’ll query the collection to set the user context for resolvers.

### Protecting with secret key

> If you’re jumping in here, `git checkout 7_0.1.0` (tag [7_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/7_0.1.0), or compare [7...8](https://github.com/GraphQLGuide/guide-api/compare/7_0.1.0...8_0.1.0))

There are two ways we could create our user doc. One is, in our context function, checking if the user we decode from the JWT exists in the database, and if they don’t, fetching their data from Auth0 and GitHub and saving it to the database. The other method is to use an Auth0 hook—a function we write that runs on a certain trigger. The “Post User Registration” hook runs whenever a user first uses their GitHub account to log in. Inside of our hook function, we can put together the user data we want and send it to the server in a mutation. The Guide hook looks something like this:

```js
const request = require('graphql-request').request
const pick = require('lodash').pick

const query = `
mutation createUserFromHook($user: CreateUserInput!, $secretKey: String!) {
  createUser(user: $user, secretKey: $secretKey) {
    id
  }
}`

module.exports = function (user, context, cb) {
  const secretKey = context.webtask.data.secretKey
  const input = pick(user, 'username', 'email')
  input.authId = user.id
  const variables = {
    user: input,
    secretKey
  }
  request('https://api.graphql.guide/graphql', query, variables).then(data => cb(null, data))
};
```

The exported function is given data about the user, and then sends a `createUser` mutation to the Guide server. The mutation takes as arguments both the user data and a `secretKey`—a secret string that the server verifies before running the mutation, so that no one but the hook can create users.

When we want to protect a query, mutation, or field from being accessed by anyone, normally we use a JWT in the authorization header. We could create a JWT for this purpose, but it’s easier to generate a random string (i.e. key). We could put the key in the authorization header like is usually done for API keys, which would look like this:

[`src/context.js`](https://github.com/GraphQLGuide/guide-api/compare/7_0.1.0...8_0.1.0)

```js
import { getAuthIdFromJWT } from './util/auth'

const API_KEYS = ['alohomora', 'speak-friend']

export default async ({ req }) => {
  const context = {}

  if (API_KEYS.includes(req.headers.authorization)) {
    context.apiUser = true
  } else {
    const jwt = req.headers.authorization
    const authId = await getAuthIdFromJWT(jwt)
    if (authId === 'github|1615') {
      context.user = {
        firstName: 'John',
        lastName: 'Resig'
      }
    }
  }

  return context
}
```

We add an if statement and set `context.apiUser` to `true`, which we can check inside our resolvers.

However, since we only need the key for this one mutation, we’ll add a `secretKey` argument to it. As always, we start with the schema:

[`src/schema/User.graphql`](https://github.com/GraphQLGuide/guide-api/compare/7_0.1.0...8_0.1.0)

```gql
type User {
  firstName: String
  lastName: String
}

extend type Query {
  me: User
}

extend type Mutation {
  createUser(user: CreateUserInput!, secretKey: String!): User
}

input CreateUserInput {
  firstName: String!
  lastName: String!
  username: String!
  email: String!
  authId: String!
}
```

We’re extending the `Mutation` type that first appears in `src/schema/Review.graphql`, and we follow the standard practice of our creation mutation resolving to the type it creates, `User`. And we create a new input type with the user fields we want. Next, we implement the `createUser` resolver:

[`src/resolvers/User.js`](https://github.com/GraphQLGuide/guide-api/compare/7_0.1.0...8_0.1.0)

```js
export default {
  Query: {
    me: (_, __, context) => context.user
  },
  Mutation: {
    createUser(_, { user, secretKey }, context) {
      // TODO
    }
  }
}
```

We have three things to do in our resolver:

- verify `secretKey` is correct
- create the user
- return the user

Best practice is to avoid committing secrets to git, so we won’t do `if (secretKey !== 'foo')`. Instead, we’ll use the [`dotenv` package](https://github.com/motdotla/dotenv#readme) to set an environment variable. First we need to generate a secret:

```sh
$ node
> require('crypto').randomBytes(15, (e, buffer) => console.log(buffer.toString('hex')))
9e769699fae6f594beafb46e9078c2
> .exit
```

Then we put it in a file named `.env`:

```
SECRET_KEY=9e769699fae6f594beafb46e9078c2
```

That we have git ignore:

`.gitignore`

```
node_modules/
dist/
.env
```

And then we have `dotenv` read the values listed in `.env` into `process.env` at the beginning of our code (the first line of `src/index.js`):

```js
import 'dotenv/config'
import { ApolloServer } from 'apollo-server'
import typeDefs from './schema/schema.graphql'
...
```

And then we can reference `process.env.SECRET_KEY` in our code:

`src/resolvers/User.js`

```js
import { AuthenticationError } from 'apollo-server'

export default {
  Query: ...
  Mutation: {
    createUser(_, { user, secretKey }, context) {
      if (secretKey !== process.env.SECRET_KEY) {
        throw new AuthenticationError('wrong secretKey')
      }
      
      // TODO
    }
  }
}
```

> We’ll learn about errors in the [Errors section](#errors).

The next step is creating the user, for which we need a users data source! We create a new file:

[`src/data-sources/Users.js`](https://github.com/GraphQLGuide/guide-api/compare/7_0.1.0...8_0.1.0)

```js
import { MongoDataSource } from 'apollo-datasource-mongodb'

export default class Users extends MongoDataSource {
  create(user) {
    user.updatedAt = new Date()
    this.collection.insertOne(user)
    return user
  }
}
```

The `create()` method adds an `updatedAt` property, inserts, and returns, just like our `Reviews` data source. We include our new data source in the index file:

[`src/data-sources/index.js`](https://github.com/GraphQLGuide/guide-api/compare/7_0.1.0...8_0.1.0)

```js
import Reviews from './Reviews'
import Users from './Users'
import { db } from '../db'

export default () => ({
  reviews: new Reviews(db.collection('reviews')),
  users: new Users(db.collection('users'))
})
```

So now `users` will be available in our resolvers at `context.dataSources.users`:

[`src/resolvers/User.js`](https://github.com/GraphQLGuide/guide-api/compare/7_0.1.0...8_0.1.0)

```js
export default {
  Query: ...
  Mutation: {
    createUser(_, { user, secretKey }, { dataSources } ) {
      if (secretKey !== process.env.SECRET_KEY) {
        throw new AuthenticationError('wrong secretKey')
      }
      
      return dataSources.users.create(user)
    }
  }
}
```

Now the `createUser` should work (using your own data and `authId` for the `user` argument):

![Successful createUser query in Playground](img/createUser.png)

```gql
mutation {
  createUser(
    user: {
      firstName: "John"
      lastName: "Resig"
      username: "jeresig"
      email: "john@graphql.guide"
      authId: "github|1615"
    }
    secretKey: "9e769699fae6f594beafb46e9078c2"
  ) {
    firstName
    lastName
  }
}
```

### Setting user context

> If you’re jumping in here, `git checkout 8_0.1.0` (tag [8_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/8_0.1.0), or compare [8...9](https://github.com/GraphQLGuide/guide-api/compare/8_0.1.0...9_0.1.0))

Now that we have our user document in the database, we can fetch it and put it in context:

[`src/context.js`](https://github.com/GraphQLGuide/guide-api/compare/8_0.1.0...9_0.1.0)

```js
import { getAuthIdFromJWT } from './util/auth'
import { db } from './db'

export default async ({ req }) => {
  const context = {}

  const jwt = req.headers.authorization
  const authId = await getAuthIdFromJWT(jwt)
  const user = await db.collection('users').findOne({ authId })
  if (user) {
    context.user = user
  }

  return context
}
```

One possible concern with this method is latency—every authenticated request now has to wait for a round trip to the database before resolvers are run, and if the request is one that doesn’t use `context.user`, we’ve wasted that time. It’s usually not a long enough period of time to be concerned about, but if we were, we could solve it in a couple of ways:

- Store whatever user data we needed in the JWT. Then we wouldn’t have to fetch it from the database—we’d just decode it. This takes some additional coding, and what the code looks like depends on how you’re creating the JWT (in this case we’d be talking to Auth0 via their API). JWTs have a limited size (~7k sent in an HTTP header), but that wouldn’t be a limiting factor for us, since we don’t have that much user data. 
- Put a promise on the context instead of the doc:

```js
import { getAuthIdFromJWT } from './util/auth'
import { db } from './db'

export default async ({ req }) => {
  const context = {}

  const jwt = req.headers.authorization
  const authId = await getAuthIdFromJWT(jwt)
  context.userPromise = db.collection('users').findOne({ authId })

  return context
}
```

And then any resolvers that needed user data would do:

```js
const user = await context.userPromise
```

That would clutter the code a little, so let’s stick with our `context.user` code. ✨😊

Now if we do the `me` query (and set our authorization header as we did in the [Authentication](#authentication) section), we should be able to get the name from our user document:

![me query with authorization header and returned name](img/me-with-name.png)

There’s more data about a user that our web client will need, so let’s add to our schema:

[`src/schema/User.graphql`](https://github.com/GraphQLGuide/guide-api/compare/8_0.1.0...9_0.1.0)

```gql
type User {
  id: ID!
  firstName: String!
  lastName: String!
  username: String!
  email: String!
  photo: String!
  createdAt: Date!
  updatedAt: Date!
}

extend type Query {
  me: User
}

extend type Mutation {
  createUser(user: CreateUserInput!, secretKey: String!): User
}

input CreateUserInput {
  firstName: String!
  lastName: String!
  username: String!
  email: String!
  authId: String!
}
```

`username`, `email`, and `updatedAt` are fields of the user document, so we don’t need resolvers for them. We do need resolvers for `id`, `photo`, and `createdAt`. Also note that we don’t have a `User.authId` field: while it’s part of `CreateUserInput` and is stored in the user document, we don’t need the client to be able to access it, so leaving it out of the `User` type means they won’t be able to query for it. 

For the `createdAt` resolver, we can do the same as the `Review.createdAt` resolver, calling the `getTimestamp()` method of the `ObjectId`:

[`src/resolvers/User.js`](https://github.com/GraphQLGuide/guide-api/compare/8_0.1.0...9_0.1.0)

```js
export default {
  Query: {
    me: (_, __, context) => context.user
  },
  User: {
    id: ({ _id }) => _id,
    photo(user) {
      // user.authId: 'github|1615'
      const githubId = user.authId.split('|')[1]
      return `https://avatars.githubusercontent.com/u/${githubId}`
    },
    createdAt: user => user._id.getTimestamp()
  },
  Mutation: ...
}
```

For the user’s photo field, we can use GitHub avatar URLs, which have the GitHub user ID at the end, like:

```
https://avatars.githubusercontent.com/u/1615
```

And we can get the GitHub user ID number from the second part of the `authId`, after the `|` character (for example `github|1615`).

Now we can query for all `User` fields:

![me query will all fields selected](img/me-with-all-fields.png)

### Linking users to reviews

> If you’re jumping in here, `git checkout 9_0.1.0` (tag [9_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/9_0.1.0), or compare [9...10](https://github.com/GraphQLGuide/guide-api/compare/9_0.1.0...10_0.1.0))

Another thing we can add now that we have a users collection is associate users with reviews. We want our client to be able to show the user’s name and photo next to reviews, so we can update our `Review` type with an `author` field that resolves to a `User`:

[`src/graphql/Review.graphql`](https://github.com/GraphQLGuide/guide-api/compare/9_0.1.0...10_0.1.0)

```gql
type Review {
  id: ID!
  author: User!
  text: String!
  stars: Int
  fullReview: String!
  createdAt: Date!
  updatedAt: Date!
}
```

When we create the review, we need to save the author’s ID. The author is the currently logged-in user, which is stored at `context.user`. Inside data sources, the context is available at `this.context`. So we can save `this.context.user._id` to an `authorId` field of the review document:

[`src/data-sources/Reviews.js`](https://github.com/GraphQLGuide/guide-api/compare/9_0.1.0...10_0.1.0)

```js
export default class Reviews extends MongoDataSource {
  ...

  create(review) {
    review.authorId = this.context.user._id
    review.updatedAt = new Date()
    this.collection.insertOne(review)
    return review
  }
}
```

Now our new `Review.author` resolver can use this `authorId` prop to fetch the user doc:

[`src/resolvers/Review.js`](https://github.com/GraphQLGuide/guide-api/compare/9_0.1.0...10_0.1.0)

```js
export default {
  Query: ...
  Review: {
    id: ...
    author: (review, _, { dataSources }) =>
      dataSources.users.findOneById(review.authorId),
    fullReview: ...
    createdAt: ...
  },
  Mutation: ...
}
```

The next task is updating our current reviews in the database to have an `authorId` field (because we made `author` non-nullable, we’ll get an error without one). Using our own user ID (from a `{ me { id } }` query) in the below `ObjectId`:

```sh
$ mongo
> use guide
switched to db guide
> db.reviews.updateMany({}, {$set: {authorId: ObjectId('5cf8331934e9730c83399fd5')}})
{ "acknowledged" : true, "matchedCount" : 2, "modifiedCount" : 2 }
> exit
```

Now we should be able to add `author` to our selection set for our `reviews` query:

![reviews query with author selected](img/reviews-with-author.png)

```gql
{
  reviews {
    text
    stars
    author {
      id
      firstName
      photo
    }
  }
}
```

And we should also be able to create a review and select the author, if we include our JWT in the authorization header:

![createReview mutation with author selected](img/createReview-with-author.png)

The last thing to update is `Review.fullReview`: let’s change “Someone on the internet gave N stars” to use the author’s name. Currently we have:

[`src/resolvers/Review.js`](https://github.com/GraphQLGuide/guide-api/compare/9_0.1.0...10_0.1.0)

```js
export default {
  Query: {
    reviews: (_, __, { dataSources }) => dataSources.reviews.all()
  },
  Review: {
    id: review => review._id,
    author: (review, _, { dataSources }) =>
      dataSources.users.findOneById(review.authorId),
    fullReview: review =>
      `Someone on the internet gave ${review.stars} stars, saying: "${
        review.text
      }"`,
    createdAt: review => review._id.getTimestamp()
  },
  Mutation: ...
}
```

We’d like to do:

```js
    fullReview: review =>
      `${review.author.firstName} ${review.author.lastName} gave ${
        review.stars
      } stars, saying: "${review.text}"`,
```

But trying to query `{ reviews { fullReview } }` gives the error `Cannot read property 'firstName' of undefined`, which means that `review.author` is undefined. This is because `review` is a MongoDB document and has an `authorId` property, not an `author` property. We could either call the other resolver (as we saw in [Custom scalars](#custom-scalars) with `Review.updatedAt`) or use the data source directly:

```js
export default {
  Query: ...
  Review: {
    id: review => review._id,
    author: (review, _, { dataSources }) =>
      dataSources.users.findOneById(review.authorId),
    fullReview: async (review, _, { dataSources }) => {
      const author = await dataSources.users.findOneById(review.authorId)
      return `${author.firstName} ${author.lastName} gave ${
        review.stars
      } stars, saying: "${review.text}"`
    },
    createdAt: review => review._id.getTimestamp()
  },
  Mutation: ...
}
```

```gql
{ 
  reviews { 
    fullReview 
  } 
}
```

![reviews query with author names in fullReview](img/fullReview-with-author.png)

## Authorization

> If you’re jumping in here, `git checkout 10_0.1.0` (tag [10_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/10_0.1.0), or compare [10...11](https://github.com/GraphQLGuide/guide-api/compare/10_0.1.0...11_0.1.0))

In this section we’ll implement an authorization check for a field on the `User` type. Later, in the [Error checking](#error-checking) section, we’ll talk about how to find the places we need to do authorization checks.

Let’s first add a new `user` query for fetching a single user by id:

[`src/graphql/User.graphql`](https://github.com/GraphQLGuide/guide-api/compare/10_0.1.0...11_0.1.0)

```gql
extend type Query {
  me: User
  user(id: ID!): User
}
```

[`src/resolvers/User.js`](https://github.com/GraphQLGuide/guide-api/compare/10_0.1.0...11_0.1.0)

```js
import { ObjectId } from 'mongodb'

export default {
  Query: {
    me: (_, __, context) => context.user,
    user: (_, { id }, { dataSources }) =>
      dataSources.users.findOneById(ObjectId(id))
  },
  User: ...
  Mutation: ...
```

We have to turn the `id` string we receive as an argument into an `ObjectId` before calling `findOneById()`. The alternative would be to create an `ObjID` [custom scalar](#custom-scalars) that parsed string arguments into `ObjectId` objects, and then if we changed the argument type from `ID` to `ObjID`, then the `id` argument would be an `ObjectId` object by the time it reached our resolver, and we could call `findOneById()` directly:

```gql
extend type Query {
  me: User
  user(id: ObjID!): User
}
```

```js
    user: (_, { id }, { dataSources }) =>
      dataSources.users.findOneById(id)
```

```js
import { GraphQLScalarType } from 'graphql'
import { ObjectId } from 'mongodb'

export default {
  ObjID: new GraphQLScalarType({
    name: 'ObjID',
    description: ...
    parseValue: value => ObjectId(value),
    parseLiteral: ast => ObjectId(ast.value),
    serialize: objectId => objectId.toString()
  })
}
```

Let’s try our new `user` query:

![user query](img/user-query.png)

We might now notice an issue. This query works without being logged in (i.e. including an authorization header), and it returns the user’s email address. Similarly, we can query `{ reviews { author { email } } }` without being logged in. Our users would probably prefer their email addresses to not be publicly available! 😄

There are a few possible ways to solve this issue:

1. We could remove the `email` field from the `User` type. However, it would be nice to be able to show users their own email address on their profile page.
2. We could check whether the user is fetching their own email. We could do this in three places:

- **Resolver:** we just add an if statement to the beginning of a `User.email` resolver function.
- **Data source:** this doesn’t have the granularity of the `User.email` resolver. If we threw an error in the data source method, the client wouldn’t get any of the user’s data. Doing authorization checks in data sources works well for preventing access to whole objects: for instance, if we wanted to prevent clients from fetching any user but their own. It works particularly well when there are multiple places in the schema the user can be accessed from. Instead of doing the check both in `Query.user` and `Review.author`, we can do it once in the `findOneById()` method of the `Users` data source.
- **Schema:** we can add a [custom directive](https://blog.apollographql.com/reusable-graphql-schema-directives-131fb3a177d1) like @isCurrentUser:

```gql
type User {
  id: ID!
  firstName: String!
  lastName: String!
  email: String! @isCurrentUser
  ...
}
```

(And we’d make more directives for other authorization checks, like `@isLoggedIn` to deny access to a field from anonymous clients or `@isAdmin` to only allow admins to access a field.)

Wherever we do the check, when the user being requested doesn’t match the logged-in user, we could either:

- Throw an error.
- Return `null`. The upside is it’s easier for clients to handle than an error. (For example, if they query for 20 reviews with their authors, they’d get 20 errors to sort through.) The downside is they don’t know why they’re getting a `null` response—they might think the user just doesn’t have an email.
- Use a union type that combines the normal result with the error result, like:

```gql
union EmailResult = Email | Forbidden

type Email {
  address: String!
  verified: Boolean!
}

type Forbidden {
  message: String!
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  email: EmailResult!
  ...
}
```

We’ll cover [union errors](#union-errors) in the next section. 

In this case, let’s do the check in a resolver and throw an error. We currently don’t have a resolver for `User.email`, because Apollo Server just uses the email property on the user object. It does the equivalent of this tiny resolver:

```js
{
  User: {
    email: user => user.email
    ...
  }
}
```

When we provide our own resolver, Apollo Server will call our resolver instead of automatically returning `user.email`. Here’s what our resolver looks like:

[`src/resolvers/User.js`](https://github.com/GraphQLGuide/guide-api/compare/10_0.1.0...11_0.1.0)

```js
import { ForbiddenError } from 'apollo-server'

export default {
  Query: {
    me: (_, __, context) => context.user,
    user: (_, { id }, { dataSources }) =>
      dataSources.users.findOneById(ObjectId(id))
  },
  User: {
    id: ({ _id }) => _id,
    email(user, _, { user: currentUser }) {
      if (!currentUser || !user._id.equals(currentUser._id)) {
        throw new ForbiddenError(`cannot access others’ emails`)
      }

      return user.email
    },
    ...
  },
  Mutation: ...
}
```

We’d have a naming conflict if we destructured `user` from context, so we assign to a new variable name `currentUser`. First we test whether there’s any user at all, and then we test whether it’s the same user. In the next section we’ll see what the error looks like to the client! 👀

## Errors

* [Nullability](11.md#nullability)
* [Union errors](11.md#union-errors)
* [formatError](11.md#formaterror)
  * [Logging errors](11.md#logging-errors)
  * [Masking errors](11.md#masking-errors)
* [Error checking](11.md#error-checking)
* [Custom errors](11.md#custom-errors)

In [Nullability](11.md#nullability), we’ll see what a thrown error looks like to the client, and we’ll look at how data in the response changes based on whether fields are nullable. In [Union errors](11.md#union-errors) we’ll use the union type to return errors instead of throwing them. In [formatError](11.md#formaterror) we log and mask errors, in [Error checking](11.md#error-checking) we go through all the other errors we might want to check for or handle, and in [Custom errors](11.md#custom-errors) we create our own type of Apollo error.

### Nullability

> If you’re jumping in here, `git checkout 11_0.1.0` (tag [11_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/11_0.1.0), or compare [11...12](https://github.com/GraphQLGuide/guide-api/compare/11_0.1.0...12_0.1.0))

In the last section, we throw an error when the client requests an email address and they’re either not logged in or it’s not their email. Let’s see what that that error looks like by making a `user` query without an authorization header:

![user query with null result and error](img/user-null-forbidden.png)

```gql
{
  user(id: "[id of a user in our database]") {
    id
    firstName
    lastName
    email
  }
}
```

We get an errors array with one item (an object with fields `message`, `locations`, `path`, and `extensions`) and `null` data:

```json
{
  "errors": [
    {
      "message": "cannot access others’ emails",
      "locations": [
        {
          "line": 6,
          "column": 5
        }
      ],
      "path": [
        "user",
        "email"
      ],
      "extensions": {
        "code": "FORBIDDEN",
        "exception": {
          "stacktrace": [
            "ForbiddenError: cannot access others’ emails",
            ...
          ]
        }
      }
    }
  ],
  "data": {
    "user": null
  }
}
```

- The `message` matches the string we created our error with:

```js
  throw new ForbiddenError(`cannot access others’ emails`)
```

- The `path` says the error occurred in the `email` field of the `user` query, and `locations` gives the line and column number of the `email` field in the client’s query document. 
- `extensions.code` is set to `FORBIDDEN` by the `ForbiddenError()` we’re using. If we use a plain `Error` (`throw new Error("cannot access others’ emails")`), then `extensions.code` would be `INTERNAL_SERVER_ERROR`.
- The stack trace is included unless `NODE_ENV` is set to `'production'`.

It would be nice if the server returned the rest of the user data we requested (`id`, `firstName`, and `lastName`) instead of just `null`. The reason it doesn’t is `User.email` is non-nullable (`String!`). If we make it nullable by removing the `!`, throwing an error from the `User.email` resolver will return `null` just for the `email` field—the server will still return the rest of the `User` fields:

[`src/graphql/User.graphql`](https://github.com/GraphQLGuide/guide-api/compare/11_0.1.0...12_0.1.0)

```gql
type User {
  id: ID!
  firstName: String!
  lastName: String!
  username: String!
  email: String
  ...
}
```

![user query with a null email response](img/user-null-email.png)

💃 This is a great improvement, especially since in the non-nullable case, a thrown error results in not just `null` for the user, but anything at a higher level as well! For example, here’s a `reviews` query requesting a non-nullable `email`:

```gql
{
  reviews {
    text
    stars
    author {
      email
    }
  }
}
```

![reviews query with null response](img/null-reviews-with-email.png)

Apollo server tries to return null for email, but it’s non-nullable, so then it tries to return null for `Review.author`, but it’s non-nullable, so then it tries to return `null` for the review, but the review is non-nullable and the list of reviews is non-nullable so we don’t even end up with `"data": {"reviews": null}`—we just get `"data": null`!

So when we throw an error for a certain field but still want the client to get the rest of the data, we want to remember to make that field nullable. ❌❗

### Union errors

> If you’re jumping in here, `git checkout 12_0.1.0` (tag [12_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/12_0.1.0), or compare [12...13](https://github.com/GraphQLGuide/guide-api/compare/12_0.1.0...13_0.1.0))

As mentioned in the [Authorization](#authorization) section, an alternative to throwing an error is returning `null`. The downside is the client can’t determine whether the server is returning `null` because there’s no data or because the client doesn’t have access to it. It might be helpful to know they don’t have access so that they can prompt the user to log in. 

When a field’s type is an object type, an alternative to returning `null` from the resolver is returning an error object. We can do this by changing the type to a union. Instead of:

```gql
type Query {
  item(id: Int!): Item
}

type Item {
  id: Int
  name: String
}
```

We can do:

```gql
type Query {
  item (id: Int!): ItemResult
}

type Item {
  id: Int
  name: String
}

type ItemError {
  reason: String
}

union ItemResult = Item | ItemError
```

Now the `item` query resolver is able to return either an `Item` or an `ItemError`. This query:

```gql
{
  item(id: 1) {
    __typename
    ... on Item {
      name
    }
    ... on ItemError {
      reason
    }
  }
}
```

can return either of these two JSON responses:

```json
{
  "data": {
    "item": {
      "__typename": "Item",
      "id": 1,
      "name": "GraphQL hacky sack"
    }
  }
}
```

```json
{
  "data": {
    "item": {
      "__typename": "ItemError",
      "reason": "This item has been discontinued."
    }
  }
}
```

Why do this? It can be easier for the client to handle the errors if they’re inline in the `"data"` attribute of the JSON rather than the `"errors"` attribute. For example, imagine a `searchUsers` query that returned a long list of users. If we wanted the client to be able to show some information about deleted or suspended users, and we threw errors for each one, the client would have to go through an array of `"errors"` in the JSON response and match them up with holes in the `data.searchUsers` results. Further, they would have to be familiar with what type of errors are thrown and the format of the error data. Versus if we document in the schema the types of *expected* errors and return them from resolvers, clients know what data possibilities to expect, and they can smoothly iterate over just the `data.searchUsers` JSON array that they get. 

> *Expected* is highlighted because unexpected errors (like an unauthorized error or database failure) are usually kept as thrown errors, for the client to handle outside of its normal process of presenting expected data on the screen.

Let’s implement this `searchUsers` query to see what it looks like. As usual, we’ll start with the schema:

[`src/schema/User.graphql`](https://github.com/GraphQLGuide/guide-api/compare/12_0.1.0...13_0.1.0)

```gql
extend type Query {
  me: User
  user(id: ID!): User
  searchUsers(term: String!): [UserResult!]!
}

type DeletedUser {
  username: String!
  deletedAt: Date!
}

type SuspendedUser {
  username: String!
  reason: String!
  daysLeft: Int!
}

union UserResult = User | DeletedUser | SuspendedUser
```

A `UserResult` union type can be either a `User`, `DeletedUser`, or `SuspendedUser`, each of which have a `__typename` and `username` but have different other fields. Let’s implement the `searchUsers` resolver next:

[`src/resolvers/User.js`](https://github.com/GraphQLGuide/guide-api/compare/12_0.1.0...13_0.1.0)

```js
export default {
  Query: {
    me: ...
    user: ...
    searchUsers: (_, { term }, { dataSources }) =>
      dataSources.users.search(term)
  },
```

We take the search `term` parameter and pass it to a `search()` method, which will talk to the database:

[`src/data-sources/Users.js`](https://github.com/GraphQLGuide/guide-api/compare/12_0.1.0...13_0.1.0)

```js
export default class Users extends MongoDataSource {
  ...
  
  search(term) {
    return this.collection.find({ $text: { $search: term } }).toArray()
  }
}
```

`$text: { $search: term }` does a [text search](https://docs.mongodb.com/manual/text-search/) of the users collection. For it to work, we need to create a `text` index, which includes all the fields we want to search—in this case, the name and username fields. In MongoDB, we usually use the [`collection.createIndex()`](http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#createIndex) method, which checks if the index already exists, and creates it if not. It would be nice to put the command in the same file as our `search()` method so that it’s easy to see which fields are being searched. One method we know will get called is the constructor, so we can put it there:

```js
export default class Users extends MongoDataSource {
  constructor(collection) {
    super(collection)

    this.collection.createIndex({
      firstName: 'text',
      lastName: 'text',
      username: 'text'
    })
  }

  ...
}
```

We’re currently instantiating this data source with:

```
new Users(db.collection('users'))
```

so in order to maintain that functionality, we need to take that object argument `collection` and pass it to `super()`.

> A new `Users` object is created for every request, which is far more often than we need to be calling `createIndex()`—once at server startup would be sufficient—but the performance impact is miniscule, so we needn’t worry about it until we’re at Google scale 😄.

Now our `search()` method returns a list of users, but they’re all normal users—we don’t have any suspended or deleted users yet. Let’s create three users in our database, all with the same first name so that they come up in a single search:

> If you generated your own secret key, use that. It’s located in your `.env` file.

```gql
mutation {
  createUser(
    user: {
      firstName: "John"
      lastName: "Resig"
      username: "jeresig"
      email: "john@graphql.guide"
      authId: "github|1615"
    }
    secretKey: "9e769699fae6f594beafb46e9078c2"
  ) {
    firstName
    lastName
  }
}
```

```gql
mutation {
  createUser(
    user: {
      firstName: "John"
      lastName: "Smith"
      username: "jsmith"
      email: "jsmith@example.com"
      authId: "github|1"
    }
    secretKey: "9e769699fae6f594beafb46e9078c2"
  ) {
    firstName
    lastName
  }
}
```

```gql
mutation {
  createUser(
    user: {
      firstName: "John"
      lastName: "Rest"
      username: "rest4eva"
      email: "rest4eva@example.com"
      authId: "github|2"
    }
    secretKey: "9e769699fae6f594beafb46e9078c2"
  ) {
    firstName
    lastName
  }
}
```

Now we can use the mongo shell to mark John Rest deleted and John Smith suspended:

```sh
$ mongo
> use guide
> db.users.updateOne({ username: 'rest4eva' }, { $set: { deletedAt: new Date() } })
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }
> db.users.updateOne({ username: 'jsmith' }, { $set: { suspendedAt: new Date(), durationInDays: 300, reason: 'Terms of Service violation' } })
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }
```

Now let’s go back to our code—our resolver returns a list of users:

```js
this.collection.find({ $text: { $search: term } }).toArray()
```

But we don’t want all of the returned objects to be of type `User`—then the client would get the user data of the deleted/suspended users and not know they were deleted/suspended. Whenever we use a union type, we need to tell Apollo which objects are of which type. For that we use a special resolver called `__resolveType`:

[`src/resolvers/User.js`](https://github.com/GraphQLGuide/guide-api/compare/12_0.1.0...13_0.1.0)

```js
export default {
  Query: {
    me: 
    user: ...
    searchUsers: (_, { term }, { dataSources }) =>
      dataSources.users.search(term)
  },
  UserResult: {
    __resolveType: result => {
      if (result.deletedAt) {
        return 'DeletedUser'
      } else if (result.suspendedAt) {
        return 'SuspendedUser'
      } else {
        return 'User'
      }
    }
  },
```

Now when we return an object from a resolver that’s supposed to return a `UserResult`, Apollo gives that object to `UserResult.__resolveType()`, which returns the type of the object. So now the server can’t return the `firstName` of a deleted user, because it’s not a field of `DeletedUser` in the schema.

The last piece we need to add is `SuspendedUser.daysLeft`, which isn’t stored in the database (we only store `suspendedAt` and `durationInDays` in the database). So we create a resolver for it:

```js
import { addDays, differenceInDays } from 'date-fns'

export default {
  Query: ...
  UserResult: ...
  SuspendedUser: {
    daysLeft: user => {
      const end = addDays(user.suspendedAt, user.durationInDays)
      return differenceInDays(end, new Date())
    }
  },
```

[`addDays`](https://date-fns.org/v1.30.1/docs/addDays) returns a date, and [`differenceInDays`](https://date-fns.org/v1.30.1/docs/differenceInDays) returns an integer. Now we can make our query:

```gql
{
  searchUsers(term: "john") {
    __typename
    ... on User {
      username
      firstName
      lastName
      photo
    }
    ... on DeletedUser {
      username
      deletedAt
    }
    ... on SuspendedUser {
      username
      reason
      daysLeft
    }
  }
}
```

![searchUsers query with 3 results](img/searchUsers.png)

> Even though `username` is common to all possible types, with unions, the only field we can select outside of an [inline fragment](2.md#fragments) is the meta field `__typename`.

Now the client can iterate over `data.searchUsers` and check the `__typename`, and if it’s a `DeletedUser` or `SuspendedUser`, display that user differently.

### formatError

There’s an Apollo Server option called [`formatError`](https://www.apollographql.com/docs/apollo-server/features/errors/#masking-and-logging-errors) that allows us to log and modify errors. In this section we’ll see a couple situations in which we might use it.

#### Logging errors

> If you’re jumping in here, `git checkout 13_0.1.0` (tag [13_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/13_0.1.0), or compare [13...14](https://github.com/GraphQLGuide/guide-api/compare/13_0.1.0...14_0.1.0))

Background: [Json Web Tokens](bg.md#tokens-vs-sessions)

Usually when there are server errors, we see them in the `errors` field of the JSON response. In Playground, it’s usually easy to see all the error information, including the stack trace, but when it’s not easy to see the error on the client, it would be nice to be able to see the error in the server output on the command line. And in production we need some way of tracking the errors our users trigger.

There is one case in which Playground doesn’t conveniently show us the server error: when it receives an error from an introspection query. Playground periodically sends an introspection query to our server to get an up-to-date schema to back its query checking and schema tab. When we set an HTTP header, Playground uses it for the introspection query as well. So when we set an invalid authorization header, the server returns an error for the introspection query, but Playground doesn’t show it to us—it just says “Response not successful”:

```gql
{
  me {
    email
  }
}
```

```json
{
  "authorization": "it's me, john!"
}
```

![Query with bad authorization header giving an error](img/status-code-500.png)

If we go into the Network tab, we can see the GraphQL `errors` field, but it’s hard to read the stack trace—we either have to scroll and visually parse the newlines or paste it into a JSON formatter (we recommend [jq](https://stedolan.github.io/jq/): `brew install jq`, copy, `pbpaste | jq .`).

![localhost internal server error](img/localhost-internal-server-error.png)

Since that takes a few steps, let’s instead log the error using [`formatError`](https://www.apollographql.com/docs/apollo-server/features/errors/#masking-and-logging-errors):

[`src/index.js`](https://github.com/GraphQLGuide/guide-api/compare/13_0.1.0...14_0.1.0)

```js
import formatError from './formatError'

const server = new ApolloServer({
  typeDefs,
  resolvers,
  dataSources,
  context,
  formatError
})
```

[`src/formatError.js`](https://github.com/GraphQLGuide/guide-api/compare/13_0.1.0...14_0.1.0)

```js
export default error => {
  console.log(error)
  return error
}
```

Now the error is logged to the terminal:

```
{ [JsonWebTokenError: Context creation failed: jwt malformed]
  message: 'Context creation failed: jwt malformed',
  locations: undefined,
  path: undefined,
  extensions: 
   { code: 'INTERNAL_SERVER_ERROR',
     exception: { stacktrace: [Array] } } }
```

But we don’t see the stack trace, so let’s log that as well, if the error has one:

```js
import get from 'lodash/get'

export default error => {
  console.log(error)
  console.log(get(error, 'extensions.exception.stacktrace'))
  return error
}
```

And now we also get:

```
[ 'JsonWebTokenError: Context creation failed: jwt malformed',
  '    at module.exports (/guide-api/node_modules/jsonwebtoken/verify.js:63:17)',
  '    at internal/util.js:230:26',
  '    at verify (/guide-api/src/util/auth.js:24:31)',
  '    at ApolloServer._default [as context] (/guide-api/src/context.js:8:24)',
  '    at ApolloServer.<anonymous> (/guide-api/node_modules/apollo-server-core/src/ApolloServer.ts:535:24)',
  '    at Generator.next (<anonymous>)',
  '    at /guide-api/node_modules/apollo-server-core/dist/ApolloServer.js:7:71',
  '    at new Promise (<anonymous>)',
  '    at __awaiter (/guide-api/node_modules/apollo-server-core/dist/ApolloServer.js:3:12)',
  '    at ApolloServer.graphQLServerOptions (/guide-api/node_modules/apollo-server-core/dist/ApolloServer.js:316:16)' ]
```

And we can further debug! The error starts in `node_modules/` (`/guide-api/node_modules/jsonwebtoken/verify.js:63:17`), so let’s look for the first lines that are inside our code (`src/`):

```
  '    at verify (/guide-api/src/util/auth.js:24:31)',
  '    at ApolloServer._default [as context] (/guide-api/src/context.js:8:24)',
```

Now let’s look at `src/context.js`:

```js
import { getAuthIdFromJWT } from './util/auth'
import { db } from './db'

export default async ({ req }) => {
  const context = {}

  const jwt = req.headers.authorization
  const authId = await getAuthIdFromJWT(jwt)
  const user = await db.collection('users').findOne({ authId })
  if (user) {
    context.user = user
  }

  return context
}
```

Line 8 is `const authId = await getAuthIdFromJWT(jwt)`. So the error message `"jwt malformed"` means the authorization header is not formatted as a valid JWT.

We achieved our goal of using `formatError` to log the error so that we could debug it. We can’t prevent clients from sending bad authorization headers, but we can improve the errors we throw. The two most common errors thrown during JWT parsing are `jwt malformed` and `jwt expired`, so let’s cover those:

[`src/context.js`](https://github.com/GraphQLGuide/guide-api/compare/13_0.1.0...14_0.1.0)

```js
import { AuthenticationError } from 'apollo-server'

export default async ({ req }) => {
  const context = {}

  const jwt = req.headers.authorization
  let authId

  if (jwt) {
    try {
      authId = await getAuthIdFromJWT(jwt)
    } catch (e) {
      let message
      if (e.message.includes('jwt expired')) {
        message = 'jwt expired'
      } else {
        message = 'malformed jwt in authorization header'
      }
      throw new AuthenticationError(message)
    }

    const user = await db.collection('users').findOne({ authId })
    context.user = user
  }

  return context
}
```

We catch errors from `getAuthIdFromJWT()`, and use a different error message depending on the kind of error. Then we use Apollo’s `AuthenticationError` error type, which adds an `extensions.code` of `"UNAUTHENTICATED"` to the error. The other errors that might occur are from the database (during the `findOne()`)—we’ll cover these in the [next section](#masking-errors). Let’s also throw an error when there is no matching user in the database:

[`src/context.js`](https://github.com/GraphQLGuide/guide-api/compare/13_0.1.0...14_0.1.0)

```js
export default async ({ req }) => {
  const context = {}

  const jwt = req.headers.authorization
  let authId

  if (jwt) {
    ...

    const user = await db.collection('users').findOne({ authId })
    if (user) {
      context.user = user
    } else {
      throw new AuthenticationError('no such user')
    }
  }

  return context
}
```

Now let’s repeat our bad-header query and see what new error we get in the console:

```
{ [AuthenticationError: Context creation failed: malformed jwt in authorization header]
  message: 'Context creation failed: malformed jwt in authorization header',
  locations: undefined,
  path: undefined,
  extensions: { code: 'UNAUTHENTICATED', exception: { stacktrace: [Array] } } }
[ 'AuthenticationError: Context creation failed: malformed jwt in authorization header',
  '    at ApolloServer._default [as context] (/Users/me/gh/guide-api/src/context.js:21:13)',
  '    at <anonymous>',
  '    at runMicrotasksCallback (internal/process/next_tick.js:121:5)',
  '    at _combinedTickCallback (internal/process/next_tick.js:131:7)',
  '    at process._tickCallback (internal/process/next_tick.js:180:9)' ]
```

We now see the `UNAUTHENTICATED` error code and the more detailed error message. Our piece of the message—`malformed jwt in authorization header`—is preceded by `Context creation failed:`, which is added by Apollo for any errors that occur in the context function, and `AuthenticationError:`, which is taken from the name of the error object.

#### Masking errors

> If you’re jumping in here, `git checkout 14_0.1.0` (tag [14_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/14_0.1.0), or compare [14...15](https://github.com/GraphQLGuide/guide-api/compare/14_0.1.0...15_0.1.0))

`formatError()` isn’t just for logging—as the name indicates, we can change the error. The most common change is masking an error we don’t want the client to see. 

You may have noticed that we return the error in the last line of the `formatError()` function:

[`src/formatError.js`](https://github.com/GraphQLGuide/guide-api/compare/14_0.1.0...15_0.1.0)

```js
export default error => {
  console.log(error)
  console.log(get(error, 'extensions.exception.stacktrace'))
  return error
}
```

When an error is thrown in our code, Apollo catches it and gives it to `formatError()`, which returns an error object, which Apollo serializes into JSON and sends in the `errors` attribute to the client. Inside `formatError()`, we can modify the error object—by editing, adding, or removing properties—or return a new error. 

A common category of error to mask is database errors—we might want to hide the original error message for security reasons or to avoid confusing non-technical users with messages they don’t understand. Let’s see, for example, what errors happen when the server can’t reach the database. We can stop the database with this command:

```sh
$ brew services stop mongodb-community
```

If we wait 30 seconds and then make a request, we get a `MongoNetworkError`:

![MongoNetworkError: failed to reconnect after 30 attempts with interval 1000 ms](img/mongo-network-error.png)

And if we keep making requests, we start getting `"MongoError: Topology was destroyed"`:

![MongoError: Topology was destroyed](img/topology-was-destroyed.png)

Let’s mask both of those with a new error:

```js
export default error => {
  console.log(error)
  console.log(get(error, 'extensions.exception.stacktrace'))

  const name = get(error, 'extensions.exception.name') || ''
  if (name.startsWith('Mongo')) {
    return new Error('Internal server error')
  } else {
    return error
  }
}
```

When we edit our code, the server fails to restart because it can’t connect to the database. So in order to test, we can restart Mongo:

```sh
$ brew services start mongodb
```

And then restart the server, and then stop Mongo:

```sh
$ brew services stop mongodb
```

Now we get our masked error instead of either of the Mongo errors:

![Error with message: Internal server error](img/internal-server-error.png)

One last note on `formatError`—in production, we’ll usually want to send our errors to an error tracking or logging service instead of logging them to the server console:

```js
const inProduction = process.env.NODE_ENV === 'production'

export default error => {
  if (inProduction) {
    // send error to tracking service
  } else {
    console.log(error)
    console.log(get(error, 'extensions.exception.stacktrace'))
  }

  ...
}
```

### Error checking

> If you’re jumping in here, `git checkout 15_0.1.0` (tag [15_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/15_0.1.0), or compare [15...16](https://github.com/GraphQLGuide/guide-api/compare/15_0.1.0...16_0.1.0))

So far we’ve dealt with the `User.email` authorization error, users who have been deleted or suspended, authentication errors, and MongoDB errors. Let’s go through our entire app and think about all the possible errors we want to handle or throw:

- **Network:** If our node server is cut off from the internet, or if there’s a DNS issue, the client won’t be able to connect to our server, and will see an error that will look different depending on their browser or platform.
- Servers
  - **Node:** If our Node GraphQL application server isn’t running, then the client won’t be able to connect, and will see the same error as when there’s a network failure.
  - **MongoDB:** We mask errors with our MongoDB server, including inability to connect, in `formatError()`
- **Request:** If the network request isn’t a valid GraphQL HTTP request, then the error will be handled before it reaches our code—either by our server’s operating system, Node, or Apollo Server.
- **Context:** Assuming the request is a valid GraphQL request (including valid against our schema), the server starts by setting the context for resolvers. This process often involves looking at request headers. We covered errors that might occur while creating context in the [Logging errors](#logging-errors) section.
- Resolvers:
  - **Arguments:** Apollo validates the arguments’ data types, but we often want to do further validation on the argument values.
  - **Execution:** We want to handle any possible errors that might occur in the running of our resolver code—things like invalid JWT decoding, dividing by zero, or trying to access a 3rd party service that’s offline.
  - **Authorization:** If there’s data or functions that we don’t want certain people to access or trigger, we need to avoid returning the data / running the functions.

In this section we’ll go through our resolvers. Let’s start with authorization. For data access, let’s look at our main data types:

```gql
type Review {
  id: ID!
  author: User!
  text: String!
  stars: Int
  fullReview: String!
  createdAt: Date!
  updatedAt: Date!
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  username: String!
  email: String
  photo: String!
  createdAt: Date!
  updatedAt: Date!
}
```

Depending on our app, we might consider `createdAt` and `updatedAt` to be sensitive, but for us, the only field we don’t want to be public is `email`, which we already [have a check for](#authorization). If we had an app for which an entire data type was restricted, then in order to verify it was restricted properly, we would need to search for that type everywhere it was referenced in the schema and make sure those queries, mutations, or other fields were restricted. For instance, if we only wanted logged-in users to be able to view user data, then we’d look for `User` in the above and below parts of the schema:

```gql
type Query {
  hello(date: Date): String!
  isoString(date: Date!): String!
  reviews: [Review!]!
  me: User
  user(id: ID!): User
  searchUsers(term: String!): [UserResult!]!
}

type Mutation {
  createReview(review: CreateReviewInput!): Review
  createUser(user: CreateUserInput!, secretKey: String!): User
}
```

We would need to restrict `Review.author`, `Query.user`, and `Query.searchUsers`, and make sure that:

- `Query.me`, which returns a `User`, only returns the current user.
- `Mutation.createUser`, which also returns a `User`, doesn’t return any user but the one just created by that client.

That’s all for authorization on data access. The other part is authorization on running functions—specifically, functions that change things. While it’s possible for a `Query` resolver function to change something, it’s better to make those functions `Mutations`. Let’s assume we’ve defined our `Query` and `Mutation` types properly, and haven’t accidentally modified data in our `Query` resolvers. That means we only need to check our mutations, `createReview` and `createUser`. `createUser` we already [protected with a `secretKey`](#protecting-with-secret-key). `createReview` can currently be run by anyone, but we want it to only be run by logged-in users. Let’s fix that:

[`src/resolvers/Review.js`](https://github.com/GraphQLGuide/guide-api/compare/15_0.1.0...16_0.1.0)

```js
import { ForbiddenError } from 'apollo-server'

export default {
  Query: ...
  Review: ...
  Mutation: {
    createReview: (_, { review }, { dataSources, user }) => {
      if (!user) {
        throw new ForbiddenError('must be logged in')
      }

      dataSources.reviews.create(review)
    }
  }
}
```

Now when we try the mutation without an authorization header, we get an error with the message `"must be logged in"` and code `"FORBIDDEN"`:

```gql
mutation {
  createReview(review: { text: "Grrrreeeeaat!", stars: 5 }) {
    id
    text
    author {
      firstName
    }
  }
}
```

![createReview mutation with error: "must be logged in"](img/must-be-logged-in.png)

That concludes authorization in resolvers. Next let’s check arguments. First we look back at the schema and think about which Query arguments need further validation:

```gql
type Query {
  hello(date: Date): String!
  isoString(date: Date!): String!
  reviews: [Review!]!
  me: User
  user(id: ID!): User
  searchUsers(term: String!): [UserResult!]!
}
```

We don’t need to do anything with the first two queries—our custom scalar checks validity, and any valid date is fine for those queries. The third and fourth don’t have arguments. The last two do. Here’s what they currently look like:

[`src/resolvers/User.js`](https://github.com/GraphQLGuide/guide-api/compare/15_0.1.0...16_0.1.0)

```js
export default {
  Query: {
    me: ...
    user: (_, { id }, { dataSources }) =>
      dataSources.users.findOneById(ObjectId(id)),
    searchUsers: (_, { term }, { dataSources }) =>
      dataSources.users.search(term)
  },
  ...
}
```

Searching with an empty string gives back an empty list, which is fine. We also don’t need to worry about a NoSQL injection attack with a text search. So let’s leave the searching to handle any string, blank or malicious, and move on to `Query.user`. Any string validates as an `ID`, so let’s see what happens when we try to get a user with an id of `'_why'`:

```gql
{
  user(id: "_why") {
     firstName
  }
}
```

![user query ](img/invalid-objectid-error.png)

We get an error with the message `"Argument passed in must be a single String of 12 bytes or a string of 24 hex characters"` and code `"INTERNAL_SERVER_ERROR"`. We can tell from the stack trace that it’s coming from our `ObjectId(id)` call, but it may very well be confusing to the client. Let’s help the client out by giving them a better error message:

[`src/resolvers/User.js`](https://github.com/GraphQLGuide/guide-api/compare/15_0.1.0...16_0.1.0)

```js
import { UserInputError } from 'apollo-server'

const OBJECT_ID_ERROR =
  'Argument passed in must be a single String of 12 bytes or a string of 24 hex characters'

export default {
  Query: {
    me: ...
    user: (_, { id }, { dataSources }) => {
      try {
        return dataSources.users.findOneById(ObjectId(id))
      } catch (error) {
        if (error.message === OBJECT_ID_ERROR) {
          throw new UserInputError('invalid id', {
            invalidArgs: ['id']
          })
        } else {
          throw error
        }
      }
    },
```

We use another built-in error type called `UserInputError`, which sets `extensions.code` to `BAD_USER_INPUT` and lists the invalid arguments in `extensions.invalidArgs`:

![user query with error "invalid id"](img/invalid-id.png)

We’re done checking Query arguments. Now let’s do Mutation arguments:

```gql
type Mutation {
  createUser(user: CreateUserInput!, secretKey: String!): User
  createReview(review: CreateReviewInput!): Review
}
```

Because of `secretKey`, we can trust that our own code is the only one calling `createUser`. Let’s also trust that our code sends good data for the `user` argument, so we can leave that resolver alone. Lastly is `createReview` with `CreateReviewInput`:

```gql
input CreateReviewInput {
  text: String!
  stars: Int
}
```

Inside our resolver, we can trust that `review.text` is a string and that `review.stars` is either undefined or an integer. We need to further check that `review.text` is a valid length (let’s say at least two characters 😄) and that `review.stars` is between 0 and 5.

[`src/resolvers/Review.js`](https://github.com/GraphQLGuide/guide-api/compare/15_0.1.0...16_0.1.0)

```js
import { ForbiddenError, UserInputError } from 'apollo-server'

const MIN_REVIEW_LENGTH = 2
const VALID_STARS = [0, 1, 2, 3, 4, 5]

export default {
  Query: ...
  Review: ...
  Mutation: {
    createReview: (_, { review }, { dataSources, user }) => {
      if (!user) {
        throw new ForbiddenError('must be logged in')
      }

      if (review.text.length < MIN_REVIEW_LENGTH) {
        throw new UserInputError(
          `text must be at least ${MIN_REVIEW_LENGTH} characters`,
          { invalidArgs: ['text'] }
        )
      }

      if (review.stars && !VALID_STARS.includes(review.stars)) {
        throw new UserInputError(`stars must be between 0 and 5`, {
          invalidArgs: ['stars']
        })
      }

      return dataSources.reviews.create(review)
    }
  }
}
```

Since `CreateReviewInput!` is non-null, we don’t have to check that `review` is defined. Similarly, we don’t have to check that `review.text` is defined. Let’s check both errors:

```gql
mutation {
  createReview(review: { text: "A", stars: 6 }) {
    id
    text
  }
}
```

![error message when text is too short](img/review-text-too-short.png)

![error message when stars is 6](img/stars-between-0-and-5.png)

That’s all of our input validation, and the last of our error checking! ✅

### Custom errors

> If you’re jumping in here, `git checkout 16_0.1.0` (tag [16_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/16_0.1.0), or compare [16...17](https://github.com/GraphQLGuide/guide-api/compare/16_0.1.0...17_0.1.0))

In addition to the built-in `UserInputError`, `ForbiddenError`, and `AuthenticationError` that we’ve used, there’s also their superclass, `ApolloError`, which we can use directly to add arbitrary error data or extend to make our own error classes. We’ll do both in this section.

In the last section, when checking the `review` argument to `createReview`, we threw an error for either `review.text` or `review.stars`. If both were incorrect, the client would just get the first error, for `review.text`. Once the client fixed that and tried again, they would then get the `review.stars` error. It would be helpful to the client if we can give both errors at the same time. 

We could do `{ invalidArgs: ['text', 'stars'] }` and combine the two error messages into one message, but it would be better to associate which error message belongs to which argument—that way, for instance, the client can display individual error messages next to each invalid form field. It turns out that `UserInputError` takes any object as its second argument (and adds it to the response JSON’s `extensions.exception`). Let’s keep the recommended `invalidArgs` attribute, but change the value from an array to an object:

```js
{
  invalidArgs: {
    text: 'must be at least 2 characters',
    stars: 'must be between 0 and 5'
  }
}
```

To get this, we update the code to:

[`src/resolvers/Review.js`](https://github.com/GraphQLGuide/guide-api/compare/16_0.1.0...17_0.1.0)

```js
import { isEmpty } from 'lodash'

export default {
  Query: ...
  Review: ...
  Mutation: {
    createReview: (_, { review }, { dataSources, user }) => {
      if (!user) {
        throw new ForbiddenError('must be logged in')
      }

      const errors = {}

      if (review.text.length < MIN_REVIEW_LENGTH) {
        errors.text = `must be at least ${MIN_REVIEW_LENGTH} characters`
      }

      if (review.stars && !VALID_STARS.includes(review.stars)) {
        errors.stars = `must be between 0 and 5`
      }

      if (!isEmpty(errors)) {
        throw new UserInputError('invalid review', { invalidArgs: errors })
      }

      return dataSources.reviews.create(review)
    }
  }
}
```

Now we see both errors together!

```gql
mutation {
  createReview(review: { text: "A", stars: 6 }) {
    id
    text
  }
}
```

![createReview query with both errors in extensions.exception.invalidArgs](img/multiple-invalid-createReview-args.png)

We use `UserInputError` in one other place. Let’s update the `invalidArgs` format there as well to be consistent so that the client can easily programmatically work with `extensions.exception.invalidArgs`:

[`src/resolvers/User.js`](https://github.com/GraphQLGuide/guide-api/compare/16_0.1.0...17_0.1.0)

```js
if (error.message === OBJECT_ID_ERROR) {
  throw new UserInputError('invalid id', {
    invalidArgs: { id: 'not a valid Mongo ObjectId' }
  })
}
```

We’ll come back to `UserInputError` in a bit. For now let’s consider this from `src/formatError.js`:

```js
return new Error('Internal server error')
```

The resulting response is bare, without even a stack trace:

![createReview response with just a message](img/createReview-internal-server-error.png)

Apollo only adds the `extensions` field (including a stack trace in development) for `ApolloError` and its subclasses. So let’s use that:

[`src/formatError.js`](https://github.com/GraphQLGuide/guide-api/compare/16_0.1.0...17_0.1.0)

```js
import { ApolloError } from 'apollo-server'

...

  if (name.startsWith('Mongo')) {
    return new ApolloError(
      `We’re sorry—an error occurred. We’ve been notified and will look into it.`,
      'INTERNAL_SERVER_ERROR'
    )
  } else {
    return error
  }
```

![error with code INTERNAL_SERVER_ERROR](img/INTERNAL_SERVER_ERROR.png)

[`ApolloError`](https://www.apollographql.com/docs/apollo-server/features/errors/#other-errors) takes three arguments: the error message, a code, and additional properties to add to `extensions.exception`. We’re using the first two. Having a code makes it easy for the client to handle all internal server errors similarly. Having a user-friendly message means that the client can show it directly to the user.

In case we want to throw an internal server error elsewhere in the future, let’s make our own `InternalServerError` class:

[`src/util/errors.js`](https://github.com/GraphQLGuide/guide-api/blob/17_0.1.0/src/util/errors.js)

```js
import { ApolloError } from 'apollo-server'

export class InternalServerError extends ApolloError {
  constructor() {
    super(
      `We’re sorry—an error occurred. We’ve been notified and will look into it.`,
      'INTERNAL_SERVER_ERROR'
    )

    Object.defineProperty(this, 'name', { value: 'InternalServerError' })
  }
}
```

`super()` gets the same arguments that the `ApolloError()` constructor got. The last thing is setting the object’s name, which is used at the beginning of the stack trace. Now our use of the error can be simplified:

[`src/formatError.js`](https://github.com/GraphQLGuide/guide-api/compare/16_0.1.0...17_0.1.0)

```js
import { InternalServerError } from './util/errors'

...

  if (name.startsWith('Mongo')) {
    return new InternalServerError()
  } else {
    return error
  }
}
```

Let’s also make a custom input error. Currently we’re using `UserInputError` like this:

[`src/resolvers/Review.js`](https://github.com/GraphQLGuide/guide-api/compare/16_0.1.0...17_0.1.0)

```js
import { UserInputError } from 'apollo-server'

...

  if (!isEmpty(errors)) {
    throw new UserInputError('invalid review', { invalidArgs: errors })
  }
```

It would be simpler if we had an `InputError` class that we could use like this:

```js
import { InputError } from '../util/errors'

...

  if (!isEmpty(errors)) {
    throw new InputError({ review: errors })
  }
```

And then `InputError` could take care of the error message for us. We could also use it in our user resolver:

[`src/resolvers/User.js`](https://github.com/GraphQLGuide/guide-api/compare/16_0.1.0...17_0.1.0)

```js
import { InputError } from '../util/errors'

export default {
  Query: {
    me: ...
    user: (_, { id }, { dataSources }) => {
      try {
        return dataSources.users.findOneById(ObjectId(id))
      } catch (error) {
        if (error.message === OBJECT_ID_ERROR) {
          throw new InputError({ id: 'not a valid Mongo ObjectId' })
        } else {
          throw error
        }
      }
    },
```

The only difference here is that our argument `id` is a scalar type, so we pass `{ id: 'not a valid Mongo ObjectId' }` to `InputError()`, versus the `review` object type argument to `createReview`, which looked like:

```js
{
  review: {
    text: 'must be at least 2 characters',
    stars: 'must be between 0 and 5'
  }
}
```

So when we implement our `InputError` class, we have to cover both scenarios—scalar arguments and their messages, as well as object arguments and their invalid field messages. As before, we subclass `ApolloError`, but this time the constructor creates the error `message`:

[`src/util/errors.js`](https://github.com/GraphQLGuide/guide-api/blob/17_0.1.0/src/util/errors.js)

```js
export class InputError extends ApolloError {
  constructor(errors) {
    let messages = []

    for (const arg in errors) {
      if (typeof errors[arg] === 'string') {
        // scalar argument
        const errorReason = errors[arg]
        messages.push(`Argument ${arg} is invalid: ${errorReason}.`)
      } else {
        // object argument
        const errorObject = errors[arg]
        for (const prop in errorObject) {
          const errorReason = errorObject[prop]
          messages.push(`Argument ${arg}.${prop} is invalid: ${errorReason}.`)
        }
      }
    }

    const fullMessage = messages.join(' ')

    super(fullMessage, 'INVALID_INPUT', { invalidArgs: errors })

    Object.defineProperty(this, 'name', { value: 'InputError' })
  }
}
```

Now when we make an invalid query, we see:

- a very detailed error `message`
- our own error code `INVALID_INPUT`
- a different `invalidArgs` object, from which we can tell what argument the fields `text` and `stars` are on (`review`)
- “InputError” at the beginning of the stack trace

![invalid createReview query with new InputError response](img/InputError.png)

In this section we went over:

- passing arbitrary `extensions.exception` properties as the second argument to `UserInputError()` (or the third argument of `ApolloError()`)
- using `ApolloError()` directly
- creating our own error classes: `InternalServerError` and `InputError`

## Subscriptions

* [githubStars](11.md#githubstars)
* [reviewCreated](11.md#reviewcreated)

GraphQL subscriptions, along with the rest of the spec, are transport-agnostic: that is, the two parties communicating GraphQL don’t need to use a specific way of sending messages. You can even do GraphQL with your friend by passing paper notes back and forth 😄.

The transport we’ve been using (HTTP) won’t work for subscriptions because HTTP is unidirectional—only the client can initiate messages to the server, and the server only has a single opportunity to respond. We need a bidirectional transport—the client needs to be able to tell the server to start and stop the subscription, and the server needs to send subscription events. The main bidirectional transport used in web programming (and most often used for GraphQL subscriptions) is WebSockets.

> In HTTP/2, the server can push resources to the client, but not messages to client code. With SSE ([Server-sent events](https://en.wikipedia.org/wiki/Server-sent_events)), the server can send messages to the client, and if we combine it with HTTP/2, we can do bidirectional communication over a single connection. However, WebSockets is more widely supported and easier to set up.

Subscriptions over WebSockets is supported by Apollo Server (at `ws://hostname/graphql`—`ws://localhost:4000/graphql` in development). In the next section, we’ll see what that looks like with a simple example. Then in [Review updates](#review-updates) we’ll code a more complex example.

### githubStars

> If you’re jumping in here, `git checkout 17_0.1.0` (tag [17_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/17_0.1.0), or compare [17...18](https://github.com/GraphQLGuide/guide-api/compare/17_0.1.0...18_0.1.0))

The simplest subscription used on the Guide site is for a single integer—the number of stars on the [GraphQLGuide/guide](https://github.com/GraphQLGuide/guide) repo. As always, we start with the schema:

[`src/schema/Github.graphql`](https://github.com/GraphQLGuide/guide-api/blob/18_0.1.0/src/schema/Github.graphql)

```gql
type Subscription {
  githubStars: Int!
}
```

This means that each subscription event that the server sends the client will contain a single integer and be in this format:

```json
{
  "data": {
    "githubStars": <integer>
  }
}
```

We include our new `.graphql` file by adding this to the bottom of `schema.graphql`:

[`src/schema/schema.graphql`](https://github.com/GraphQLGuide/guide-api/compare/17_0.1.0...18_0.1.0)

```graphql
#import 'Github.graphql'
```

We need a publish and subscribe system to keep track of which clients to send events to. Apollo Server has an interface that all pub/sub packages implement, so whichever we use, the API will be the same. We create an instance of the `PubSub` class, use its `.asyncIterator()` method in the subscription resolver, and its `.publish()` method to send events. Let’s start with the first step, using the in-memory, for-use-in-development version of `PubSub` included in Apollo Server:

[`src/util/pubsub.js`](https://github.com/GraphQLGuide/guide-api/blob/18_0.1.0/src/util/pubsub.js)

```js
import { PubSub } from 'apollo-server'

export const pubsub = new PubSub()
```

Our resolver is:

[`src/resolvers/Github.js`](https://github.com/GraphQLGuide/guide-api/blob/18_0.1.0/src/resolvers/Github.js)

```js
import { pubsub } from '../util/pubsub'

export default {
  Subscription: {
    githubStars: {
      subscribe: () => pubsub.asyncIterator('githubStars')
    }
  }
}
```

For subscriptions, instead of defining the function on `Subscription.field`, we use `Subscription.field.subscribe` and return an iterator. We’re naming the iterator `'githubStars'`, so to send events to the interator, we’ll do `pubsub.publish('githubStars', { githubStars: 1337 })`. 

Next we include the resolver:

[`src/resolvers/index.js`](https://github.com/GraphQLGuide/guide-api/compare/17_0.1.0...18_0.1.0)

```js
...

import Github from './Github'

const resolversByType = [Review, User, Date, Github]

resolversByType.forEach(type => merge(resolvers, type))
```

Now where do we call `pubsub.publish()`? We have to get the information first. Where do we get it from? GitHub, of course! The first three versions of their API were REST-based, but their v4 is a GraphQL API—let’s use that. [Their docs](https://developer.github.com/v4/guides/forming-calls/#the-graphql-endpoint) say the endpoint is `https://api.github.com/graphql` and that we need to [create an access token](https://developer.github.com/v4/guides/forming-calls/#authenticating-with-graphql) to use the API. Once we’ve done that, we add a new `GITHUB_TOKEN` environment variable with the token we created:

`.env`

```
SECRET_KEY=9e769699fae6f594beafb46e9078c2
GITHUB_TOKEN=...
```

Now we can use `process.env.GITHUB_TOKEN` in our auth header to the GitHub API. Let’s put our code in the `data-sources/` directory—even though it doesn’t talk to our database or follow Apollo’s `DataSource` API (we don’t need context, a new instance for every request, batching, nor caching), it is a source of data used in our app. 

[`src/data-sources/Github.js`](https://github.com/GraphQLGuide/guide-api/blob/18_0.1.0/src/data-sources/Github.js)

```js
import { GraphQLClient } from 'graphql-request'

const githubAPI = new GraphQLClient('https://api.github.com/graphql', {
  headers: {
    authorization: `bearer ${process.env.GITHUB_TOKEN}`
  }
})
```

The simplest way to make GraphQL requests is with the [`graphql-request`](https://github.com/prisma/graphql-request) npm package. Now we can call `githubAPI.request(queryString)`, and our query will be sent to GitHub with our auth header. 

To determine what our query should be, we can browse GitHub’s GraphQL Explorer (an authenticated GraphiQL). A repo’s star count should be included in a repository’s information, so let’s look for a root Query field for getting a repository:

![GitHub’s GraphiQL with Query fields](img/github-graphql-explorer.png)

We find:

```gql
# Lookup a given repository by the owner and repository name.
repository(owner: String!, name: String!): Repository
```

Clicking on the `Repository` type gives us a long list of fields, including a `stargazers` field:

![Repository field list](img/github-stargazers.png)

And clicking on the `StargazerConnection` type gives us:

![StargazerConnection field list](img/github-stargazers-totalCount.png)

And we find that `totalCount` is the field we need. Putting all of that together gives us:

```js
const GUIDE_STARS_QUERY = `
query GuideStars {
  repository(owner: "GraphQLGuide", name: "guide") {
    stargazers {
      totalCount
    }
  }
}
`
```

We can make this query periodically to keep the count up to date. Let’s create a `startPolling()` function that does that. When it gets a new number, it will call `pubsub.publish()`:

[`src/data-sources/Github.js`](https://github.com/GraphQLGuide/guide-api/blob/18_0.1.0/src/data-sources/Github.js)

```js
import { pubsub } from '../util/pubsub'

...

export default {
  async fetchStarCount() {
    const data = await githubAPI.request(GUIDE_STARS_QUERY).catch(console.log)
    return data && data.repository.stargazers.totalCount
  },

  startPolling() {
    let lastStarCount

    setInterval(async () => {
      const starCount = await this.fetchStarCount()
      const countChanged = starCount && starCount !== lastStarCount
      
      if (countChanged) {
        pubsub.publish('githubStars', { githubStars: starCount })
        lastStarCount = starCount
      }
    }, 1000)
  }
}
```

The first argument to `pubsub.publish()` is the name of the async iterator and the second argument is the event data, the format of which needs to match our Subscription field in the schema (`type Subscription { githubStars: Int! }`).

Next we need to call `startPolling()` on startup. The place where all the other data sources are included seems a fitting place:

[`src/data-sources/index.js`](https://github.com/GraphQLGuide/guide-api/compare/17_0.1.0...18_0.1.0)

```js
import Github from './Github'

Github.startPolling()
```

The last change we need to make is to our context function:

[`src/context.js`](https://github.com/GraphQLGuide/guide-api/compare/17_0.1.0...18_0.1.0)

```js
export default async ({ req }) => {
  const context = {}

  const jwt = req.headers.authorization
```

We’re getting a `req` argument and assuming that it has `headers.authorization` properties. But actually, `req` will be undefined for subscriptions. So let’s guard against that:

```js
export default async ({ req }) => {
  const context = {}

  const jwt = req && req.headers.authorization
```

Now we test out our new subscription:

```gql
subscription {
  githubStars
}
```

![githubStars subscription in Playground with two events](img/githubStars-subscription.png)

When we hit the play button, it turns red, but nothing appears on the right—that’s because we haven’t received an event from the server yet, because the server only publishes when the value changes. But if we star [the repo](https://github.com/GraphQLGuide/guide), we’ll see an event of the form:

```json
{
  "data": {
    "githubStars": 87
  }
}
```

And when we unstar the repo, we see another event with the number one lower. Great, we’ve got realtime updates! 🙌 

Well… depending on your definition of realtime. Since we’re polling once a second, we might lag around a second. In the next section we’ll see even faster updates, where the publish happens as soon as the server receives a user’s action.

Lastly, let’s see what the WebSocket communication looks like. If we open devtools Network tab, hit the stop button in Playground, hit play, unstar and re-star the repo, select the `graphql` item in the list on the bottom-left, and select the Messages tab, we’ll see something like:

![Network tab with a list of WebSocket messages](img/subscription-websocket-start.png)

The rows with the green up arrow are messages sent over the WebSocket to the server, and the rows with the red down arrow are messages sent from the server to the browser. When we hit the play button, Playground opens the connection to `ws://localhost:4000/graphql` and sends two messages: one with type `connection_init` and one with:

- `type: "start"`—We’re starting a subscription.
- `payload.query`—The GraphQL document containing our subscription (what we typed on the left side of the Playground).
- `id: 1`—We might start more subscriptions over this websocket, so we have a number to identify this one that we’re starting in this message.

Then the server sends a message with type `connection_ack` (**ack**nowledging receipt of the `connection_init`), and messages like this:

![WebSocket message containing a subscription event](img/subscription-websocket-event.png)

- `type: "data"`—This message contains a subscription event.
- `id: 1`—This event corresponds to the subscription with an `id` of 1.
- `payload: {data: {githubStars: 89}}`—This is the subscription event, which Playground displays in the right-side panel.

Similar to how Playground took our subscription document and put it in WebSocket messages in the right format, and how it parsed the response messages and displayed the payload on the page, most of our clients will be using libraries that take care of the messaging part, so that all they’ll get is the payload object: `{data: {githubStars: 89}}`.

### reviewCreated

> If you’re jumping in here, `git checkout 18_0.1.0` (tag [18_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/18_0.1.0), or compare [18...19](https://github.com/GraphQLGuide/guide-api/compare/18_0.1.0...19_0.1.0))

In the last section we set up our first subscription for a single integer based on an external source of data. In this section we’ll set up a subscription for an object type (`Review`) based on a user action (creating a review). The subscription will be named `reviewCreated`, and whenever any user creates a review, the server will send an event with that review data to all the clients that are subscribed to the `reviewCreated` subscription.

Let’s start with the schema!

[`src/graphql/Review.graphql`](https://github.com/GraphQLGuide/guide-api/compare/18_0.1.0...19_0.1.0)

```gql
type Subscription {
  reviewCreated: Review!
}
```

We now have an error because we’re declaring `type Subscription` in two places, so let’s change the one in `Github.graphql` (which we can see in `src/graphql/schema.graphql` is included after `Review.graphql` is included) to `extend type Subscription`:

[`src/graphql/Github.graphql`](https://github.com/GraphQLGuide/guide-api/compare/18_0.1.0...19_0.1.0)

```gql
extend type Subscription {
  githubStars: Int!
}
```

Now we only need to do two things: 

- add a `Subscription.reviewCreated.subscribe` function that returns an iterator
- at the end of the `createReview` resolver, publish the new review object to that iterator

[`src/resolvers/Review.js`](https://github.com/GraphQLGuide/guide-api/compare/18_0.1.0...19_0.1.0)

```js
import { pubsub } from '../util/pubsub'

export default {
  Query: ...
  Review: ...
  Mutation: {
    createReview: (_, { review }, { dataSources, user }) => {
      ...

      const newReview = dataSources.reviews.create(review)

      pubsub.publish('reviewCreated', {
        reviewCreated: newReview
      })

      return newReview
    }
  },
  Subscription: {
    reviewCreated: { subscribe: () => pubsub.asyncIterator('reviewCreated') }
  }
}
```

The second argument to `pubsub.publish` is the event data, which needs to match the schema (`reviewCreated: Review!`): a `reviewCreated` attribute with an object of type `Review` for the value.

Aaaaand we’re done! That was easy. To test, we start the subscription in one Playground tab:

```gql
subscription {
  reviewCreated {
    id
    text
    stars
    createdAt
  }
}
```

And create the review in another:

```gql
mutation {
  createReview(review: { text: "Now that’s a downtown job!", stars: 5 }) {
    id
    text
  }
}
```

![createReview completed in Playground](img/createReview-downtown-job.png)

Now when we go back to the subscription tab, we’ll see the event:

![reviewCreated subscription with data received](img/subscription-downtown-job.png)

Other common types of subscriptions include when objects are edited and deleted:

```gql
type Subscription {
  reviewEdited: Review!
  reviewDeleted: ID!
}
```

`reviewEdited` events would include the review post-edit, and `reviewDeleted` events would just include the ID of the deleted review, so that clients can remove it from their cache. We’ll discuss subscriptions in more depth in the section Extended topics -> Subscription design.

## Testing

Background: [Testing](bg#testing)

- [Static testing](#static-tests)
- [Review integration tests](#review-integration-tests)
- [Code coverage](#code-coverage)
- [User integration tests](#user-integration-tests)
- [Unit tests](#unit-tests)
- [End-to-end tests](#end-to-end-tests)

In the Background chapter we go over [mocking](bg.md#mocking) and [which types of tests](bg.md#types-of-tests) are best to write. 

In this section we’ll start out by setting up static testing. Next we’ll write integration tests for our review operations. Then we’ll check how much of the code we’ve tested using a code coverage tool. Next we’ll fill in some of the coverage gaps with more integration tests and unit tests. Finally, we’ll write an end-to-end test.

### Static testing

> If you’re jumping in here, `git checkout 19_0.1.0` (tag [19_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/19_0.1.0), or compare [19...20](https://github.com/GraphQLGuide/guide-api/compare/19_0.1.0...20_0.1.0))

Static testing is done through linting, a type of static code analysis. It’s called *static* because, unlike the tests we write code for, no code is being run during static testing—instead, a tool analyzes the code for certain types of mistakes that can be found by just looking at the code and not running it. One such mistake is when we use a variable without declaring it. In JavaScript, the main tool for static analysis is [ESLint](https://eslint.org/docs/about/), and here’s a [list of possible *rules*](https://eslint.org/docs/rules/)—things it can analyze that we can choose to disallow in our code. 

We have `eslint` and `eslint-plugin-node` installed as dev dependencies, so all we need to do is configure ESLint:

[`.eslintrc.js`](https://github.com/GraphQLGuide/guide-api/blob/20_0.1.0/.eslintrc.js)

```js
module.exports = {
  env: {
    es6: true,
    node: true
  },
  extends: 'plugin:node/recommended',
  parserOptions: {
    sourceType: 'module'
  }
}
```

`env` says that we’re using ES6 in Node.js, `extends` says to use `eslint-plugin-node`’s set of recommended linting rules, and `sourceType: 'module'` means that we’re using modules. We can add an npm script for linting:
 
[`package.json`](https://github.com/GraphQLGuide/guide-api/compare/19_0.1.0...20_0.1.0)

```js
{
  ...
  "scripts": {
    ...
    "lint": "eslint src/"
  }
}
```

When we try it out (`npm run lint`), we get errors saying:

```
error  Import and export declarations are not supported yet  node/no-unsupported-features/es-syntax
```

It’s warning us that using the keywords `import` and `export` in our code won’t work because it’s not supported by node. Our code actually does work, because we’re using babel. So let’s disable this rule (the name of the rule is printed at the end):

[`.eslintrc.js`](https://github.com/GraphQLGuide/guide-api/blob/20_0.1.0/.eslintrc.js)

```js
module.exports = {
  ...
  rules: {
    'node/no-unsupported-features/es-syntax': 0
  }
}
```

Now when we do `npm run lint`, it succeeds—no errors are found.

A common practice is setting up linting to occur as a *pre-commit hook*—that is, a command that will automatically be run whenever we enter `git commit`, and if the command fails, the commit will be canceled. The easiest way to set this up is with [husky](https://github.com/typicode/husky), one of our dev dependencies, which simply uses a `package.json` attribute:

[`package.json`](https://github.com/GraphQLGuide/guide-api/compare/19_0.1.0...20_0.1.0)

```json
{
  ...
  "husky": {
    "hooks": {
      "pre-commit": "npm run lint"
    }
  }
}
```

Now if we commit, we see that `eslint src/` is run before the commit happens:

```sh
$ git commit -m 'Set up linting'
husky > pre-commit (node v8.11.3)

> guide-api@0.1.0 lint /guide-api
> eslint src/

[20 bfe4bf1] Set up linting
 2 files changed, 21 insertions(+), 1 deletion(-)
 create mode 100644 .eslintrc.js
```

### Review integration tests

> If you’re jumping in here, `git checkout 20_0.1.0` (tag [20_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/20_0.1.0), or compare [20...21](https://github.com/GraphQLGuide/guide-api/compare/20_0.1.0...21_0.1.0))

The different types of testing are basically defined by how much is mocked 😄. In integration tests, we usually just mock network requests. The main type of network request our server makes is to the database, so we’ll be mocking our MongoDB collection methods. We also won’t need our tests to make network requests to the GraphQL server because Apollo has [`createTestClient()`](https://www.apollographql.com/docs/apollo-server/features/testing/#createtestclient) which allows us to query the server without starting the server. It puts our queries through the Apollo Server request pipeline as if they were HTTP requests. 

`createTestClient()` returns an object with `query` and `mutate` functions, which each take a `GraphQLRequest` object:

[`apollo-server-types`](https://github.com/apollographql/apollo-server/blob/master/packages/apollo-server-types/src/index.ts)

```ts
export interface GraphQLRequest {
  query?: string;
  operationName?: string;
  variables?: VariableValues;
  extensions?: Record<string, any>;
  http?: Pick<Request, 'url' | 'method' | 'headers'>;
}
```

Usually we just use the `query` and `variables` properties, but we can also use `http`, for instance to include an authorization header:

```js
const { query } = createTestClient(server)
query({
  query: gql`...`,
  http: {
    headers: {
      authorization: `Bearer ${token}`
    }
  }
})
```

Then the server would run our context function, decode the auth token, and add the user doc to the context that it gives to resolvers.

`createTestClient()`’s only parameter is an instance of Apollo Server, so our tests will need one. We can’t use the one created in `src/index.js` because our tests will need to be able to modify data sources and context. So let’s make a `createTestServer()` function. And let’s create a new file that exports all of our testing helper functions and data, so that the test files can import whatever they need from one place:

[`test/guide-test-utils.js`](https://github.com/GraphQLGuide/guide-api/blob/21_0.1.0/test/guide-test-utils.js)

```js
import { ApolloServer } from 'apollo-server'

import { Reviews, Users } from '../src/data-sources/'
import {
  typeDefs,
  resolvers,
  context as defaultContext,
  formatError
} from '../src/'

export const createTestServer = ({ context = defaultContext } = {}) => {
  const reviews = new Reviews({})

  const users = new Users({})

  const server = new ApolloServer({
    typeDefs,
    resolvers,
    dataSources: () => ({ reviews, users }),
    context,
    formatError
  })

  return { server, dataSources: { reviews, users } }
}

export { createTestClient } from 'apollo-server-testing'
export { default as gql } from 'graphql-tag'
```

`createTestServer()` returns both the server instance and the data sources (so that tests can spy on or modify data source functions). In order for the above code to work, we need to add some exports:

[`src/data-sources/index.js`](https://github.com/GraphQLGuide/guide-api/compare/20_0.1.0...21_0.1.0)

```js
...

export { Reviews, Users, Github }
```

[`src/index.js](https://github.com/GraphQLGuide/guide-api/compare/20_0.1.0...21_0.1.0)

```js
...

export { typeDefs, resolvers, context, formatError }
```

Now that we’ve got our `guide-test-utils.js` file, we can import from it into our test files. It would be nice if we could import without thinking about relative paths, as if it were a node module:

```js
import {
  createTestServer,
  createTestClient,
  gql
} from 'guide-test-utils'
```

To enable this, we can create a config file:

[`jest.config.js`](https://github.com/GraphQLGuide/guide-api/blob/21_0.1.0/jest.config.js)

```js
const path = require('path')

module.exports = {
  moduleDirectories: ['node_modules', path.join(__dirname, 'test')]
}
```

Jest will now look for modules both in `node_modules/` and in `test/`. ([Jest](https://jestjs.io), made by Facebook, is the most popular JavaScript testing framework.)

Let’s move on to writing the review tests themselves. Since the entry point to review operations and most of the logic is in the resolvers, let’s put our test file next to it, adding a `.test` to the filename:

[`src/resolvers/Review.test.js`](https://github.com/GraphQLGuide/guide-api/blob/21_0.1.0/src/resolvers/Review.test.js)

```js
import {
  createTestServer,
  createTestClient,
  gql
} from 'guide-test-utils'

test('something', () => {
  const result = ...

  expect(result).toSomething()
})
```

Jest provides a set of [global functions](https://jestjs.io/docs/en/api#describename-fn), including the basic test function [`test()`](https://jestjs.io/docs/en/api#testname-fn-timeout) (or `it()`), in which we run part of our code and assert something about the result. We use `expect()` for assertions, which is followed by any of [a number of *matcher* methods](https://jestjs.io/docs/en/expect), such as:

```js
expect(result).toBeTruthy()
expect(result).toBe('this string')
expect(array).not.toContain(10)
expect(doSomething).toThrow('must be logged in')
```

We’ll write two tests, one for each review operation (`reviews` query and `createReview` mutation):

```js
import {
  createTestServer,
  createTestClient,
  gql
} from 'guide-test-utils'

test('reviews', () => {

})

test('createReview', () => {

})
```

For the first, we’ll start by first creating a test server and then a test client:

```js
import {
  createTestServer,
  createTestClient,
  gql
} from 'guide-test-utils'

test('reviews', async () => {
  const { server } = createTestServer()
  const { query } = createTestClient(server)

  const result = await query({ query: ... })
})
```

We need a query document to give to `query()`. To try to cover as many resolvers as possible, let’s select all `Review` and `User` fields except `User.email` (it requires authentication, which we’ll do in the second test).

```js
const REVIEWS = gql`
  query {
    reviews {
      id
      text
      stars
      author {
        id
        firstName
        lastName
        username
        photo
        createdAt
        updatedAt
      }
      createdAt
      updatedAt
    }
  }
`

test('reviews', async () => {
  const { server } = createTestServer()
  const { query } = createTestClient(server)

  const result = await query({ query: REVIEWS })
})
```

This test will send the `REVIEWS` query via the test client to our server. But before we make an assertion and run our code, we have to mock the database! Specifically, we have to mock the collection functions that will be called when our query is run. Looking at `src/resolvers/Review.js`, we see that `dataSources.reviews.all` and `dataSources.users.findOneById` are called. The former calls `this.collection.find().toArray()`, and the latter calls `this.collection.find().toArray()`. We need to mock both of them, as well as `this.collection.createIndex()`, which we call in the `Users` data source constructor.

[`test/guide-test-utils.js`](https://github.com/GraphQLGuide/guide-api/blob/21_0.1.0/test/guide-test-utils.js)

```js
export const createTestServer = ({ context = defaultContext } = {}) => {
  const reviews = new Reviews({
    find: () => ({
      toArray: jest.fn().mockResolvedValue(mockReviews)
    })
  })

  const users = new Users({
    createIndex: jest.fn(),
    find: () => ({
      toArray: jest.fn().mockResolvedValue(mockUsers)
    })
  })

  const server = new ApolloServer({
    dataSources: () => ({ reviews, users }),
    ...
  })

  ...
}
```

We’ll create a mock function using [`jest.fn()`](https://jestjs.io/docs/en/mock-function-api). By default it returns `undefined`, which works for `createIndex()`, but for `find()` we need to return an object that has a `toArray()` method that returns a promise that resolves to an array of documents 😵😄. We’ll also need to create the `mockReviews` and `mockUsers` constants:

```js
import { ObjectId } from 'mongodb'

const updatedAt = new Date('2020-01-01')

export const mockUser = {
  _id: ObjectId('5d24f846d2f8635086e55ed3'),
  firstName: 'First',
  lastName: 'Last',
  username: 'mockA',
  authId: 'mockA|1',
  email: 'mockA@gmail.com',
  updatedAt
}

const mockUsers = [mockUser]

const reviewA = {
  _id: ObjectId('5ce6e47b5f97fe69e0d63479'),
  text: 'A+',
  stars: 5,
  updatedAt,
  authorId: mockUser._id
}

const reviewB = {
  _id: ObjectId('5cf8add4c872001f31880a97'),
  text: 'Passable',
  stars: 3,
  updatedAt,
  authorId: mockUser._id
}

const mockReviews = [reviewA, reviewB]
```

Now our `'reviews'` test should return `reviewA` and `reviewB`, both with author `mockUser`. Let’s complete the test with an assertion:

```js
test('reviews', async () => {
  const { server } = createTestServer()
  const { query } = createTestClient(server)

  const result = await query({ query: REVIEWS })
  expect(result).toMatchSnapshot()
})
```

To run the test, let’s add an npm script:

[`package.json`](https://github.com/GraphQLGuide/guide-api/compare/20_0.1.0...21_0.1.0)

```json
{ 
  ...
  "scripts": {
    ...
    "test": "jest"    
  }
}
```

Now when we do `npm run test` (or just `npm test`), Jest will find all `*.test.js` files and run the tests it finds inside them. 

Our assertion `expect(result).toMatchSnapshot()` will save a snapshot (a serialization of the result, saved to a new `__snapshots__/` directory). Whenever we get a different result from the saved snapshot, the test will fail, and we’ll either need to fix the code or (in the case when the result is correctly different) tell Jest to update the snapshot.

> Snapshots should be added to git.

```
$ npm test

> guide-api@0.1.0 test /guide-api
> jest

 PASS  src/resolvers/Review.test.js
  ✓ reviews (58ms)

 › 1 snapshot written.
  console.log src/index.js:22
    GraphQL server running at http://localhost:4000/

Snapshot Summary
 › 1 snapshot written from 1 test suite.

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   1 written, 1 total
Time:        3.375s, estimated 4s
Ran all test suites.
Jest did not exit one second after the test run has completed.

This usually means that there are asynchronous operations that weren’t stopped in your tests. Consider running Jest with `--detectOpenHandles` to troubleshoot this issue.
```

> To terminate the command, type `Ctrl-C`.

We see that our one test passes, and a new snapshot is written. We can look at the file to make sure it’s correct:

[`src/resolvers/__snapshots__/Review.test.js.snap`](https://github.com/GraphQLGuide/guide-api/blob/21_0.1.0/src/resolvers/__snapshots__/Review.test.js.snap)

```js
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`reviews 1`] = `
Object {
  "data": Object {
    "reviews": Array [
      Object {
        "author": Object {
          "createdAt": 1562703942000,
          "firstName": "First",
          "id": "5d24f846d2f8635086e55ed3",
          "lastName": "Last",
          "photo": "https://avatars.githubusercontent.com/u/1",
          "updatedAt": 1577836800000,
          "username": "mockA",
        },
        "createdAt": 1558635643000,
        "id": "5ce6e47b5f97fe69e0d63479",
        "stars": 5,
        "text": "A+",
        "updatedAt": 1577836800000,
      },
      Object {
        "author": Object {
          "createdAt": 1562703942000,
          "firstName": "First",
          "id": "5d24f846d2f8635086e55ed3",
          "lastName": "Last",
          "photo": "https://avatars.githubusercontent.com/u/1",
          "updatedAt": 1577836800000,
          "username": "mockA",
        },
        "createdAt": 1559801300000,
        "id": "5cf8add4c872001f31880a97",
        "stars": 3,
        "text": "Passable",
        "updatedAt": 1577836800000,
      },
    ],
  },
  "errors": undefined,
  "extensions": undefined,
  "http": Object {
    "headers": Headers {
      Symbol(map): Object {},
    },
  },
}
`;
```

That looks good! We’ve got what we expected in the `"data"` result attribute and nothing in the `"errors"` attribute. However, if we look at the end of the test output, we see a problem:

```
Jest did not exit one second after the test run has completed.

This usually means that there are asynchronous operations that weren’t stopped in your tests. Consider running Jest with `--detectOpenHandles` to troubleshoot this issue.
```

It’s saying we’ve started code running that hasn’t stopped running. If we look above that, we see this output:

```
  console.log src/index.js:22
    GraphQL server running at http://localhost:4000/
```

It looks like our non-test server is running—that’s the running code that Jest is warning us about. So we need to edit `src/index.js` to not start the server during tests. Jest sets `NODE_ENV` to `'test'`, so let’s use that:

[`src/index.js`](https://github.com/GraphQLGuide/guide-api/compare/20_0.1.0...21_0.1.0)

```js
const start = () => {
  server
    .listen({ port: 4000 })
    .then(({ url }) => console.log(`GraphQL server running at ${url}`))
}

if (process.env.NODE_ENV !== 'test') {
  start()
}
```

Instead of starting the server with `server.listen()` at the top level, we put it in a function and only call it when we’re not testing. However, when we run `npm test` again, while we no longer get the `console.log`, we still get the warning, which means there must be more code that we start running at the top level...

The database connection! Let’s put that in a function as well:

[`src/db.js`](https://github.com/GraphQLGuide/guide-api/compare/20_0.1.0...21_0.1.0)

```js
import { MongoClient } from 'mongodb'

export let db

const URL = 'mongodb://localhost:27017/guide'

export const connectToDB = () => {
  const client = new MongoClient(URL, { useNewUrlParser: true })
  client.connect(e => {
    if (e) {
      console.error(`Failed to connect to MongoDB at ${URL}`, e)
      return
    }

    db = client.db()
  })
}
```

And we’ll call it from `start()`. We’ll also move `Github.startPolling()` from the top level of `src/data-sources/index.js`:

[`src/index.js`](https://github.com/GraphQLGuide/guide-api/compare/20_0.1.0...21_0.1.0)

```js
import dataSources, { Github } from './data-sources'
import { connectToDB } from './db'

const start = () => {
  connectToDB()
  Github.startPolling()
  server
    .listen({ port: 4000 })
    .then(({ url }) => console.log(`GraphQL server running at ${url}`))
}

if (process.env.NODE_ENV !== 'test') {
  start()
}
```

Now `npm test` completes normally. To recap, we set up integration tests for review operations by:

- Creating a test version of the server.
- Making a test utilities file that can be used like a node module.
- Writing a test.
- Mocking MongoDB collection methods.
- Preventing long-running server code from starting during testing.

Lastly, we have our second test to write—`'createReview'`:

[`src/resolvers/Review.test.js`](https://github.com/GraphQLGuide/guide-api/blob/21_0.1.0/src/resolvers/Review.test.js)

```js
test('createReview', async () => {
  const { server } = createTestServer({
    context: () => ({ user: mockUser })
  })
  const { mutate } = createTestClient(server)

  const result = await mutate({
    mutation: CREATE_REVIEW,
    variables: { review: { text: 'test', stars: 1 } }
  })
  expect(result).toMatchSnapshot()
})
```

Similarly to `'reviews'`, we create a test server and client, send an operation via the test client, and assert the response matches the snapshot. The differences are:

- We need to set the server’s context as if we’re logged in as `mockUser` so that we don’t get the `ForbiddenError`.
- We use `mutate()` instead of `query()`, and provide the `review` variable.

For the mutation, we have:

```js
const CREATE_REVIEW = gql`
  mutation CreateReview($review: CreateReviewInput!) {
    createReview(review: $review) {
      id
      text
      stars
      author {
        id
        email
      }
      createdAt
    }
  }
`
```

We include `email`, which we’ll have access to because we’re logged in as `mockUser` and `mockUser` will be used for the new review’s `author` field.

The one thing we haven’t done yet is update our database mock functions. It looks like the only new function that will be called is `this.collection.insertOne()`, which is used in `src/data-sources/Reviews.js`:

```js
export default class Reviews extends MongoDataSource {
  ...

  create(review) {
    review.authorId = this.context.user._id
    review.updatedAt = new Date()
    this.collection.insertOne(review)
    return review
  }
}
```

The only thing we were depending on `insertOne()` doing was adding an `_id` property, so let’s mock that:

[`test/guide-test-utils.js`](https://github.com/GraphQLGuide/guide-api/blob/21_0.1.0/test/guide-test-utils.js)

```js
export const createTestServer = ({ context = defaultContext } = {}) => {
  const reviews = new Reviews({
    find: jest.fn(() => ({
      toArray: jest.fn().mockResolvedValue(mockReviews)
    })),
    insertOne: jest.fn(
      doc => (doc._id = new ObjectId('5cf8b6ff37568a1fa500ba4e'))
    )
  })

  ...
}
```

Now when we run the tests, we see that two are passing, and one new snapshot is written:

```
$ npm test

> guide-api@0.1.0 test /guide-api
> jest

 PASS  src/resolvers/Review.test.js
  ✓ reviews (41ms)
  ✓ createReview (21ms)

 › 1 snapshot written.
Snapshot Summary
 › 1 snapshot written from 1 test suite.

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   1 written, 1 passed, 2 total
Time:        3.745s
Ran all test suites.
```

And one new snapshot is written:

[`src/resolvers/__snapshots__/Review.test.js.snap`](https://github.com/GraphQLGuide/guide-api/blob/21_0.1.0/src/resolvers/__snapshots__/Review.test.js.snap)

```js
exports[`createReview 1`] = `
Object {
  "data": Object {
    "createReview": Object {
      "author": Object {
        "email": "mockA@gmail.com",
        "id": "5d24f846d2f8635086e55ed3",
      },
      "createdAt": 1559803647000,
      "id": "5cf8b6ff37568a1fa500ba4e",
      "stars": 1,
      "text": "test",
    },
  },
  "errors": undefined,
  "extensions": undefined,
  "http": Object {
    "headers": Headers {
      Symbol(map): Object {},
    },
  },
}
`;

...
```

Looks good! ✅

### Code coverage

> If you’re jumping in here, `git checkout 21_0.1.0` (tag [21_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/21_0.1.0), or compare [21...22](https://github.com/GraphQLGuide/guide-api/compare/20_0.1.0...22_0.1.0))

Jest analyzes *code coverage*—how much of our code gets run during our tests—with the `--coverage` flag. We can look at code coverage to see which parts of the code aren’t covered by tests, so that we know what our new tests should cover. 

Let’s update our test script:

[`package.json`](https://github.com/GraphQLGuide/guide-api/compare/21_0.1.0...22_0.1.0)

```js
{
  ...
  "scripts": {
    ...
    "test": "jest --coverage",
    "open-coverage": "open coverage/lcov-report/index.html"
  },
```

When `jest --coverage` runs, it both logs statistics and updates the coverage report, which is located in the `coverage/` directory. We can now do `npm run open-coverage` for opening the html report. We can run jest without coverage with:

```sh
$ npx jest
``` 

Or to keep it open, re-running tests whenever we edit our code:

```sh
$ npx jest --watch
```

Or to keep it open with code coverage, one of these commands:

```sh
$ npx jest --coverage --watch
$ npm test -- --watch
```

> `--` after an npm script tells npm to apply the subsequent arguments to the script.

We should tell git to ignore the generated `coverage/` report directory:

[`.gitignore`](https://github.com/GraphQLGuide/guide-api/compare/21_0.1.0...22_0.1.0)

```
node_modules/
dist/
.env
coverage/
```

And we need to tell Jest which JavaScript files it should analyze coverage for, using the `collectCoverageFrom` config:

[`jest.config.js`](https://github.com/GraphQLGuide/guide-api/compare/21_0.1.0...22_0.1.0)

```js
module.exports = {
  moduleDirectories: ['node_modules', path.join(__dirname, 'test')],
  collectCoverageFrom: ['src/**/*.js']
}
```

Here’s the new output of `npm test`:

![Jest with coverage statistics](img/coverage-bash.png)

We see the coverage overall, for each directory, and each JS file, in percentage of statements, logic branches, functions, and lines. To see which lines of code are covered, we can view the HTML report:

```sh
$ npm run open-coverage
```

![Coverage report overview HTML page](img/coverage-web.png)

And follow links to a particular file we’d like to look at, like `src/index.js`:

![Coverage report for src/index.js](img/coverage-index.png)

The red highlighted code shows what wasn’t run during the test. Anything at the top level was run, like the imports, `ApolloServer` instance creation, and the if statement condition, but the body of the if statement—and the body of the start function, which wasn’t called—wasn’t run and thus is red. The highlighting isn’t perfect—notice that `.listen` and `.then` should also be red but aren’t.

If we want to make sure that contributors to our project write tests that cover new code, we can set a minimum coverage threshold, below which the test command will fail. We can set it for any statistic—statements, branches, functions, or lines—and either globally or for individual files. Let’s set a global statement threshold of 40%:

[`jest.config.js`](https://github.com/GraphQLGuide/guide-api/compare/21_0.1.0...22_0.1.0)

```js
module.exports = {
  moduleDirectories: ['node_modules', path.join(__dirname, 'test')],
  collectCoverageFrom: ['src/**/*.js'],
  coverageThreshold: {
    global: {
      statements: 40
    }
  }
}
```

Now the test will fail whenever the code coverage statement ratio is below 40%. We’re currently below 40%, so when we re-run `npm test`, it fails:

![global coverage threshold for statements (40%) not met: 34.39%](img/coverage-below-threshold.png)

### User integration tests

> If you’re jumping in here, `git checkout 22_0.1.0` (tag [22_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/22_0.1.0), or compare [22...23](https://github.com/GraphQLGuide/guide-api/compare/22_0.1.0...23_0.1.0))

Let’s try to meet our 40% coverage threshold. Looking at `src/resolvers/User.js`, we can see that our queries are red:

![HTML coverage report of src/resolvers/User.js](img/coverage-user-red.png)

This makes sense, as our tests haven’t sent any user queries—they’ve just selected `User` fields in review operations. Accordingly, when we scroll down, we see the only covered lines are for `User` field resolvers:

![User field resolvers mostly not red](img/coverage-user-fields.png)

Let’s write some integration tests that query user operations. We’ll start with the same imports and test format (one for each operation) as we did with `Review.test.js`:

[`src/resolvers/User.test.js`](https://github.com/GraphQLGuide/guide-api/blob/23_0.1.0/src/resolvers/User.test.js)

```js
import {
  createTestServer,
  createTestClient,
  gql,
  mockUser
} from 'guide-test-utils'

test('me', async () => {
  ...
})

test('user', async () => {
  ...
})

test('searchUsers', async () => {
  ...
})

test('createUser', async () => {
  ...
})
```

For the `me` test, we can set the `context` to a user with a certain `_id`, and then check to make sure the result’s `id` matches:

```js
const ME = gql`
  query {
    me {
      id
    }
  }
`

test('me', async () => {
  const { server } = createTestServer({
    context: () => ({ user: { _id: 'itme' } })
  })
  const { query } = createTestClient(server)

  const result = await query({ query: ME })
  expect(result.data.me.id).toEqual('itme')
})
```

We don’t need to worry about selecting and testing other fields, as we know they’ve been covered.

Next is the `user` query. We know our mock users collection always returns `mockUser`, so we’ll query for that user:

```js
const USER = gql`
  query User($id: ID!) {
    user(id: $id) {
      id
    }
  }
`

test('user', async () => {
  const { server } = createTestServer()
  const { query } = createTestClient(server)

  const id = mockUser._id.toString()
  const result = await query({
    query: USER,
    variables: { id }
  })
  expect(result.data.user.id).toEqual(id)
})
```

For the `searchUsers` test, let’s set it up so that multiple results are returned. For that, we’ll need to temporarily change the mocked `users.find` function. To get access to that function, we need to get the dataSources from `createTestServer()`:

```js
test('searchUsers', async () => {
  const userA = { _id: 'A' }
  const userB = { _id: 'B' }
  const { server, dataSources } = createTestServer()

  dataSources.users.collection.find.mockReturnValueOnce({
    toArray: jest.fn().mockResolvedValue([userA, userB])
  })
```

`mockReturnValueOnce()` will have `users.find` return the given value once and then go back to returning `[mockUser]` as it was before. After we make the query, we can also test to see what `users.find` was called with:

```js
  expect(dataSources.users.collection.find).toHaveBeenCalledWith({
    $text: { $search: 'foo' }
  })
```

All together, that’s:

```js
const SEARCH_USERS = gql`
  query SearchUsers($term: String!) {
    searchUsers(term: $term) {
      ... on User {
        id
      }
    }
  }
`

test('searchUsers', async () => {
  const userA = { _id: 'A' }
  const userB = { _id: 'B' }
  const { server, dataSources } = createTestServer()

  dataSources.users.collection.find.mockReturnValueOnce({
    toArray: jest.fn().mockResolvedValue([userA, userB])
  })

  const { query } = createTestClient(server)

  const result = await query({
    query: SEARCH_USERS,
    variables: { term: 'foo' }
  })

  expect(dataSources.users.collection.find).toHaveBeenCalledWith({
    $text: { $search: 'foo' }
  })
  expect(result.data.searchUsers[0].id).toEqual('A')
  expect(result.data.searchUsers[1].id).toEqual('B')
})
```

For the last test, our `createUser` mutation will be calling `users.insertOne`, which we haven’t mocked yet. Let’s reuse the `insertOne` function we used for reviews:

[`test/guide-test-utils.js`](https://github.com/GraphQLGuide/guide-api/compare/22_0.1.0...23_0.1.0)

```js
const insertOne = jest.fn(
  doc => (doc._id = new ObjectId('5cf8b6ff37568a1fa500ba4e'))
)

export const createTestServer = ({ context = defaultContext } = {}) => {
  const reviews = new Reviews({
    find: jest.fn(() => ({
      toArray: jest.fn().mockResolvedValue(mockReviews)
    })),
    insertOne
  })

  const users = new Users({
    createIndex: jest.fn(),
    find: jest.fn(() => ({
      toArray: jest.fn().mockResolvedValue(mockUsers)
    })),
    insertOne
  })
  
  ...
```

For the mutation input, let’s `pick` the fields from `mockUser`:

[`src/resolvers/User.test.js`](https://github.com/GraphQLGuide/guide-api/blob/23_0.1.0/src/resolvers/User.test.js)

```js
import { pick } from 'lodash'

const CREATE_USER = gql`
  mutation CreateUser($user: CreateUserInput!, $secretKey: String!) {
    createUser(user: $user, secretKey: $secretKey) {
      id
    }
  }
`

test('createUser', async () => {
  const { server } = createTestServer()
  const { mutate } = createTestClient(server)

  const user = pick(mockUser, [
    'firstName',
    'lastName',
    'username',
    'email',
    'authId'
  ])

  const result = await mutate({
    mutation: CREATE_USER,
    variables: {
      user,
      secretKey: process.env.SECRET_KEY
    }
  })

  expect(result).toMatchSnapshot()
})
```

Whenever we’re using a snapshot, we should check it on the first run to make sure it’s correct. If we run `npm test`, then we should see a new file:

[`src/resolvers/__snapshots__/User.test.js.snap`](https://github.com/GraphQLGuide/guide-api/blob/23_0.1.0/src/resolvers/__snapshots__/User.test.js.snap)

```js
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`createUser 1`] = `
Object {
  "data": Object {
    "createUser": Object {
      "id": "5cf8b6ff37568a1fa500ba4e",
    },
  },
  "errors": undefined,
  "extensions": undefined,
  "http": Object {
    "headers": Headers {
      Symbol(map): Object {},
    },
  },
}
`;
```

Looks good! ✅ We can also see that our statement coverage is above the 40% minimum, so our tests pass!

![Passing console output with statements at 42.68%](img/coverage-above-threshold.png)

### Unit tests

> If you’re jumping in here, `git checkout 23_0.1.0` (tag [23_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/23_0.1.0), or compare [23...24](https://github.com/GraphQLGuide/guide-api/compare/23_0.1.0...24_0.1.0))

We’ve written integration tests that cover most of our queries and mutations. If we want a higher test coverage, we could write more integration tests with different arguments or mock data that result in different parts of the code getting run. We could also write unit tests that cover individual functions. In this section we’ll write a unit test that covers the `user` query. As we can see in the coverage report, we’re missing three lines:

![User.js coverage showing 64%](img/coverage-user-16.png)

Let’s first write a unit test that triggers the invalid ObjectId error. We can either add it to `User.test.js` or create separate files for unit tests named `File.unit.test.js`. The latter has the benefit of smaller files and we can run all the unit tests together with `npm test -- unit`. 

> An alternative file structure would be to move all integration tests to the `test/` directory and only place unit tests next to the files they’re testing. So `test/User.test.js` for integration and `src/resolvers/User.test.js` for unit testing `src/resolvers/User.js`.

Instead of using the test server and client, we can import the resolver function and call it ourselves:

[`src/resolvers/User.unit.test.js`](https://github.com/GraphQLGuide/guide-api/blob/24_0.1.0/src/resolvers/User.unit.test.js)

```js
import resolvers from './User'
import { InputError } from '../util/errors'

test('user throws InputError', () => {
  expect(() =>
    resolvers.Query.user(
      null,
      { id: 'invalid' },
      { dataSources: { users: { findOneById: jest.fn() } } }
    )
  ).toThrow(InputError)
})
```

We mock the `dataSources.users.findOneById` function, and we assert that an instance of `InputError` will be thrown.

However if we want to fit the strict definition of a unit test that says everything must be mocked, we need to mock `ObjectId()`. Since it’s imported from an NPM module, we can use the [`jest.mock()`](https://jestjs.io/docs/en/jest-object#jestmockmodulename-factory-options) function, which mocks the module for all the tests in the same file:

```js
jest.mock('mongodb', () => ({
  ObjectId: id => {
    if (id === 'invalid') {
      throw new Error(
        'Argument passed in must be a single String of 12 bytes or a string of 24 hex characters'
      )
    }
  }
}))
```

Now when `User.js` imports the function (`import { ObjectId } from 'mongodb'`), it will get our version of it.

When we re-run `npm test` and refresh the coverage report, we see that the statements coverage has gone up from 16/25 to 18/25:

![User.js coverage showing 72%](img/coverage-user-18.png)

There’s one statement left in this function: the `throw error` line. For that, we need to have `dataSources.users.findOneById()` throw a different error and make sure that `resolvers.Query.user()` throws the same error.

[`src/resolvers/User.unit.test.js`](https://github.com/GraphQLGuide/guide-api/blob/24_0.1.0/src/resolvers/User.unit.test.js)

```js
import resolvers from './User'
import { InputError } from '../util/errors'

test('user throws data source errors', () => {
  const MOCK_MONGO_ERROR = 'Unable to connect to DB'

  expect(() =>
    resolvers.Query.user(
      null,
      { id: mockMongoId },
      {
        dataSources: {
          users: {
            findOneById: () => {
              throw new Error(MOCK_MONGO_ERROR)
            }
          }
        }
      }
    )
  ).toThrow(MOCK_MONGO_ERROR)
})
```

![User.js coverage showing 76%](img/coverage-user-19.png)

Now the `user` query is completely green. And we could continue writing unit tests for more functions or files, either until we covered the most important pieces of logic, or until we met our overall desired test coverage percentage.

### End-to-end tests

> If you’re jumping in here, `git checkout 24_0.1.0` (tag [24_0.1.0](https://github.com/GraphQLGuide/guide-api/tree/24_0.1.0), or compare [24...25](https://github.com/GraphQLGuide/guide-api/compare/24_0.1.0...25_0.1.0))

The final type of testing is end-to-end, or e2e. In backend e2e testing, we start the server and database, and then we test by sending HTTP requests to the server. So our tests will look something like this:

```js
beforeAll(startE2EServer)
afterAll(stopE2EServer)

test('query A', () => {
  const result = makeHttpRequest(queryA)

  expect(result).toMatchSnapshot()
})
```

Let’s start by writing the `startE2EServer()` helper. We want it to look like this:

[`test/guide-test-utils.js`](https://github.com/GraphQLGuide/guide-api/compare/24_0.1.0...25_0.1.0)

```js
export const startE2EServer = () => {
  // start server and connect to db

  return {
    stop: () => // stops server and db client
    request: () => // send http request to server
  }
}
```

It returns the `stop()` and `request()` functions for the tests to use. We can fill in the first comment:

```js
import { server } from '../src/'
import { connectToDB } from '../src/db'

export const startE2EServer = async () => {
  // start server and connect to db
  const e2eServer = await server.listen({ port: 0 })
  await connectToDB()

  return {
    stop: () => // stops server and db client
    request: () => // send http request to server
  }
}
```

`{ port: 0 }` uses any available port, which we do because the default port (4000) will be in use if our dev server is running while we run our tests. In order to `await` our call to `connectToDB()`, we need to make it async instead of callback-based:

[`src/db.js`](https://github.com/GraphQLGuide/guide-api/compare/24_0.1.0...25_0.1.0)

```js
export let db

export const connectToDB = async () => {
  const client = new MongoClient(URL, { useNewUrlParser: true })
  await client.connect()
  db = client.db()
  return client
}
```

We also need to `return client` so that we can close the connection when testing is done. For stopping the server, there is a `e2eServer.server.close`, but it’s callback-based. We can use node’s [`promisify()`](https://nodejs.org/api/util.html#util_util_promisify_original) to turn it into a promise that we can `await`:

[`test/guide-test-utils.js`](https://github.com/GraphQLGuide/guide-api/compare/24_0.1.0...25_0.1.0)

```js
import { promisify } from 'util'

export const startE2EServer = async () => {
  const e2eServer = await server.listen({ port: 0 })
  const dbClient = await connectToDB()

  const stopServer = promisify(e2eServer.server.close.bind(e2eServer.server))

  return {
    stop: async () => {
      await stopServer()
      await dbClient.close()
    }
    request: () => // send http request to server
  }
}
```

We also use [bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) to maintain the function’s `this`.

We can make our function run faster by performing startup and stopping in parallel using [`Promise.all()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all):

```js
export const startE2EServer = async () => {
  const [e2eServer, dbClient] = await Promise.all([
    server.listen({ port: 0 }),
    connectToDB()
  ])

  const stopServer = promisify(e2eServer.server.close.bind(e2eServer.server))

  return {
    stop: () => Promise.all([stopServer(), dbClient.close()]),
    request: () => // send http request to server
  }
}
```

Lastly, we can send HTTP requests to the server using Apollo Link. [`apollo-link-http`](https://www.apollographql.com/docs/link/links/http/) has the basic `HttpLink` and `apollo-link` has [`execute()`](https://github.com/apollographql/apollo-link/blob/70f342380117fdfdbb5bad0987cd120689659ef2/packages/apollo-link/src/link.ts#L126-L138), a function that sends GraphQL operations over a link, and `toPromise()`, which converts the Observable that `execute()` returns into a promise. All together, that’s:

[`test/guide-test-utils.js`](https://github.com/GraphQLGuide/guide-api/compare/24_0.1.0...25_0.1.0)

```js
import { promisify } from 'util'
import { HttpLink } from 'apollo-link-http'
import fetch from 'node-fetch'
import { execute, toPromise } from 'apollo-link'

import { server } from '../src/'
import { connectToDB } from '../src/db'

export const startE2EServer = async () => {
  const [e2eServer, dbClient] = await Promise.all([
    server.listen({ port: 0 }),
    connectToDB()
  ])

  const stopServer = promisify(e2eServer.server.close.bind(e2eServer.server))

  const link = new HttpLink({
    uri: e2eServer.url,
    fetch
  })

  return {
    stop: () => Promise.all([stopServer(), dbClient.close()]),
    request: operation => toPromise(execute(link, operation))
  }
}
```

We also need `src/index.js` to add `server` to its exports:

[`src/index.js`](https://github.com/GraphQLGuide/guide-api/compare/24_0.1.0...25_0.1.0)

```js
const server = new ApolloServer({
  typeDefs,
  resolvers,
  dataSources,
  context,
  formatError
})

...

export { server, typeDefs, resolvers, context, formatError }
```

Now we can write our e2e test:

[`test/e2e.test.js`](https://github.com/GraphQLGuide/guide-api/blob/25_0.1.0/test/e2e.test.js)

```js
import { gql, startE2EServer } from 'guide-test-utils'

let stop, request

beforeAll(async () => {
  const server = await startE2EServer()
  stop = server.stop
  request = server.request
})

afterAll(() => stop())

const HELLO = gql`
  query {
    hello
  }
`

test('hello', async () => {
  const result = await request({ query: HELLO })

  expect(result).toMatchSnapshot()
})
```

We start the server in `beforeAll()` and stop it in `afterAll()`. Then we create our query document, which we send to the server using `request()` in our one test. After we run the test, we check the snapshot:

[`test/__snapshots__/e2e.test.js.snap`](https://github.com/GraphQLGuide/guide-api/blob/25_0.1.0/test/__snapshots__/e2e.test.js.snap)

```js
exports[`hello 1`] = `
Object {
  "data": Object {
    "hello": "🌍🌏🌎",
  },
}
`;
```

---

That’s all for now! We’re currently working on the rest of the server chapter. Please drop us a line if you have any suggestions for us 😊.

- <authors@graphql.guide>
- [GitHub issues: book text](https://github.com/GraphQLGuide/book/issues)
- [GitHub issues: code](https://github.com/GraphQLGuide/guide/issues)