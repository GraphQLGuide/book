# Chapter 6: React

Chapter contents:

* [Setting up](6.md#setting-up)
  * [Build options](6.md#build-options)
  * [App structure](6.md#app-structure)
  * [Set up Apollo](6.md#set-up-apollo)
* [Querying](6.md#querying)
  * [First query](6.md#first-query)
  * [Loading](6.md#loading)
  * [Polling](6.md#polling)
  * [Subscriptions](6.md#subscriptions)
  * [Lists](6.md#lists)
  * [Query variables](6.md#query-variables)
  * [Variable query](6.md#variable-query)
* [Authentication](6.md#authentication)
  * [Logging in](6.md#logging-in)
  * [Resetting](6.md#resetting)
* [Mutating](6.md#mutating)
  * [First mutation](6.md#first-mutation)
  * [Listing reviews](6.md#listing-reviews)
  * [Optimistic updates](6.md#optimistic-updates)
  * [Arbitrary updates](6.md#arbitrary-updates)
  * [Creating reviews](6.md#creating-reviews)
  * [Using fragments](6.md#using-fragments)
  * [Deleting](6.md#deleting)
  * [Error handling](6.md#error-handling)
  * [Editing reviews](6.md#editing-reviews)
* [Advanced querying](6.md#advanced-querying)
  * [Paginating](6.md#paginating)
    * [Offset-based](6.md#offset-based)
      * [page](6.md#page)
      * [skip & limit](6.md#skip-&-limit)
    * [Cursors](6.md#cursors)
      * [after](6.md#after)
      * [orderBy](6.md#orderby)
  * [Client-side ordering & filtering](6.md#client-side-ordering-&-filtering)
  * [Local state](6.md#local-state)
    * [Reactive variables](6.md#reactive-variables)
    * [In cache](6.md#in-cache)
  * [REST](6.md#rest)
  * [Review subscriptions](6.md#review-subscriptions)
    * [Subscription component](6.md#subscription-component)
    * [Add new reviews](6.md#add-new-reviews)
    * [Update on edit and delete](6.md#update-on-edit-and-delete)
  * [Prefetching](6.md#prefetching)
    * [On mouseover](6.md#on-mouseover)
    * [Cache redirects](6.md#cache-redirects)
  * [Batching](6.md#batching)
  * [Persisting](6.md#persisting)
  * [Multiple endpoints](6.md#multiple-endpoints)
* [Extended topics](6.md#extended-topics)
  * [Linting](6.md#linting)
    * [Setting up linting](6.md#setting-up-linting)
    * [Fixing linting errors](6.md#fixing-linting-errors)
    * [Using linting](6.md#using-linting)
  * [Uploading files](6.md#uploading-files)
  * [Testing](6.md#testing)

---

Background: [single-page application](bg.md#spa), [HTTP](bg.md#http), [Node](bg.md#node-&-npm-&-nvm), [git](bg.md#git), [JSON](bg.md#json), [JavaScript](bg#javascript), [React](bg.md#react)

In this chapter, we’ll learn to use the [`@apollo/client`](https://www.apollographql.com/docs/react/) library through building the Guide web app—the code behind the [https://graphql.guide](https://graphql.guide/Preface) site, where we can sign in, read the book, and write reviews. We’ll go through setup, simple queries, complex queries, auth, and mutations for creating, updating, and deleting. Then we’ll cover advanced topics like infinite scrolling, local state, SSR, working offline, and performance. Here’s what it will look like:

![Guide app](img/guide-app.png)

We’ll be using Apollo’s hooks API. For an older version of this chapter that uses Apollo’s [render prop](https://www.apollographql.com/docs/react/api/react/components/) and [higher-order component](https://www.apollographql.com/docs/react/api/react/hoc/) APIs or the Apollo Client 2.* cache API, see version r5 of the Guide:

- [r5.pdf](https://s3.graphql.guide/the-graphql-guide-r5.pdf)
- [r5.mobi](https://s3.graphql.guide/the-graphql-guide-r5.mobi)
- [r5.epub](https://s3.graphql.guide/the-graphql-guide-r5.epub)

> We recommend Apollo for its flexibility, ease of use, documentation, and ecosystem. The main alternative is [Relay](https://relay.dev/), which is more opinionated—it requires fragments colocated with components, specific ways of working with errors, and a certain format for the server schema, including `Node`s, universally unique `id`s, [connections](11.md#relay-cursor-connections) for pagination, and mutation structure. It also requires use of the Relay compiler. For more info on these differences, check out [this post](https://hasura.io/blog/deep-dive-into-relay-graphql-client/).

# Setting up

Section contents:

* [Build options](6.md#build-options)
* [App structure](6.md#app-structure)
* [Set up Apollo](6.md#set-up-apollo)

## Build options

Background: [server-side rendering](bg.md#ssr)

In the early days, setting up a new React app was plagued by complex Webpack and
Babel configurations. There are now a number of tools for this, four of which
we recommend: Create React App, Gatsby, Next.js, and Meteor.

> [Babel](https://babeljs.io/) converts our modern JavaScript to old JavaScript so it will run in the browser or Node. [Webpack](https://webpack.js.org/) bundles our JavaScript and other files together into a website.

### Create React App

```sh
npm i -g create-react-app
create-react-app my-app
cd my-app/
npm start
```

[Create React App](https://github.com/facebookincubator/create-react-app) (CRA)
is a tool that configures Webpack and Babel to good, common defaults. For
deployment, running `npm run build` gives us an `index.html`, our JavaScript
bundle (or multiple bundles if we’re code splitting), and imported static assets
like CSS, images, and fonts.

### Gatsby

```sh
npm install -g gatsby-cli
gatsby new my-app
cd my-app/
gatsby develop
```

[Gatsby](https://www.gatsbyjs.org/) is the best static site generator out there. But by “static site generator,” we don’t mean it generates HTML-only non-interactive sites. It generates pages that render the HTML & CSS UI immediately and run JavaScript to hydrate the page into a React app. It can’t generate logged-in content (like you can with SSR and cookies) because it’s not your production server—deploying is building HTML, JS, and CSS files and serving them as-is (*statically*). However, you can [render logged-in content on the client](https://www.gatsbyjs.org/docs/building-apps-with-gatsby/).

### Next.js

```sh
npm i -g create-next-app
create-next-app my-app
cd my-app/
npm run dev
```

[Next.js](https://github.com/zeit/next.js) is similar to CRA and Gatsby in that it takes
care of Webpack/Babel for us, but it also does [server-side rendering](bg.md#ssr)
(SSR), routing, automatic page-level code splitting, dynamic importing, and hot
code reloading. CRA and Gatsby are just your dev server and build tool, whereas Next.js, since it
does SSR, is also your Node production server. 

Next.js also has an `export` command that outputs HTML and JS that you can serve as static files (like Gatsby). The HTML is rendered once at the time that you run the `export` command, instead of in real time whenever a client requests the site.

### Meteor

```sh
curl https://install.meteor.com/ | sh
git clone https://github.com/jamiter/meteor-starter-kit.git my-app
cd my-app/
npm install
meteor
```

Like Next.js, [Meteor](https://www.meteor.com) is a build tool and the production server. But, unlike Next.js and the other options, it does not use
Webpack—it has its own advanced build system that is blissfully
configuration-free. It does not have built-in SSR, since it is view layer agnostic (it can be used with any view library, like Vue, Svelte, Angular, etc.), but it does
have other advanced features. It has dynamic (runtime) imports, and all dynamically imported modules are fetched quickly
over a WebSocket and [cached on the client](https://blog.meteor.com/announcing-meteor-1-5-b82be66571bb) (in
[IndexedDB](https://en.wikipedia.org/wiki/Indexed_Database_API)). It also does [differential bundling](https://blog.meteor.com/meteor-1-7-and-the-evergreen-dream-a8c1270b0901), reducing bundle size for modern browsers.

## App structure

For our Guide app, we’ll use CRA, because it’s the most widely used and the most
basic, straightforward option. Here’s our starter app:

```sh
git clone https://github.com/GraphQLGuide/guide.git
cd guide/
git checkout 0_0.2.0
npm install
```

Now we should be able to run CRA’s development server:

```sh
npm start
```

And see our app at [localhost:3000](http://localhost:3000/):

![Create React App starting site](/img/cra.png)

Our file structure is very similar to what we get when we run
`create-react-app`:

```
.
├── .eslintrc
├── .gitignore
├── package-lock.json
├── package.json
├── public
│   ├── favicon.ico
│   ├── index.html
│   └── manifest.json
└── src
    ├── components
    │   └── App.js
    │   └── App.test.js
    ├── index.css
    ├── index.js
    └── logo.svg
```

`.eslintrc.js` — The CRA dev server (`npm start`) outputs linter warnings ([background on ESLint](https://eslint.org/docs/about/)), but it’s
nice to see the warnings directly in our text editor, so we have an `.eslintrc`
file that uses the same rules as the dev server. Most editors’ ESLint plugins
will pick this up, including
[`eslint`](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)
for our recommended editor, [VS Code](https://code.visualstudio.com/).

`package.json`

```json
{
  "name": "guide",
  "version": "0.2.0",
  "private": true,
  "dependencies": {
    "react": "16.13.1",
    "react-dom": "16.13.1",
    "react-scripts": "3.4.1",
    ...
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    ...
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
```

We have our normal react dependencies, `react` and `react-dom`, plus
`react-scripts`, which is what CRA lives inside, and which provides the
commands:

* `npm start` starts the dev server
* `npm run build` bundles the app for deployment
* `npm test` runs all the tests found in `*.test.js` files
* `npm run eject` takes us out of CRA (replaces `react-scripts` in our dependencies with a long list
  of other packages, adds a `scripts/` directory, and adds an 8-file `config/` directory
  with Webpack, Babel, and testing configuration)

`browserslist` defines which browsers the generated site will support. We can use [browserl.ist/](https://browserl.ist/) to interpret our browserlist strings:

* Supported browsers: [>0.2%, not dead, not op_mini all](https://browserl.ist/?q=%3E0.2%25%2C+not+dead%2C+not+op_mini+all)
* Not supported: [<=0.2%, dead, op_mini all](https://browserl.ist/?q=%3C%3D0.2%25%2C+dead%2C+op_mini+all)

For instance, here is the [dead](https://browserl.ist/?q=dead) list at time of writing:

![Some versions of Blackberry, IE, IE Mobile, Opera Mobile, and Samsung Internet](img/browserlist.png)

In our `public/` directory, we have a
[favicon](https://en.wikipedia.org/wiki/Favicon), `manifest.json` (which is used
when our app is added to an Android homescreen), and our only HTML page, `public/index.html` — our [SPA](bg.md#spa) shell, basically just:

```html
<!doctype html>
<html lang="en">
  <head>
    <title>The GraphQL Guide</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
```

We can add HTML, like meta tags to the head or a Google Analytics tracking
script to the bottom of the body. Our React JavaScript code gets added to the
body, and when it runs, it puts the app inside the root tag `<div
id="root"></div>`:

[`src/index.js`](https://github.com/GraphQLGuide/guide/blob/0_0.2.0/src/index.js)

```js
import React from 'react'
import { render } from 'react-dom'
import './index.css'
import App from './components/App'

render(<App />, document.getElementById('root'))

module.hot.accept()
```

Let’s look at some of the lines:

`import './index.css'` — CRA supports importing CSS from JavaScript. There are
many ways to do CSS with React, and we’ll be sticking with this single plain
`.css` file so that we can focus on the GraphQL parts of app-building.

`render(<App />, document.getElementById('root'))` — Our only component,
`<App />`, gets rendered into the `#root` div.

`module.hot.accept()` — This enables HMR ([Hot Module Replacement](https://webpack.js.org/concepts/hot-module-replacement/)), a Webpack feature that updates JavaScript when code is saved in development without reloading the page.

Here’s our App component:

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/blob/0_0.2.0/src/components/App.js)

```js
import React from 'react'

import logo from '../logo.svg'

export default () => (
  <div className="App">
    <header className="App-header">
      <img src={logo} className="App-logo" alt="logo" />
      <h1 className="App-title">The GraphQL Guide</h1>
    </header>
    <p className="App-intro">
      To get started, edit <code>src/App.js</code>, and save to reload.
    </p>
  </div>
)
```

`import logo from '../logo.svg'` — CRA supports importing files, like images and
fonts. When we import a file, it gets included in the app bundle, and we get a
URL that we can use—for example, in a `src` attribute:

```html
<img src={logo} className="App-logo" alt="logo" />
```

We also have a test file:

[`src/components/App.test.js`](https://github.com/GraphQLGuide/guide/blob/0_0.2.0/src/components/App.test.js)

```js
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'

it('renders without crashing', () => {
  const div = document.createElement('div')
  render(<App />, div)
})
```

This and any other files ending in `.test.js` get run when we do `npm test`.

## Set up Apollo

The best GraphQL library for React is
[`@apollo/client`](https://www.apollographql.com/docs/react/). It has all the features we
talked about in the [Client Libraries](#client-libraries) section and more. Our `package.json` already has these packages, but normally we would install it and `graphql` with:

```sh
npm i -S @apollo/client graphql
```

Now we need to create an instance of `ApolloClient` and wrap our app JSX in a
component called `<ApolloProvider>`, which provides our client instance to all
descendants. So we go to `src/index.js`, where our `<App />` component is
rendered, and replace the `render()` line with:

[`src/index.js`](https://github.com/GraphQLGuide/guide/blob/1_0.2.0/src/index.js)

```js
import {
  ApolloClient,
  ApolloProvider,
  InMemoryCache,
  HttpLink,
} from '@apollo/client'

const link = new HttpLink({
  uri: 'https://api.graphql.guide/graphql',
})

const cache = new InMemoryCache()

const client = new ApolloClient({ link, cache })

render(
  <ApolloProvider client={client}>
    <App />
  </ApolloProvider>,
  document.getElementById('root')
)
```

> We highly recommend typing out the code instead of copy/pasting—you’ll learn
> it better! 🤔😏👊

We tell `ApolloClient` where to send queries by giving it a network link pointed
at our GraphQL server—in this case `https://api.graphql.guide/graphql`.

# Querying

Section contents:

* [First query](6.md#first-query)
* [Loading](6.md#loading)
* [Polling](6.md#polling)
* [Subscriptions](6.md#subscriptions)
* [Lists](6.md#lists)
* [Query variables](6.md#query-variables)
* [Variable query](6.md#variable-query)

## First query

One of the fields we can query for is `githubStars`, the number of stars the
Guide’s [github repo](https://github.com/GraphQLGuide/guide) has. Let’s look at
how we can make that query and display the results. We’ll start out by adding a
component to display the star count:

[`src/components/StarCount.js`](https://github.com/GraphQLGuide/guide/blob/1_0.2.0/src/components/StarCount.js)

```js
import React from 'react'

export default () => {
  return (
    <a className="StarCount" href="https://github.com/GraphQLGuide/guide">
      {count}
    </a>
  )
}
```

But how do we get the `count` number? First we write the query, which is
pretty simple, since it’s a top-level
[scalar](3.md#scalar-types) query field:

```js
import { gql } from '@apollo/client'

const STARS_QUERY = gql`
  query StarsQuery {
    githubStars
  }
`
```

We name it `STARS_QUERY` because convention is to use all caps for query
constants. We use an
[operation name](http://graphql.org/learn/queries/#operation-name)
(`StarsQuery`) so that it’s easier to find and debug. `gql` is a
[template literal tag](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals)
that parses our [query document](2.md#document) string, converting it into a structured object
that we can pass to Apollo—now we can give it to Apollo’s `useQuery` hook:

```js
import { gql, useQuery } from '@apollo/client'

const STARS_QUERY = gql`
  query StarsQuery {
    githubStars
  }
`

export default () => {
  const { data } = useQuery(STARS_QUERY)

  return (
    <a
      className="StarCount"
      href="https://github.com/GraphQLGuide/guide"
      target="_blank"
      rel="noopener noreferrer"
    >
      {data && data.githubStars}
    </a>
  )
}
```

`useQuery` returns an object with [many properties](https://www.apollographql.com/docs/react/api/react/hooks/#result). For now, we’re just using `data`, the `"data"` attribute in the JSON response from the server. When the page is loaded and the component is created, Apollo will send the query to the server, during which `data` will be undefined. When the response arrives from the server, our function is re-run with `data` defined.

Now we can add the component to our app:

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/blob/1_0.2.0/src/components/App.js)

```js
import StarCount from './StarCount'
...
<header className="App-header">
  <StarCount />
  <img src={logo} className="App-logo" alt="logo" />
  <h1 className="App-title">The GraphQL Guide</h1>
</header>
```

And we have a working GraphQL-backed app!

![GitHub stars in header](/img/stars.png)

🙌👊

## Loading

> If you’re jumping in here, `git checkout 1_0.2.0` (tag [`1_0.2.0`](https://github.com/GraphQLGuide/guide/tree/1_0.2.0)). Tag [2_0.2.0](https://github.com/GraphQLGuide/guide/tree/2_0.2.0) contains all the code written in this section.

`loading` is another property returned by `useQuery()`. It’s `true` when a network request is in flight. 

When we reload the app, we see a flash of “⭐️ stars” before the number appears,
pushing `stars` to the right. When `<StarCount>` is rendered the first time, it
doesn’t have the number of stars yet. Let’s log `data` and `loading` to see it happening:

[`src/components/StarCount.js`](https://github.com/GraphQLGuide/guide/blob/1_0.2.0/src/components/StarCount.js)

```js
export default () => {
  const { data, loading } = useQuery(STARS_QUERY)

  console.log('rendering StarCount', data, loading)
```

```
rendering StarCount undefined true
rendering StarCount {githubStars: 102} false
```

We see that it’s rendered twice—first `loading` is `true` and `data` is
`undefined`, and then later, once the query has finished, `loading` is `false`
and `data` is an object.

`⭐️ stars` without a number doesn’t make sense, and `stars` jumping to the
right when the number appears doesn’t look nice, so let’s hide
everything until the number has arrived by adding the modifier CSS class
`'loading'` when the `loading` prop is `true`:

```js
import classNames from 'classnames'

export default () => {
  const { data, loading } = useQuery(STARS_QUERY)

  return (
    <a
      className={classNames('StarCount', { loading })}
```

> `classNames` takes strings or objects as arguments and combines them into a
> React `className` string. For objects, it includes the key if the value is
> true. For example, `classNames('a', { b: false, c: true }, 'd')` returns `'a c
> d'`.

When `loading` becomes `false`, the CSS class `'loading'` is removed, and the
component fades in.

## Polling

Right now our star count is static—once it’s fetched, the number remains on the
page until the page is refreshed. If the actual number of stars on the
repository changes, we won’t know until we refresh. If we want to keep the
number (and any other GraphQL data) up to date, we can do so in two different
ways: polling and [subscriptions](2.md#subscriptions). Polling is much easier to
implement, so let’s do that first. We can add a [`pollInterval`](https://www.apollographql.com/docs/react/api/react/hooks/#params) option to our query in `StarCount.js`:

[`src/components/StarCount.js`](https://github.com/GraphQLGuide/guide/blob/2_0.2.0/src/components/StarCount.js)

```js
export default () => {
  const { data, loading } = useQuery(STARS_QUERY, {
    pollInterval: 5 * 1000,
  })
```

Now every five seconds, Apollo
will resend our `STARS_QUERY`. If the response has a different value for
`githubStars`, Apollo will pass us the new prop, which will trigger a
component re-render, and the new count will be displayed on the page.

Depending on what type of data we’re keeping up to date, we may want to use some
kind of visual cue or animation when it changes. There are a few possible
motivations for this:

1. Calling attention to the change to make the user aware that it
   happened—a common example in this category is the brief yellow background glow.
   Another example is in Google Docs—the colored cursor labeled with a name that
   follows someone’s live edits. However, sometimes a user doesn’t need to know
   that a piece of data has changed, and calling attention to it would
   needlessly distract them from what they were paying attention to.
2. Making the change visually smoother. If a change in the data triggers some
   node on the page to change in size, and there are other nodes on the page
   around it, the other nodes might jump to a new location when the browser
   reflows—for example, if the data is a paragraph of text, and the updated
   paragraph is twice as long, everything below that paragraph will be pushed
   down. We can make this change look nicer by animating the data container to
   its new size and animating the displaced components to their new locations.
   This also gives time for the user to notice which part of the page changed,
   which is helpful for situations in which the user doesn’t realize why things on
   the page jumped around.
3. For fun 😄. Animations can be fun, and sometimes we add them just because we like how it feels.

The data change that happens in our app is a number that is usually just going
up by 1. This type of change is well-suited to an odometer animation, where each
digit is on a number wheel that rotates up or down to reveal the next number.
The benefit of this animation is #3, and the downside is #1—the odometer
changing draws more attention to the change than a non-animated change does, but
the user doesn’t need to know when the star count changes (they’re just trying
to read the book!). So we might not add this animation to a serious app, but
let’s add it to our app for fun 😊. It’s easy with the
[`react-odometerjs`](https://www.npmjs.com/package/react-odometerjs) component:

[`src/components/StarCount.js`](https://github.com/GraphQLGuide/guide/blob/2_0.2.0/src/components/StarCount.js)

```js
import Odometer from 'react-odometerjs'

...

    <a
      className={classNames('StarCount', { loading })}
      href="https://github.com/GraphQLGuide/guide"
      target="_blank"
      rel="noopener noreferrer"
    >
      {data && <Odometer value={data.githubStars} />}
    </a>
```

Now when the polling `STARS_QUERY` results in a new `githubStars` value, we pass
the new number to the `<Odometer>` component, which does the animation.

We can test it out by starring and un-starring
the [repository on GitHub](https://github.com/GraphQLGuide/guide) and watching the number
in our app update.

## Subscriptions

Background: [webhooks](bg.md#webhooks)

> If you’re jumping in here, `git checkout 2_0.2.0` (tag [`2_0.2.0`](https://github.com/GraphQLGuide/guide/tree/2_0.2.0)). Tag [3_0.2.0](https://github.com/GraphQLGuide/guide/tree/3_0.2.0) contains all the code written in this section.

When we poll for new data every 5 seconds, it takes 2.5 seconds on average (as
little as 0, and as much as 5) for a change to show up, plus a little time for
the server to talk to GitHub and get the response back to us. For certain types
of apps, like a chat app or multiplayer games, it’s important to receive updates
in less than 2.5 seconds. One thing we can do is reduce the poll interval—for
instance, a 500 ms interval would mean an average update speed of 250 ms (plus
server response time). This would be fast enough for a chat app but not fast
enough for some games. And it comes at a certain cost in server workload (it now
has to respond to 10 times as many requests) and browser workload (sending
requests takes up main-thread JavaScript time, perhaps during one of the
[10ms windows](https://developers.google.com/web/fundamentals/performance/rail)
in which the thread needs to quickly calculate a 60 fps animation). So
while polling is often the best choice given its simplicity to implement (we
just added that single [`pollInterval` option](#polling)), sometimes we want
something more efficient and real-time.

In these cases we can use GraphQL
[subscriptions](https://dev-blog.apollodata.com/graphql-subscriptions-in-apollo-client-9a2457f015fb),
in which our server will send us updates to our data as they occur. The main
drawback to subscriptions is that it takes extra work to implement on the
server. (In the last chapter we’ll learn how to
[add subscription support](11.md#subscriptions).) Another possible drawback is
that if the subscription data changes frequently, it can hurt client performance
by taking up time receiving, updating the cache, and re-rendering the page.

While GraphQL servers can support different methods of transporting subscription
updates to clients (the GraphQL spec is transport-agnostic), the usual method is
over WebSockets. 

> *WebSocket* is a format for sending messages over the internet (like [HTTP](bg.md#http)). It allows for very fast two-way communication by keeping a connection open and allowing the server to initiate messages to the client.

We could replace our HTTP link with a [WebSocket
link](https://www.apollographql.com/docs/react/api/link/apollo-link-ws/) in `index.js`:


```js
import { WebSocketLink } from '@apollo/client/link/ws'

const link = new WebSocketLink({
  uri: `wss://api.graphql.guide/subscriptions`,
  options: {
    reconnect: true
  }
})
```

This would establish a WebSocket connection that remains open for the duration of the client session, and all GraphQL communication
(queries, mutations, and subscriptions) would be sent over the connection. However, authentication over the WebSocket is a little involved, so we’ll go with a hybrid transport solution: we’ll send queries and mutations over an HTTP link (which we’ll add auth to later), and we’ll send subscriptions over the unauthenticated WebSocket link. We can do this because all of the data used in the Guide’s real-time features (for example `StarCount`, and later on, reviews) is public. 

[`src/index.js`](https://github.com/GraphQLGuide/guide/blob/3_0.2.0/src/index.js)

```js
import { split } from '@apollo/client'
import { WebSocketLink } from '@apollo/client/link/ws'
import { getMainDefinition } from '@apollo/client/utilities'

const httpLink = new HttpLink({
  uri: 'https://api.graphql.guide/graphql'
})

const wsLink = new WebSocketLink({
  uri: `wss://api.graphql.guide/subscriptions`,
  options: {
    reconnect: true
  }
})

const link = split(
  ({ query }) => {
    const { kind, operation } = getMainDefinition(query)
    return kind === 'OperationDefinition' && operation === 'subscription'
  },
  wsLink,
  httpLink
)
```

The `ApolloClient` constructor options object takes a single link, so we need to compose our two links together. We can use the [`split()` function](https://www.apollographql.com/docs/link/composition/#directional-composition), which takes a function and two links. The function is given the current query, and if it returns true, the first link is used for the query; otherwise, the second is used. In our `split()` function we look up the query operation and return true if it’s a subscription query, which directs the query to the WebSocket link `wsLink`.

Now we can subscribe to updates to the star count with this simple subscription:

[`src/components/StarCount.js`](https://github.com/GraphQLGuide/guide/blob/3_0.2.0/src/components/StarCount.js)

```js
const STARS_SUBSCRIPTION = gql`
  subscription StarsSubscription {
    githubStars
  }
`
```

To start the subscription, we use a function
[`subscribeToMore`](https://www.apollographql.com/docs/react/features/subscriptions.html#subscribe-to-more)
that `useQuery()` returns:

[`src/components/StarCount.js`](https://github.com/GraphQLGuide/guide/blob/3_0.2.0/src/components/StarCount.js)

```js
import { useEffect } from 'react'

export default () => {
  const { data, loading, subscribeToMore } = useQuery(STARS_QUERY, {
    pollInterval: 5 * 1000,
  })

  useEffect(
    () =>
      subscribeToMore({
        document: STARS_SUBSCRIPTION,
        updateQuery: (
          _,
          {
            subscriptionData: {
              data: { githubStars },
            },
          }
        ) => ({ githubStars }),
      }),
    [subscribeToMore]
  )

  return (
    <a
      className={classNames('StarCount', { loading })}
      href="https://github.com/GraphQLGuide/guide"
      target="_blank"
      rel="noopener noreferrer"
    >
      {data && <Odometer value={data.githubStars} />}
    </a>
  )
}
```

We want to start the subscription when the component is initialized, so we use [`useEffect()`](https://reactjs.org/docs/hooks-effect.html). While the `subscribeToMore` won’t be changing, we include it in the dependency array (instead of passing an empty array) because it’s required by our linting.

`subscribeToMore` takes the GraphQL document specifying our subscription and an
`updateQuery` function. `updateQuery` is called each time the client receives
new subscription data from the server. The first argument `updateQuery` is given is the result of the previous query (`{ githubStars: 102 }` in our case), and the second is the subscription event data. It returns an updated query result, which is used to provide new props to the component. In this example, we’re just replacing the old result with the GitHub star count received
in the `subscriptionData`. But if GitHub never lets us un-star repos, and the
star count only ever increased, then we might use a `justGotStarred`
subscription that published `{ newStar: true }` to the client. Then our
`updateQuery` would look like:

```js
  subscribeToMore({
    document: JUST_GOT_STARRED_SUBSCRIPTION,
    updateQuery: previousResult => ({ 
      githubStars: previousResult + 1
    }),
  }),
```

The last thing we need to do is test whether our `STARS_SUBSCRIPTION` is working:
we stop polling by removing the `pollInterval` option from our `useQuery()`:

```js
export default () => {
  const { data, loading, subscribeToMore } = useQuery(STARS_QUERY)
```

Now we can star and unstar the
[Guide repo](https://github.com/GraphQLGuide/guide) and see the count quickly
change in our app. We might notice a slight delay sometimes, and that’s because
the server is polling the GitHub API once a second for updates, so the
subscription data reaching the client could be as old as 1 second plus network
time. We could improve this by reducing the polling interval on the server or by
setting up a [webhook](bg.md#webhook)—the most efficient and lowest-latency solution,
in which the only delay would be network time. With a webhook, GitHub would immediately notify
our server of the change, and the server would immediately send the subscription
update over the WebSocket to the client.

## Lists

> If you’re jumping in here, `git checkout 3_0.2.0` (tag [`3_0.2.0`](https://github.com/GraphQLGuide/guide/tree/3_0.2.0)). Tag [`4_0.2.0`](https://github.com/GraphQLGuide/guide/tree/4_0.2.0) contains all the code written in this section.

> See the [Listing reviews](#listing-reviews) section for another example of querying a list of data.

Next let’s get to the heart of our app—the stuff below the header! We’ll want to
reserve most of the space for the book content, since there’s a lot of it, and
reading it is the purpose of the app 😜. But let’s put a thin sidebar on the left
for the table of contents so that readers can easily navigate between sections.

To begin, we replace the `<p>` in `<App>` with the two new sections of the page:

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/blob/4_0.2.0/src/components/App.js)

```js
import TableOfContents from './TableOfContents'
import Section from './Section'

...

<div className="App">
  <header className="App-header">
    <StarCount />
    <img src={logo} className="App-logo" alt="logo" />
    <h1 className="App-title">The GraphQL Guide</h1>
  </header>
  <TableOfContents />
  <Section />
</div>
```

We call the second component `Section` because it will display a single section
of a chapter at a time. Let’s think about the loading state first—we’ll be
fetching the table of contents and the section content from the API. We could do
a loading spinner, but a nicer alternative when we’re waiting for text to load
is a loading skeleton—an animated gray bar placed where the text will appear.
Let’s put a few bars in both components:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/4_0.2.0/src/components/Section.js)

```js
import React from 'react'
import Skeleton from 'react-loading-skeleton'

export default () => {
  const loading = true

  return (
    <section className="Section">
      <div className="Section-header-wrapper">
        <header className="Section-header">
          <h1>Title</h1>
          <h2>Subtitle</h2>
        </header>
      </div>
      <div className="Section-content">{loading && <Skeleton count={7} />}</div>
    </section>
  )
}
```

`count={7}` will give us 7 gray bars, representing 7 lines of text. Now for the
sidebar:

[`src/components/TableOfContents.js`](https://github.com/GraphQLGuide/guide/blob/4_0.2.0/src/components/TableOfContents.js)

```js
import React from 'react'
import Skeleton from 'react-loading-skeleton'

export default () => {
  const loading = true

  return (
    <nav className="TableOfContents">
      {loading ? (
        <div>
          <h1>
            <Skeleton />
          </h1>
          <Skeleton count={4} />
        </div>
      ) : null}
    </nav>
  )
}
```

`<Skeleton>` picks up the surrounding font size, so we’ll see a larger gray line
(in place of a chapter title) and then 4 smaller lines (in place of section
titles):

![Loading skeleton](/img/loading-skeleton.png)

Now let’s construct the query for the data we need to display in
`TableOfContents`. We can explore the Guide API’s schema in GraphQL Playground, an IDE for writing GraphQL queries. Its playground is located at [api.graphql.guide/play](https://api.graphql.guide/play). In the below screenshot, we’re querying for `{ githubStars }`. On the left side we have the GraphQL document, and when we click the play button (or `command-return`), we see the response on the right:

![Playground: query { githubStars }](/img/play-githubStars.png)

<!-- [Playground: `query { githubStars }`](https://www.graphqlbin.com/qj7PuX) -->

Now let’s delete `githubStars`, and with our cursor in between the `query` braces, we hit `control-space` to bring up query suggestions:

![Playground with query suggestions](/img/play-suggestions.png)

The one we want is `chapters`. Now we can add an inner set of braces (the
[selection set](2.md#selection-sets) on `chapters`), move our cursor inside, and hit `control-space` again to see the available fields of a `Chapter` (which is the type that `chapters` returns):

```gql
query {
  chapters {

  }
}
```

We’ll want to display the `title` and the `sections`, and we do the same to see
which fields of a `Section` we want.

```gql
query {
  chapters {
    title
    sections {

    }
  }
}
```

And we see `title`, which we will want for each section. 

![Playground Section field suggestions](/img/play-section-suggestions.png)

We will also want to display the chapter and section numbers, so let’s add those as well. Our whole query is:

```gql
query {
  chapters {
    number
    title
    sections {
      number
      title
    }
  }
}
```

We can see what the data looks like by hitting the play button or
`command-return`. 

![Playground chapters query response](/img/play-chapters.png)

To use our query in our component, we give it a name,
`ChapterQuery`, put it inside a `gql` template string, and use `useQuery()`:

[`src/components/TableOfContents.js`](https://github.com/GraphQLGuide/guide/blob/4_0.2.0/src/components/TableOfContents.js)

```js
import { gql, useQuery } from '@apollo/client'

const CHAPTER_QUERY = gql`
  query ChapterQuery {
    chapters {
      id
      number
      title
      sections {
        id
        number
        title
      }
    }
  }
`

export default () => {
  const { data: { chapters } = {}, loading } = useQuery(CHAPTER_QUERY)

  return ( ... )
```

Now we can use `chapters` in our JSX. For each chapter we display a
list of links to each section:

[`src/components/TableOfContents.js`](https://github.com/GraphQLGuide/guide/blob/4_0.2.0/src/components/TableOfContents.js)

```js
import { NavLink } from 'react-router-dom'
import classNames from 'classnames'

import { slugify, withHyphens } from '../lib/helpers'

const LoadingSkeleton = () => (
  <div>
    <h1>
      <Skeleton />
    </h1>
    <Skeleton count={4} />
  </div>
)

export default () => {
  const { data: { chapters } = {}, loading } = useQuery(CHAPTER_QUERY)

  return (
    <nav className="TableOfContents">
      {loading ? (
        <LoadingSkeleton />
      ) : (
        <ul className="TableOfContents-chapters">
          {chapters.map(chapter => {
            const chapterIsNumbered = chapter.number !== null
            return (
              <li
                className={classNames({ numbered: chapterIsNumbered })}
                key={chapter.id}
              >
                <NavLink
                  to={{
                    pathname: slugify(chapter),
                    state: { chapter, section: chapter.sections[0] }
                  }}
                  className="TableOfContents-chapter-link"
                  activeClassName="active"
                  isActive={(match, location) => {
                    const rootPath = location.pathname.split('/')[1]
                    return rootPath.includes(withHyphens(chapter.title))
                  }}
                >
                  {chapterIsNumbered && (
                    <span className="TableOfContents-chapter-number">
                      {chapter.number}
                    </span>
                  )}
                  {chapter.title}
                </NavLink>
                {chapterIsNumbered && (
                  <ul className="TableOfContents-sections">
                    {chapter.sections.map(section => (
                      <li key={section.number}>
                        <NavLink
                          to={{
                            pathname: slugify(chapter, section),
                            state: { chapter, section }
                          }}
                          className="TableOfContents-section-link"
                          activeClassName="active"
                        >
                          {section.title}
                        </NavLink>
                      </li>
                    ))}
                  </ul>
                )}
              </li>
            )
          })}
        </ul>
      )}
    </nav>
  )
}
```

Okay, so that was a lot of code 😁. We’ve got an outer list of chapters, and for each chapter we have an inner list of sections. We’ve got React Router `<NavLink>`s that add an `"active"` class when the URL matches the link path. And we use the `slugify()` helper to generate paths.

[`src/lib/helpers.js`](https://github.com/GraphQLGuide/guide/blob/4_0.2.0/src/lib/helpers.js)

```js
export const withHyphens = (string) => string.replace(/ /g, '-')

// generate paths of the form:
// `/Forward`
// `/Preface`
// `/1-Understanding-GraphQL-through-REST/1-Introduction`
export const slugify = (chapter, section) => {
  if (!section) {
    if (chapter.sections.length) {
      // default to the first section
      section = chapter.sections[0]
    } else {
      return '/' + withHyphens(chapter.title)
    }
  }

  const chapterSlug = chapter.number + '-' + withHyphens(chapter.title)
  const sectionSlug = section.number + '-' + withHyphens(section.title)
  return `/${chapterSlug}/${sectionSlug}`
}
```

Also, to get React Router working, we need to wrap our app in `<BrowserRouter>`:

[`src/index.js`](https://github.com/GraphQLGuide/guide/blob/4_0.2.0/src/index.js)

```js
import { BrowserRouter } from 'react-router-dom'

render(
  <BrowserRouter>
    <ApolloProvider client={client}>
      <App />
    </ApolloProvider>
  </BrowserRouter>,
  document.getElementById('root')
)
```

With all this JSX code, we’re starting to feel the best thing about GraphQL on the client side—that most of the coding is in the view instead of in data fetching. We don’t have a bunch of code for REST endpoint fetching and parsing and caching and passing; instead, we attach simple query strings to the components that need them, and we get the data in the props.

Now we should see the table of contents on the left side of the page, and we can click between sections and see the active links and path changing:

![Table of contents](/img/table-of-contents.png)

## Query variables

> If you’re jumping in here, `git checkout 4_0.2.0` (tag [`4_0.2.0`](https://github.com/GraphQLGuide/guide/tree/4_0.2.0)). Tag [`5_0.2.0`](https://github.com/GraphQLGuide/guide/tree/5_0.2.0) contains all the code written in this section.

Let’s fill in the book content next! Say we have a section ID, like `'intro'`—how do we get the content? Let’s look in [Playground](https://api.graphql.guide/play) to find the right query to make:

![Playground SCHEMA tab](/img/section-query-schema.png)
 
There’s a `section(id: String!)` query that returns a `Section` object, which has a `content` field. So let’s try it out:

![section query with results](/img/section-query-playground.png)
<!-- [Playground: `query { section(id: "intro") { content }}`](https://graphqlbin.com/pg8rs -->

Next we add the query to our component:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/5_0.2.0/src/components/Section.js)

```js
import { gql, useQuery } from '@apollo/client'

const SECTION_QUERY = gql`
  query SectionContent {
    section(id: "intro") {
      content
    }
  }
`

export default () => {
  const { data, loading } = useQuery(SECTION_QUERY)

  ...
```

Now `data.section` will have the same `content` string that we saw returned in Playground, and we can display it:

[src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/5_0.2.0/src/components/Section.js)

```js
import get from 'lodash/get'

export default () => {
  const { data, loading } = useQuery(SECTION_QUERY)

  return (
    <section className="Section">
      <div className="Section-header-wrapper">
        <header className="Section-header">
          <h1>Title</h1>
          <h2>Subtitle</h2>
        </header>
      </div>
      <div className="Section-content">
        {loading ? <Skeleton count={7} /> : get(data, 'section.content')}
      </div>
    </section>
  )
}
```

We can read the book! 📖 But we’ve got a hard-coded section ID—let’s turn our `section(id: "intro")` argument into a variable:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/5_0.2.0/src/components/Section.js)

```js
const SECTION_QUERY = gql`
  query SectionContent($id: String!) {
    section(id: $id) {
      content
    }
  }
`

export default () => {
  const { data, loading } = useQuery(SECTION_QUERY, {
    variables: { id: 'intro' },
  })

  ...
```

- `query SectionContent($id: String!) {`: We declare at the top that the `SectionContent` query takes a variable `$id`, a required `String`.
- `section(id: $id) {`: We replace our string literal `"intro"` with the variable `$id`.
- `{ variables: { id: 'intro' } }`: We tell `useQuery()` to pass an `id` variable to the query.

Now passing the variable to the query is working, but we still have `'intro'` hard-coded. Where do we get the section ID from? Back in `TableOfContents`, we gave a `to` prop to our `NavLinks`:

```js
<NavLink
  to={{
    pathname: slugify(chapter, section),
    state: { chapter, section }
  }}
```

The `pathname` is the equivalent of an anchor tag’s `href` attribute, but `state` is part of the HTML5 [session history management](https://developer.mozilla.org/en-US/docs/Web/API/History_API#The_pushState()_method). We can access it at `window.location.state`, but we also want our components to react to changes, so we want it as a prop. The best way to use browser history state with `react-router` is with the [`useLocation` hook](https://reactrouter.com/web/api/Hooks/uselocation), which returns the `location` object, which has a `.state` property:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/5_0.2.0/src/components/Section.js)

```js
import { useLocation } from 'react-router'

export default () => {
  const {
    state: { section, chapter },
  } = useLocation()

  const { data, loading } = useQuery(SECTION_QUERY, {
    variables: { id: section.id },
  })

  ...
```

> If you get `TypeError: Cannot read property 'section' of undefined`, look ahead to the next section to see the solution.

Let’s fill in our component with our newly available data:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/5_0.2.0/src/components/Section.js)

```js
export default () => {
  const {
    state: { section, chapter },
  } = useLocation()

  const { data, loading } = useQuery(SECTION_QUERY, {
    variables: { id: section.id },
  })

  return (
    <section className="Section">
      <div className="Section-header-wrapper">
        <header className="Section-header">
          {chapter.number !== null ? (
            <div>
              <h1>{section.title}</h1>
              <h2>
                {'Chapter ' + chapter.number}
                <span className="Section-number-divider" />
                {'Section ' + section.number}
              </h2>
            </div>
          ) : (
            <h1>{chapter.title}</h1>
          )}
        </header>
      </div>
      <div className="Section-content">
        {loading ? <Skeleton count={7} /> : get(data, 'section.content')}
      </div>
    </section>
  )
}
```

We can see this working by clicking a different section in the table of contents. The path will change and a new `state` will be set, which `useLocation` will provide to the component, which provides a new `id` to `useQuery`, triggering a new query sent to the server, which will return the new section content, which triggers a re-render, during which the book content on the right updates. 

![Section content](/img/section-content.png)

## Variable query

> If you’re jumping in here, `git checkout 5_0.2.0` (tag [`5_0.2.0`](https://github.com/GraphQLGuide/guide/tree/5_0.2.0)). Tag [`6_0.2.0`](https://github.com/GraphQLGuide/guide/tree/6_0.2.0) contains all the code written in this section.

If you’ve kept your development browser tab open during this section, then everything has worked smoothly for you. But when we open a [new tab](http://localhost:3000/introduction), we find a bug:

`TypeError: Cannot read property 'section' of undefined`
```js
export default () => {
  const {
    state: { section, chapter },
  } = useLocation()
```

It looks like `location.state` is undefined! 🐞 Which makes sense, because in a new tab, we haven’t yet clicked a `<NavLink>`, so the state hasn’t been set. If we don’t have the state, how do we get the section ID so that we can query for the right content? The only information we have on first page load is the path, so we have to parse it. [`location.pathname`](https://reacttraining.com/react-router/web/api/location) will always be defined, so we can `deslugify()` it:

[`src/lib/helpers.js`](https://github.com/GraphQLGuide/guide/blob/6_0.2.0/src/lib/helpers.js)

```js
// parse a path:
// /Introduction
// -> { chapterTitle: 'Introduction' }
//
// /1-Understanding-GraphQL-through-REST/1-Introduction
// -> { chapterNumber: 1, sectionNumber: 1 }
export const deslugify = (path) => {
  const [, chapterSlug, sectionSlug] = path.split('/')
  const chapterIsNumbered = !!sectionSlug

  return chapterIsNumbered
    ? {
        chapterNumber: parseInt(chapterSlug.split('-')[0], 10),
        sectionNumber: parseInt(sectionSlug.split('-')[0], 10),
      }
    : { chapterTitle: chapterSlug }
}
```

Now let’s look at Playground to figure out which two queries we can use, given either the chapter title or the chapter and section numbers:

![chapterByTitle and Chapter.section(number: Int!)](/img/chapterByTitle-schema.png)

We can use the `chapterByTitle` and `chapterByNumber` root query fields along with a `Chapter`’s `section` field with a `number: Int!` argument. (Any field, not just root fields, can have arguments.)

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/6_0.2.0/src/components/Section.js)

```js
const SECTION_BY_ID_QUERY = gql`
  query SectionContent($id: String!) {
    section(id: $id) {
      content
    }
  }
`

const SECTION_BY_CHAPTER_TITLE_QUERY = gql`
  query SectionByChapterTitle($title: String!) {
    chapterByTitle(title: $title) {
      title
      section(number: 1) {
        content
      }
    }
  }
`

const SECTION_BY_NUMBER_QUERY = gql`
  query SectionByChapterTitle($chapterNumber: Int!, $sectionNumber: Int!) {
    chapterByNumber(number: $chapterNumber) {
      number
      section(number: $sectionNumber) {
        number
        title
        content
      }
    }
  }
`
```

For `chapterByTitle`, all the non-numbered chapters only have a single section that is title-less. For `chapterByNumber`, we need the section title in addition to the contents, because we display it at the top of the component. 

In our component, we need to decide which query to use, depending on which scenario we’re in:

```js
export default () => {
  const { state, pathname } = useLocation()

  const page = deslugify(pathname)

  let query, variables

  if (state) {
    query = SECTION_BY_ID_QUERY
  } else if (page.chapterTitle) {
    query = SECTION_BY_CHAPTER_TITLE_QUERY
  } else {
    query = SECTION_BY_NUMBER_QUERY
  }

  const { data, loading } = useQuery(query, { variables })

  ...
```

If we have state, we can use the query we were using before, `SECTION_BY_ID_QUERY`. If we received a chapter title from `deslugify()`, we can use `SECTION_BY_CHAPTER_TITLE_QUERY`. Otherwise, we should have `page.chapterNumber` and `page.sectionNumber`, and we can use `SECTION_BY_NUMBER_QUERY`. 

Each of these queries takes different variables, so we decide those inside the if-statement: 

```js
export default () => {
  const { state, pathname } = useLocation()

  const page = deslugify(pathname)

  let query, variables

  if (state) {
    query = SECTION_BY_ID_QUERY 
    variables = { id: state.section.id }    
  } else if (page.chapterTitle) {
    query = SECTION_BY_CHAPTER_TITLE_QUERY
    variables = { title: page.chapterTitle }
  } else {
    query = SECTION_BY_NUMBER_QUERY
    variables = pick(page, 'chapterNumber', 'sectionNumber')
  }

  const { data, loading } = useQuery(query, { variables })

  ...
```

Now we have the correct `variables` for each query. However, the `data` we get back from each query is also different. So we construct `section` and `chapter` objects to use in our JSX:

```js
  const { data, loading } = useQuery(query, { variables })

  let section, chapter

  // eslint-disable-next-line default-case
  switch (query) {
    case SECTION_BY_ID_QUERY:
      section = {
        ...state.section,
        content: get(data, 'section.content'),
      }
      chapter = state.chapter
      break
    case SECTION_BY_CHAPTER_TITLE_QUERY:
      section = get(data, 'chapterByTitle.section')
      chapter = {
        ...get(data, 'chapterByTitle'),
        number: null,
      }
      break
    case SECTION_BY_NUMBER_QUERY:
      section = get(data, 'chapterByNumber.section')
      chapter = get(data, 'chapterByNumber')
      break
  }
```

`data` will have either a `section`, `chapterByTitle`, or `chapterByNumber` property, depending on which query was used. We disable the eslint rule requiring a default case because we know from our previous if-statement that there are only 3 possibilities. 

Now we can use `section` and `chapter` in our JSX:

```js
  let headerContent = null,
    sectionContent = null

  if (loading) {
    headerContent = (
      <h1>
        <Skeleton />
      </h1>
    )
    sectionContent = <Skeleton count={7} />
  } else if (!section) {
    headerContent = (
      <h1>
        <span role="img" aria-label="magnifying glass">
          🔍
        </span>{' '}
        404 page not found
      </h1>
    )
  } else {
    if (chapter.number !== null) {
      headerContent = (
        <div>
          <h1>{section.title}</h1>
          <h2>
            {'Chapter ' + chapter.number}
            <span className="Section-number-divider" />
            {'Section ' + section.number}
          </h2>
        </div>
      )
    } else {
      headerContent = <h1>{chapter.title}</h1>
    }

    sectionContent = section.content
  }

  return (
    <section className="Section">
      <div className="Section-header-wrapper">
        <header className="Section-header">{headerContent}</header>
      </div>
      <div className="Section-content">{sectionContent}</div>
    </section>
  )
```

All together, that’s:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/6_0.2.0/src/components/Section.js)

```js
import React from 'react'
import Skeleton from 'react-loading-skeleton'
import { gql, useQuery } from '@apollo/client'
import { useLocation } from 'react-router'
import get from 'lodash/get'
import pick from 'lodash/pick'

import { deslugify } from '../lib/helpers'

const SECTION_BY_ID_QUERY = gql`
  query SectionContent($id: String!) {
    section(id: $id) {
      content
    }
  }
`

const SECTION_BY_CHAPTER_TITLE_QUERY = gql`
  query SectionByChapterTitle($title: String!) {
    chapterByTitle(title: $title) {
      title
      section(number: 1) {
        content
      }
    }
  }
`

const SECTION_BY_NUMBER_QUERY = gql`
  query SectionByNumber($chapterNumber: Int!, $sectionNumber: Int!) {
    chapterByNumber(number: $chapterNumber) {
      number
      section(number: $sectionNumber) {
        number
        title
        content
      }
    }
  }
`

export default () => {
  const { state, pathname } = useLocation()

  const page = deslugify(pathname)

  let query, variables

  if (state) {
    query = SECTION_BY_ID_QUERY
    variables = { id: state.section.id }
  } else if (page.chapterTitle) {
    query = SECTION_BY_CHAPTER_TITLE_QUERY
    variables = { title: page.chapterTitle }
  } else {
    query = SECTION_BY_NUMBER_QUERY
    variables = pick(page, 'chapterNumber', 'sectionNumber')
  }

  const { data, loading } = useQuery(query, { variables })

  let section, chapter

  // eslint-disable-next-line default-case
  switch (query) {
    case SECTION_BY_ID_QUERY:
      section = {
        ...state.section,
        content: get(data, 'section.content'),
      }
      chapter = state.chapter
      break
    case SECTION_BY_CHAPTER_TITLE_QUERY:
      section = get(data, 'chapterByTitle.section')
      chapter = {
        ...get(data, 'chapterByTitle'),
        number: null,
      }
      break
    case SECTION_BY_NUMBER_QUERY:
      section = get(data, 'chapterByNumber.section')
      chapter = get(data, 'chapterByNumber')
      break
  }

  let headerContent = null,
    sectionContent = null

  if (loading) {
    headerContent = (
      <h1>
        <Skeleton />
      </h1>
    )
    sectionContent = <Skeleton count={7} />
  } else if (!section) {
    headerContent = (
      <h1>
        <span role="img" aria-label="magnifying glass">
          🔍
        </span>{' '}
        404 page not found
      </h1>
    )
  } else {
    if (chapter.number !== null) {
      headerContent = (
        <div>
          <h1>{section.title}</h1>
          <h2>
            {'Chapter ' + chapter.number}
            <span className="Section-number-divider" />
            {'Section ' + section.number}
          </h2>
        </div>
      )
    } else {
      headerContent = <h1>{chapter.title}</h1>
    }

    sectionContent = section.content
  }

  return (
    <section className="Section">
      <div className="Section-header-wrapper">
        <header className="Section-header">{headerContent}</header>
      </div>
      <div className="Section-content">{sectionContent}</div>
    </section>
  )
}
```

Now when we open [/introduction](http://localhost:3000/introduction) or [/1-Understanding-GraphQL-through-REST/1-Introduction](http://localhost:3000/1-Understanding-GraphQL-through-REST/1-Introduction) in new tabs, we get the right section content instead of an error! 🐞✅ 

In [Apollo devtools](5.md#devtools), we can look at the active queries on the page, which will let us see which of our three section queries is being used:

![SectionContent](/img/SectionContent.png)

![SectionByNumber](/img/SectionByNumber.png)

The first image is from a tab in which we’ve been navigating with the table of contents, and it uses the `SectionContent` query. The second image is from a newly opened tab, and it uses `SectionByNumber`.

Lastly, let’s redirect from the root, which currently shows 404 and prints a GraphQL error to the console (we didn’t provide the `$chapterNumber` variable because there’s nothing in the URL to deslugify).

![404 page not found](/img/404-root.png)

So far, we haven’t defined any routes—`Section` just changes what data it shows based on the path. We can create a root route that redirects to `/Preface`:

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/blob/6_0.2.0/src/components/App.js)

```js
import { Switch, Route, Redirect } from 'react-router'

const Book = () => (
  <div>
    <TableOfContents />
    <Section />
  </div>
)

export default () => (
  <div className="App">
    <header className="App-header">
      <StarCount />
      <img src={logo} className="App-logo" alt="logo" />
      <h1 className="App-title">The GraphQL Guide</h1>
    </header>
    <Switch>
      <Route exact path="/" render={() => <Redirect to="/Preface" />} />
      <Route component={Book} />
    </Switch>
  </div>
)
```

Assuming we always want to keep our header on the page regardless of which route we’re on, we put the `<Route>`s below the header in lieu of `<TableOfContents />` and `<Section />`, which we move to a new `Book` component. `<Switch>` renders the first `<Route>` that matches. The first route matches only `/` and redirects, and the second route matches everything else and displays `Book`. 

Now loading [`localhost:3000/`](http://localhost:3000/) redirects to `localhost:3000/Preface`, and the GraphQL error is gone from the console. 🐞✅

# Authentication

Section contents:

* [Logging in](6.md#logging-in)
* [Resetting](6.md#resetting)

## Logging in

Background: [Authentication](bg.md#authentication)

> If you’re jumping in here, `git checkout 6_0.2.0` (tag [`6_0.2.0`](https://github.com/GraphQLGuide/guide/tree/6_0.2.0)). Tag [`7_0.2.0`](https://github.com/GraphQLGuide/guide/tree/7_0.2.0) contains all the code written in this section.

We’ll have noticed by now that we’re not getting the entire section content from the Guide API, and that’s because we’re not logged in. When we bought the book, we created a user account that was associated with our purchase. In order to see the full content, we need to log in with that account.

Authentication is important and complex enough that we rarely want to code it ourselves—we probably should use a library or service. For node backends, the most common library is [passport](http://www.passportjs.org/). We’ll instead use a service—[Auth0](https://auth0.com/)—for ease of integration. There are pros and cons to [signed tokens vs. sessions](bg.md#tokens-vs-sessions) and [localStorage vs. cookies](bg.md#localstorage-vs-cookies), but we’ll go with the most straightforward option for Auth0 integration: tokens stored in localStorage. They have a number of authentication methods (called "Connections" in Auth0 or "strategies" in Passport), including email/password, [passwordless](https://auth0.com/passwordless) (SMS one-time codes, email magic login links, and/or TouchID), and Social OAuth providers. While Auth0 makes it easy to provide multiple options, for simplicity’s sake, we’ll just provide GitHub OAuth—all of our users are developers, and they’re likely already logged into their GitHub account on most of their browsers, so the login process should be really easy. If we were building for a different market, we might prefer passwordless instead.

A common login sequence is this: the user clicks a login button, which redirects them to the GitHub OAuth page, and after they do GitHub login (if needed), they authorize our app and are redirected back to our site. One UX drawback of this sequence is that at the end, the user has to wait for our site to load, and without some work, they won’t be taken to the exact page and scroll position they were at before. A good alternative is to open a popup (or a new tab on mobile) where the user can do the GitHub steps. When they’re done authorizing, the popup closes and returns the signed token to the app. Then we’ll include that token in our requests to the server so the server will know who the user is.

Let’s think about what UI elements we want related to the login and the user. We can put a login link on the right side of the header, which will open the GitHub popup. Once the user is logged in, we can show their GitHub profile photo and name in place of the login link, and if they click their name, we can take them to a new `/me` route that shows them their profile. For all of this, we’ll need some data and functions—the user data, whether the user data is loading, and login and logout functions. We need it in a couple of different places in the app—in the header and in a route. There are a few different ways to get information to any place in the app—one is to render an `<AppContainer>` instead of `<App>` in `index.js`:

```js
render(
  <BrowserRouter>
    <ApolloProvider client={client}>
      <AppContainer />
    </ApolloProvider>
  </BrowserRouter>,
  document.getElementById('root')
)
```

And then the `<AppContainer>` fetches the current user object from the server and passes it to `<App>` along with login/logout functions and a `loggingIn` prop that indicates whether the app is in the process of logging the user in:

```js
const AppContainer = () => {
  ...

  return (
    <App
      user={user}
      login={this.login}
      logout={this.logout}
      loggingIn={loading}
    />
  )
}
```

Then `<App>` in turn passes the props down the component tree to children and grandchildren who need them. The main benefit to this method is that it’s easy to test, because it’s simple to mock out props. However, in all but the smallest apps, it results in a lot of *prop drilling* (passing props down to a component’s children’s children’s ... children). That can get tiresome and clutter our JSX. Instead, let’s export `login()` and `logout()` from a helper file and create a custom hook that provides `user` and `loggingIn`. Then, inside components that deal with the user, we can import and use `login()`, `logout()`, and `useUser()`.

Let’s add the current user’s name and photo to our header, and let’s add a route for a profile page:

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/blob/7_0.2.0/src/components/App.js)

```js
import { Link } from 'react-router-dom'

import CurrentUser from './CurrentUser'
import Profile from './Profile'

export default () => (
  <div className="App">
    <header className="App-header">
      <StarCount />
      <Link className="App-home-link" to="/">
        <img src={logo} className="App-logo" alt="logo" />
        <h1 className="App-title">The GraphQL Guide</h1>
      </Link>
      <CurrentUser />
    </header>
    <Switch>
      <Route exact path="/" render={() => <Redirect to="/Preface" />} />
      <Route exact path="/me" component={Profile} />
      <Route component={Book} />
    </Switch>
  </div>
)
```

We call the header component `<CurrentUser>` because that’s what it will usually be displaying (it will sometimes instead have a "Sign in" button or a spinner). We need a way for the user to navigate from `/me` to the rest of the app, so we wrap the header image and title in a `<Link>` to the root `/`. Later we’ll get to the hook (`lib/useUser.js`) and the login/logout functions (`lib/auth.js`), but, for now, let’s assume they work and write `<CurrentUser>`:

[`src/components/CurrentUser.js`](https://github.com/GraphQLGuide/guide/blob/7_0.2.0/src/components/CurrentUser.js)

```js
import React from 'react'
import { Link } from 'react-router-dom'

import { useUser } from '../lib/useUser'
import { login } from '../lib/auth'

export default () => {
  const { user, loggingIn } = useUser()

  let content

  if (loggingIn) {
    content = <div className="Spinner" />
  } else if (!user) {
    content = <button onClick={login}>Sign in</button>
  } else {
    content = (
      <Link to="/me" className="User">
        <img src={user.photo} alt={user.firstName} />
        {user.firstName}
      </Link>
    )
  }

  return <div className="CurrentUser">{content}</div>
}
```

This one is straightforward to read. If there’s no user and the user isn’t being loaded, then we have a “Sign in” button that calls `login()`.

Similarly, in `<Profile>`, we might show a loading spinner or a login button. Otherwise, we show the user’s details and a “Sign out” button:

[`src/components/Profile.js`](https://github.com/GraphQLGuide/guide/blob/7_0.2.0/src/components/Profile.js)

```js
import React from 'react'

import { useUser } from '../lib/useUser'
import { login, logout } from '../lib/auth'

export default () => {
  const { user, loggingIn } = useUser()

  if (loggingIn) {
    return (
      <main className="Profile">
        <div className="Spinner" />
      </main>
    )
  } else if (!user) {
    return (
      <main className="Profile">
        <button onClick={login} className="Profile-login">
          Sign in
        </button>
      </main>
    )
  } else {
    return (
      <main className="Profile">
        <div className="Profile-header-wrapper">
          <header className="Profile-header">
            <h1>{user.name}</h1>
          </header>
        </div>
        <div className="Profile-content">
          <dl>
            <dt>Email</dt>
            <dd>
              <code>{user.email}</code>
            </dd>

            <dt>Membership level</dt>
            <dd>
              <code>{user.hasPurchased || 'GUEST'}</code>
            </dd>

            <dt>OAuth Github account</dt>
            <dd>
              <a
                href="https://github.com/settings/applications"
                target="_blank"
                rel="noopener noreferrer"
              >
                <code>{user.username}</code>
              </a>
            </dd>
          </dl>

          <button className="Profile-logout" onClick={logout}>
            Sign out
          </button>
        </div>
      </main>
    )
  }
}
```

And now to write our authentication logic! First, we need to set up the Auth0 client:

[`src/lib/auth.js`](https://github.com/GraphQLGuide/guide/blob/7_0.2.0/src/lib/auth.js)

```js
import auth0 from 'auth0-js'
import {
  initAuthHelpers,
  login as auth0Login,
  logout as auth0Logout,
} from 'auth0-helpers'

const client = new auth0.WebAuth({
  domain: 'graphql.auth0.com',
  clientID: '8fErnZoF3hbzQ2AbMYu5xcS0aVNzQ0PC',
  responseType: 'token',
  audience: 'https://api.graphql.guide',
  scope: 'openid profile guide',
})

initAuthHelpers({
  client,
  usePopup: true,
  authOptions: {
    connection: 'github',
    owp: true,
    popupOptions: { height: 623 }, // make tall enough for content
  },
  checkSessionOptions: {
    redirect_uri: window.location.origin,
  },
  onError: (e) => console.error(e),
})
```

Here we’re just following the docs for [`auth0-js`](https://www.npmjs.com/package/auth0-js) and [`auth0-helpers`](https://www.npmjs.com/package/auth0-helpers). Now `auth0Login()` and `auth0Logout()` should be configured to work with the Guide’s Auth0 account system, and we can use them:

[`src/lib/auth.js`](https://github.com/GraphQLGuide/guide/blob/7_0.2.0/src/lib/auth.js)

```js
export const login = () => {
  auth0Login({
    onCompleted: (e) => {
      if (e) {
        console.error(e)
        return
      }
    },
  })
}

export const logout = () => {
  auth0Logout()
}
```

You might be wondering, "But what do the login and logout functions actually do?" `auth0Login()` opens the GitHub auth popup, and saves the resulting token in localStorage. `auth0Logout()` removes the token from localStorage and ends our session with the Auth0 server. The next step is actually using the token—whenever we communicate with the server, we need to provide it. There’s an Apollo Link called [`setContext`](https://www.apollographql.com/docs/link/links/context/) that lets us set headers on HTTP requests, and we’ll use it to add an `authorization` header with the token. While we’re at it, let’s move our Apollo client creation out to another file:

[`src/index.js`](https://github.com/GraphQLGuide/guide/blob/7_0.2.0/src/index.js)

```js
import { apollo } from './lib/apollo'

render(
  <BrowserRouter>
    <ApolloProvider client={apollo}>
      <App />
    </ApolloProvider>
  </BrowserRouter>,
  document.getElementById('root')
)
```

[`src/lib/apollo.js`](https://github.com/GraphQLGuide/guide/blob/7_0.2.0/src/lib/apollo.js)

```js
import { ApolloClient, InMemoryCache, HttpLink, split } from '@apollo/client'
import { WebSocketLink } from '@apollo/client/link/ws'
import { setContext } from '@apollo/client/link/context'
import { getMainDefinition } from '@apollo/client/utilities'
import { getAuthToken } from 'auth0-helpers'

const httpLink = new HttpLink({
  uri: 'https://api.graphql.guide/graphql',
})

const authLink = setContext(async (_, { headers }) => {
  const token = await getAuthToken({
    doLoginIfTokenExpired: true,
  })

  if (token) {
    return {
      headers: {
        ...headers,
        authorization: `Bearer ${token}`,
      },
    }
  } else {
    return { headers }
  }
})

const authedHttpLink = authLink.concat(httpLink)

const wsLink = new WebSocketLink({
  uri: `wss://api.graphql.guide/subscriptions`,
  options: {
    reconnect: true,
  },
})

const link = split(
  ({ query }) => {
    const { kind, operation } = getMainDefinition(query)
    return kind === 'OperationDefinition' && operation === 'subscription'
  },
  wsLink,
  authedHttpLink
)

const cache = new InMemoryCache()

export const apollo = new ApolloClient({ link, cache })
```

We get the token from `auth0-helpers` using `getAuthToken()`, which either looks it up in localStorage, or if it has expired, opens the GitHub auth popup again. We use [`concat()`](https://www.apollographql.com/docs/link/composition.html#additive) to combine our new `authLink` with the `httpLink`—now when our Apollo client sends out a new query or mutation, it will first go through `authLink`, which will set the header, and then through `httpLink`, which will put it in an HTTP request and send it to the server.

The last piece is to make an HOC that provides the current user’s data:

[`src/lib/useUser.js`](https://github.com/GraphQLGuide/guide/blob/7_0.2.0/src/lib/useUser.js)

```js
import { gql, useQuery } from '@apollo/client'

export const USER_QUERY = gql`
  query UserQuery {
    currentUser {
      id
      firstName
      name
      username
      email
      photo
      hasPurchased
    }
  }
`

export function useUser() {
  const { data, loading } = useQuery(USER_QUERY)

  return {
    user: data && data.currentUser,
    loggingIn: loading,
  }
}
```

We can now try logging in with our Github account. Clicking “Sign in” opens the popup, and after we go through the OAuth dialog, the popup closes. But then nothing else happens. The “Sign in” link is still there, which means `useUser()` is still providing `user: null` to `<CurrentUser>`. If we reload, it’ll show us logged in, but we don’t want to have to reload, of course. This issue will be solved in the next section.

## Resetting

> If you’re jumping in here, `git checkout 7_0.2.0` (tag [`7_0.2.0`](https://github.com/GraphQLGuide/guide/tree/7_0.2.0)). Tag [`8_0.2.0`](https://github.com/GraphQLGuide/guide/tree/8_0.2.0) contains all the code written in this section.

Because the auth token is included in every request, the server will know who we are for any other queries and mutations we send, like the ones for the section content. So our server should recognize that we have purchased a Guide package and return the full content to the sections that are included in our package. But after we log in, the section content is still cut off like it was before. Why is that? Because the section content queries haven’t been refetched! We’re still showing the old data fetched when we were logged out. Now what do we do?

Apollo does have a [refetch()](https://www.apollographql.com/docs/react/api/react/hooks/#result) function that we get along with a query’s results. It would be a pain to use on our section queries because: A) there are 3 of them, and B) we’d have to figure out how to call the `refetch()` functions (which would be inside `Section.js`) from `auth.js`. So let’s take a different path—telling Apollo to refetch all the queries in the app. Apollo has a `reFetchObservableQueries()` function, which takes all the *observable queries* (queries used in a `useQuery()` hook) and re-sends them to the server. Let’s call that:

[`src/lib/auth.js`](https://github.com/GraphQLGuide/guide/blob/8_0.2.0/src/lib/auth.js)

```js
import { apollo } from './apollo'

export const login = () => {
  auth0Login({
    onCompleted: e => {
      if (e) {
        console.error(e)
        return
      }

      apollo.reFetchObservableQueries()
    },
  })
}
```

Now we’ve got login working. But let’s take a minute to think about query efficiency. We have `useUser()` in two components right now, and when we load `/me`, they’re both on the page. But if we look in our network tab, we only see `UserQuery` sent to the server once! This is an example of Apollo’s automatic [query deduplication](https://www.apollographql.com/docs/link/links/dedup/#context)—when we ask it to make the same query twice, it’s smart enough to only send it once and give the result to both components. However, whenever we render new components that use `useUser()` (for instance, when we navigate from `/Preface` to `/me`), it’s treated as a separate query and not deduplicated. But we don’t need to re-send it to the server—the user’s name, photo, etc. isn’t likely to change. Luckily, the query isn’t re-sent to the server! The default [fetchPolicy](https://www.apollographql.com/docs/react/data/queries/#configuring-fetch-logic) for queries is `cache-first`, which means if the query result is already in the cache, Apollo loads the data from the cache. If we were dealing with a type of data that was more likely to change, we could set the `fetchPolicy` to `cache-and-network`, which first loads data from the cache, but at the same time sends the query to the server, and will update the component if the server result is different from the cache result. We would set `fetchPolicy` like this:

```js
const { data, loading } = useQuery(USER_QUERY, {
  fetchPolicy: 'cache-and-network',
})
```

Our queries update on login, but what about logout? There may be private data in the cache, so the method we want is [`resetStore()`](https://www.apollographql.com/docs/react/api/apollo-client.html#ApolloClient.resetStore), which first clears the cache (a.k.a. store) and then refetches observable queries:

[`src/lib/auth.js`](https://github.com/GraphQLGuide/guide/blob/8_0.2.0/src/lib/auth.js)

```js
export const logout = () => {
  auth0Logout()
  apollo.resetStore()
}
```

Now when we log in and out, the full section content should appear and disappear. 

> If we knew what the private data was, we could alternatively delete only that data. For instance if the only private data was under `Query.currentUser`, we could do:

```js
export const logout = () => {
  auth0Logout()
  apollo.cache.evict({ fieldName: 'currentUser' })
  apollo.cache.gc()
}
```

# Mutating

Section contents:

* [First mutation](6.md#first-mutation)
* [Listing reviews](6.md#listing-reviews)
* [Optimistic updates](6.md#optimistic-updates)
* [Arbitrary updates](6.md#arbitrary-updates)
* [Creating reviews](6.md#creating-reviews)
* [Using fragments](6.md#using-fragments)
* [Deleting](6.md#deleting)
* [Error handling](6.md#error-handling)
* [Editing reviews](6.md#editing-reviews)

## First mutation

> If you’re jumping in here, `git checkout 8_0.2.0` (tag [`8_0.2.0`](https://github.com/GraphQLGuide/guide/tree/8_0.2.0)). Tag [`9_0.2.0`](https://github.com/GraphQLGuide/guide/tree/9_0.2.0) contains all the code written in this section.

We haven’t yet changed any of the data in the Guide’s database (just the star count in GitHub’s database). When we want to change data (or more broadly, trigger side effects), we need to send a mutation to the server. Let’s start with something simple—at the bottom of `<Section>`, let’s add the count of how many times the current section has been viewed. Then we can increment the count whenever it’s viewed.

First we add the `views` field to each of our three section queries:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/9_0.2.0/src/components/Section.js)

```js
const SECTION_BY_ID_QUERY = gql`
  query SectionContent($id: String!) {
    section(id: $id) {
      id
      content
      views
    }
  }
`

const SECTION_BY_CHAPTER_TITLE_QUERY = gql`
  query SectionByChapterTitle($title: String!) {
    chapterByTitle(title: $title) {
      title
      section(number: 1) {
        id
        content
        views
      }
    }
  }
`

const SECTION_BY_NUMBER_QUERY = gql`
  query SectionByNumber($chapterNumber: Int!, $sectionNumber: Int!) {
    chapterByNumber(number: $chapterNumber) {
      number
      section(number: $sectionNumber) {
        id
        number
        title
        content
        views
      }
    }
  }
`
```

In addition to `views`, we have to add `id` to the query’s selection set so that the `Section` gets [normalized](5.md#caching) correctly. 

For the first query, we also need to add `views: get(data, 'section.views')` to `section`:

```js
  switch (query) {
    case SECTION_BY_ID_QUERY:
      section = {
        ...state.section,
        content: get(data, 'section.content'),
        views: get(data, 'section.views'),
      }
      chapter = state.chapter
      break
```

Next we display the new data:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/9_0.2.0/src/components/Section.js)

```js
  let headerContent = null,
    sectionContent = null,
    footerContent = null

  if (loading) {
    ...
  } else if (!section) {
    ...
  } else {
    ...

    sectionContent = section.content
    footerContent = `Viewed ${section.views.toLocaleString()} times`
  }

  return (
    <section className="Section">
      ...
      <footer>{footerContent}</footer>
    </section>
  )
```

![Section views](/img/section-views.png)

Now look for the mutation we need in Playground—we need the name, arguments, and return type.

![viewedSection selected among list of available mutations](/img/viewedSection-schema.png)

And we write out the mutation string just like we write queries:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/9_0.2.0/src/components/Section.js)

```js
const VIEWED_SECTION_MUTATION = gql`
  mutation ViewedSection($id: String!) {
    viewedSection(id: $id) {
      id
      views
    }
  }
`
```

Like in the queries, we need the `id` field so that Apollo knows which `Section` is being returned in the mutation response. Now the response’s `views` field will update the normalized `Section` object in the Apollo cache, which will update any hook queries that select that field. We’ll be able to see this in action in a bit.

The mutation hook is simple:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/9_0.2.0/src/components/Section.js)

```js
import { useMutation } from '@apollo/client'

...

  const [viewedSection] = useMutation(VIEWED_SECTION_MUTATION)
```

`useMutation()` returns a function, which we’re naming `viewedSection`. We want to call it whenever a section is viewed, so inside a `useEffect()` hook:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/9_0.2.0/src/components/Section.js)

```js
export default () => {
  ...

  let section, chapter

  switch(query) { ... }

  const [viewedSection] = useMutation(VIEWED_SECTION_MUTATION)

  const id = get(section, 'id')

  useEffect(() => {
    const timeoutID = setTimeout(() => {
      viewedSection({ variables: { id } })
    }, 2000)

    return () => clearTimeout(timeoutID)
  }, [id, viewedSection])

  ...
}
```

We give `viewedSection()` the section ID variable. We put it in a timeout so that we have time to scroll down to the bottom of the section to see the count change (End key or Cmd-⬇️ on Mac). We add `id` as a dependency so that whenever it changes, `viewSection()` is called again.

We should now be able to see the count change at the bottom of the page when we switch between sections.

## Listing reviews

> If you’re jumping in here, `git checkout 9_0.2.0` (tag [`9_0.2.0`](https://github.com/GraphQLGuide/guide/tree/9_0.2.0)). Tag [`10_0.2.0`](https://github.com/GraphQLGuide/guide/tree/10_0.2.0) contains all the code written in this section.

Before we get to more advanced mutations, we need more material to work with! Let’s make a new page that lists book reviews, and then in the [next section](#optimistic-updates), we can implement features that require mutations: favoriting reviews, creating new reviews, and editing and deleting our own reviews.

Let’s start out by adding a link to the bottom of the table of contents:

[`src/components/TableOfContents.js`](https://github.com/GraphQLGuide/guide/blob/10_0.2.0/src/components/TableOfContents.js)

```js
export default () => {
  const { data: { chapters } = {}, loading } = useQuery(CHAPTER_QUERY)

  return (
    <nav className="TableOfContents">
      ...
          <li>
            <NavLink className="TableOfContents-reviews-link" to="/reviews">
              Reviews
            </NavLink>
          </li>
        </ul>
      )}
    </nav>
  )
}
```

And we can add the new route with another `<Switch>`:

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/blob/10_0.2.0/src/components/App.js)

```js
import Reviews from './Reviews'

const Book = () => (
  <div>
    <TableOfContents />
    <Switch>
      <Route exact path="/reviews" component={Reviews} />
      <Route component={Section} />
    </Switch>
  </div>
)
```

Our `<Reviews>` component is going to need some data! We know how to do that now. Let’s search through the schema for the right query:

![Schema: reviews](/img/schema-reviews.png)

We find the `reviews` root query field, and since fetching them all might be a lot of data, let’s use the `limit` argument. And for each review, we want to display the author’s name, photo, and a link to their GitHub, so we need:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/blob/10_0.2.0/src/components/Reviews.js)

```js
const REVIEWS_QUERY = gql`
  query ReviewsQuery {
    reviews(limit: 20) {
      id
      text
      stars
      createdAt
      favorited
      author {
        id
        name
        photo
        username
      }
    }
  }
`
```

As before, we will use `useQuery()` to get `reviews` and `loading`, and it should have a similar structure to `<Section>`:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/blob/10_0.2.0/src/components/Reviews.js)

```js
import React from 'react'
import { gql, useQuery } from '@apollo/client'

import Review from './Review'

const REVIEWS_QUERY = ...

export default () => {
  const { data: { reviews } = {}, loading } = useQuery(REVIEWS_QUERY)

  return (
    <main className="Reviews mui-fixed">
      <div className="Reviews-header-wrapper">
        <header className="Reviews-header">
          <h1>Reviews</h1>
        </header>
      </div>
      <div className="Reviews-content">
        {loading ? (
          <div className="Spinner" />
        ) : (
          reviews.map((review) => <Review key={review.id} review={review} />)
        )}
      </div>
    </main>
  )
}
```

Next up is the `<Review>` component. So far we’ve mostly been using plain HTML tags and CSS classes for styling. For many components of an app, it’s easier to use a library instead of building and styling them ourselves. One of the most popular React component libraries is [Material-UI](http://www.material-ui.com/), based on Google’s [design system](https://material.io/guidelines/material-design/introduction.html). 

> Here are some of the other [major React component libraries](https://blog.bitsrc.io/11-react-component-libraries-you-should-know-178eb1dd6aa4).

We can explore their component demos to find components we want to use to make up a `<Review>`, and we can browse the [material icons listing](https://material.io/icons/). Let’s put each review on a [Card](https://material-ui.com/demos/cards/), with an [Avatar](https://material-ui.com/demos/avatars/) for the author’s photo, a [MoreVert](https://material.io/tools/icons/?icon=more_vert&style=baseline) and [Menu](https://material-ui.com/demos/menus/) for editing and deleting, and a more prominent [FavoriteBorder](https://material.io/tools/icons/?icon=favorite_border&style=baseline) as a bottom action:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/blob/10_0.2.0/src/components/Reviews.js)

```js
import React, { useState } from 'react'
import {
  Card,
  CardHeader,
  CardContent,
  CardActions,
  IconButton,
  Typography,
  Avatar,
  Menu,
  MenuItem,
} from '@material-ui/core'
import {
  MoreVert,
  Favorite,
  FavoriteBorder,
  Star,
  StarBorder,
} from '@material-ui/icons'
import formatDistanceToNow from 'date-fns/formatDistanceToNow'
import times from 'lodash/times'

const FavoriteButton = ({ favorited }) => {
  function toggleFavorite() {}

  return (
    <IconButton onClick={toggleFavorite}>
      {favorited ? <Favorite /> : <FavoriteBorder />}
    </IconButton>
  )
}

const StarRating = ({ rating }) => (
  <div>
    {times(rating, (i) => (
      <Star key={i} />
    ))}
    {times(5 - rating, (i) => (
      <StarBorder key={i} />
    ))}
  </div>
)

export default ({ review }) => {
  const { text, stars, createdAt, favorited, author } = review

  const [anchorEl, setAnchorEl] = useState()

  function openMenu(event) {
    setAnchorEl(event.currentTarget)
  }

  function closeMenu() {
    setAnchorEl(null)
  }

  function editReview() {
    closeMenu()
  }

  function deleteReview() {
    closeMenu()
  }

  function toggleFavorite() {}

  const LinkToProfile = ({ children }) => (
    <a
      href={`https://github.com/${author.username}`}
      target="_blank"
      rel="noopener noreferrer"
    >
      {children}
    </a>
  )

  return (
    <div>
      <Card className="Review">
        <CardHeader
          avatar={
            <LinkToProfile>
              <Avatar alt={author.name} src={author.photo} />
            </LinkToProfile>
          }
          action={
            <IconButton onClick={openMenu}>
              <MoreVert />
            </IconButton>
          }
          title={<LinkToProfile>{author.name}</LinkToProfile>}
          subheader={stars && <StarRating rating={stars} />}
        />
        <CardContent>
          <Typography component="p">{text}</Typography>
        </CardContent>
        <CardActions>
          <Typography className="Review-created">
            {formatDistanceToNow(createdAt)} ago
          </Typography>
          <div className="Review-spacer" />
          <FavoriteButton {...review} />
        </CardActions>
      </Card>
      <Menu anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={closeMenu}>
        <MenuItem onClick={editReview}>Edit</MenuItem>
        <MenuItem onClick={deleteReview}>Delete</MenuItem>
      </Menu>
    </div>
  )
}
```

The `MoreVert` button controls whether the `Menu` is open and where it is placed (or "anchored").

We should now see a list of the 20 most recent reviews! 💃

## Optimistic updates

> If you’re jumping in here, `git checkout 10_0.2.0` (tag [`10_0.2.0`](https://github.com/GraphQLGuide/guide/tree/10_0.2.0)). Tag [`11_0.2.0`](https://github.com/GraphQLGuide/guide/tree/11_0.2.0) contains all the code written in this section.

Optimistic UI is when the client acts as if a user action has immediate effect instead of waiting for a response from the server. For example, normally if the user adds a comment to a blog post, the client sends the mutation to the server, and when the server responds with the new comment, the client adds it to the cache, which updates the comment query results, which re-renders the page. Optimistic UI is when the client sends the mutation to the server and updates the cache at the same time, not waiting for a response—*optimistically* assuming that the comment will be successfully saved to the database.

Let’s write a simple example of an optimistic update for favoriting or unfavoriting a review. We can find in the [Playground](https://api.graphql.guide/play) a mutation called `favoriteReview` which takes the review ID and whether the user is favoriting or unfavoriting. First we write the mutation and add it to our component with `useMutation()`:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/blob/11_0.2.0/src/components/Review.js)

```js
import { gql, useMutation } from '@apollo/client'

const FAVORITE_REVIEW_MUTATION = gql`
  mutation FavoriteReview($id: ObjID!, $favorite: Boolean!) {
    favoriteReview(id: $id, favorite: $favorite) {
      favorited
    }
  }
`

const FavoriteButton = ({ id, favorited }) => {
  const [favorite] = useMutation(FAVORITE_REVIEW_MUTATION)

  function toggleFavorite() {
    favorite({
      variables: { id, favorite: !favorited },
    })
  }

  return (
    <IconButton onClick={toggleFavorite}>
      {favorited ? <Favorite /> : <FavoriteBorder />}
    </IconButton>
  )
}
```

Now when we click a review’s heart outline icon, it should change to the filled-in icon... right? 😁 But nothing’s happening. Let’s investigate with [Apollo devtools](5.md#devtools). We can open it on our page to the Mutations section. Then when we click a favorite button, `FavoriteReview` shows up in the Mutation log. So we know the mutation is getting called. And when we click on the log entry, we can see that the argument variables are given correctly:

![Favorite mutation in the log](/img/favorite-mutation.png)

So maybe the issue is with the server’s response? Let’s look at that in the Network tab. In the Name section on the left, scroll down to the bottom, and when we click the favorite button again, a new entry should appear. When we click on that, we should see the Headers tab, which at the top says it was an HTTP POST to `https://api.graphql.guide/graphql` (which is the case for all of our GraphQL queries and mutations). It also says the response status code was "200 OK", so we know the server responded without an error. If we scroll to the bottom, we’ll see the Request Payload, which has `operationName: FavoriteReview` and the correct mutation string and variables. Now if we switch to the Response tab, we see:

`{"data":{"favoriteReview":{"favorited":true,"__typename":"Review"}}}`

The server is giving us the correct response, so it looks like the mutation did succeed. Let’s try reloading the page. Now we see that the review did get favorited. Why was the UI not updating? 

We forgot to include `id` in the response selection set, so Apollo didn’t know which part of the cache to update with `favorited: true`. When we add `id`, it works:

```js
const FAVORITE_REVIEW_MUTATION = gql`
  mutation FavoriteReview($id: ObjID!, $favorite: Boolean!) {
    favoriteReview(id: $id, favorite: $favorite) {
      id
      favorited
    }
  }
`
```

![Delayed favoriting](/img/delayed-favoriting.gif)
[*gif: Delayed favoriting*](http://res.cloudinary.com/graphql/guide/delayed-favoriting.gif)

While it works now, we can probably notice a delay between when we click the heart and when it changes. If we don’t, we can switch from "Online" to "Fast 3G" in the dropdown on the far right top of the Network tab in Chrome devtools (which simulates the higher latency of mobile networks), and we’ll notice a two-second delay before the icon changes. Users of our app who are on mobile or on computers far away from our servers notice the delay. Let’s improve their experience by updating the icon immediately. (In reality, it will take some milliseconds to run the Apollo and React code and paint a new screen, but the delay should be imperceptible.)

We can provide an [`optimisticResponse`](https://www.apollographql.com/docs/react/api/react/hooks/#options-2) to our `favorite()` mutation:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/blob/11_0.2.0/src/components/Review.js)

```js
  function toggleFavorite() {
    favorite({
      variables: { id, favorite: !favorited },
      optimisticResponse: {
        favoriteReview: {
          __typename: 'Review',
          id,
          favorited: !favorited,
        },
      },
    })
  }
```

`__typename` is an automatically provided field for the type being returned. We’re mimicking the response from the server, which we saw had `"__typename":"Review"`:

``{"data":{"favoriteReview":{"favorited":true,"__typename":"Review"}}}``

The type name, along with the `id`, will allow Apollo to figure out which review object in the cache to update with the new `favorited` value. Now we see that the icon updates right away, even when we set the network speed to fast or slow 3G.

![Optimistic favoriting](/img/optimistic-favoriting.gif)
[*gif: Optimistic favoriting*](http://res.cloudinary.com/graphql/guide/optimistic-favoriting.gif)

In the next section, we’ll implement a more flexible and complex form of optimistic updating.

## Arbitrary updates

> If you’re jumping in here, `git checkout 11_0.2.0` (tag [`11_0.2.0`](https://github.com/GraphQLGuide/guide/tree/11_0.2.0)). Tag [`12_0.2.0`](https://github.com/GraphQLGuide/guide/tree/12_0.2.0) contains all the code written in this section.

In the previous section ([Optimistic updating](#optimistic-updating)), we changed the Apollo cache using the mutation’s `optimisticResponse` option. But that method only let us set the mutation response—an object of type `Review`. Sometimes we need to update different parts of the cache. For our next piece of UI, we’ll need to update the `User` object, and we’ll do so with some new functions—[cache.readQuery()](https://www.apollographql.com/docs/react/caching/cache-interaction/#readquery) and [cache.writeQuery()](https://www.apollographql.com/docs/react/caching/cache-interaction/#writequery-and-writefragment).

In the header of the Reviews page, let’s add the total count of favorited reviews:

![Review count](/img/review-count.png)

First we need to think about how to get the count. We can’t just count how many reviews in the cache have `favorited: true`, because we only have the most recent 20. And fetching all the reviews from the server would be a lot of data on the wire, a lot of memory taken up on the client, and a long list to count through. Instead let’s fetch the current user’s `favoriteReviews` field. When we want to know more about the current user, we need to go back to our `useUser()` hook and add the field to our `USER_QUERY`:

[`src/lib/useUser.js`](https://github.com/GraphQLGuide/guide/blob/12_0.2.0/src/lib/useUser.js)

```js
const USER_QUERY = gql`
  query UserQuery {
    currentUser {
      ...
      favoriteReviews {
        id
      }
    }
  }
```

Since we’re just counting the length, we don’t need many `favoriteReviews` sub-fields—just the `id`. We add the hook to `<Reviews>` to the get the `user`, and then we get the length of the `user.favoriteReviews` array to display as the count:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/blob/12_0.2.0/src/components/Reviews.js)

```js
import { gql, useQuery } from '@apollo/client'
import get from 'lodash/get'
import { Favorite } from '@material-ui/icons'

import { useUser } from '../lib/useUser'

export default () => {
  const { data: { reviews } = {}, loading } = useQuery(REVIEWS_QUERY)

  const { user } = useUser()
  const favoriteCount = get(user, 'favoriteReviews.length')

  return (
    <main className="Reviews mui-fixed">
      <div className="Reviews-header-wrapper">
        <header className="Reviews-header">
          {favoriteCount ? (
            <div className="Reviews-favorite-count">
              <Favorite />
              {favoriteCount}
            </div>
          )}
          <h1>Reviews</h1>
        </header>
    ...
  )
}
```

Now if we have a non-zero favorite count, we should see it in the Reviews header. However, when we favorite reviews, the count doesn’t go up as it should. We have to reload the page in order to get the count displayed accurately again. From this we know that when we favorite, the user’s `favoriteReviews` list is getting updated on the server, but not on the client. In order to update it on the client, we add another option to our `useMutation()` hook: [`update`](https://www.apollographql.com/docs/react/api/react/hooks/#options-2).

```js
const READ_USER_FAVORITES = gql`
  query ReadUserFavorites {
    currentUser {
      id
      favoriteReviews {
        id
      }
    }
  }
`

const FavoriteButton = ({ id, favorited }) => {
  const [favorite] = useMutation(FAVORITE_REVIEW_MUTATION, {
    update: (cache, { data: { favoriteReview } }) => {
      const { currentUser } = cache.readQuery({ query: READ_USER_FAVORITES })
      let newUser

      if (favoriteReview.favorited) {
        newUser = {
          ...currentUser,
          favoriteReviews: [
            ...currentUser.favoriteReviews,
            { id, __typename: 'Review' },
          ],
        }
      } else {
        newUser = {
          ...currentUser,
          favoriteReviews: currentUser.favoriteReviews.filter(
            (review) => review.id !== id
          ),
        }
      }

      cache.writeQuery({
        query: READ_USER_FAVORITES,
        data: { currentUser: newUser },
      })
    },
  })

  function toggleFavorite() { ... }

  return (
    <IconButton onClick={toggleFavorite}>
      {favorited ? <Favorite /> : <FavoriteBorder />}
    </IconButton>
  )
}
```

The `update()` function is used to update the cache after a mutation. It is given as arguments the `cache` and the result of the mutation. Because we’re providing an `optimisticResponse`, `update()` will be called twice: once with the `optimisticResponse`, and once with the response from the server. We can use the `cache` to read and write data from and to the cache. To read data, we write a query for the data we want to change (in this case `currentUser.favoriteReviews`). To differentiate between queries we send to the server and queries we write just for reading from the cache, we start the name with "Read": `ReadUserFavorites`. We give the query to [`cache.readQuery()`](https://www.apollographql.com/docs/react/caching/cache-interaction/#readquery), and we get back the data. Then we modify the data (either adding or removing a bare-bones `Review` object with an `id` and `__typename`—it doesn’t need to be a complete `Review` because we just want the count to update). Finally, we write the modified data back to the cache with [`cache.writeQuery()`](https://www.apollographql.com/docs/react/caching/cache-interaction/#writequery-and-writefragment). 

For example, if we read this from the cache:

```js
{
  currentUser: {
    __typename: 'User',
    favoriteReviews: [{
      __typename: 'Review',
      id: 'foo'
    }]
  }
}
```

and we favorited a review with ID `'bar'`, then we would write this data object back to the cache:

```js
{
  currentUser: {
    __typename: 'User',
    favoriteReviews: [{
      __typename: 'Review',
      id: 'foo'
    }, {
      __typename: 'Review',
      id: 'bar'
    }]
  }
}
```

Then Apollo would update `USER_QUERY`’s user prop, which would update the `user` in `<Reviews>`, which would find a new `user.favoriteReviews.length` value and display it. We can see that this process works in our app:

![Updating favorite count](/img/updating-favorite-count.gif)
[*gif: Updating favorite count*](http://res.cloudinary.com/graphql/guide/updating-favorite-count.gif) 

In our `update()` function, we create a `newUser` object because we can’t mutate the `currentUser` we read from the cache. If we try, for example with a `.push()`, we get an error like this:

```js
currentUser.favoriteReviews.push({ id, __typename: 'Review' }
```

```
index.js:1 TypeError: Cannot add property 1, object is not extensible
    at Array.push (<anonymous>)
    at update (Review.js:52)
    ...
```

In the [next section](#creating-reviews), we’ll write an `update()` function that adds an item to a list. We can also use `readQuery()` and `writeQuery()` outside of a mutation—we can use the [`useApolloClient()`](https://www.apollographql.com/docs/react/api/react/hooks/#useapolloclient) hook to get our client instance and then call [any client functions](https://www.apollographql.com/docs/react/api/core/ApolloClient/#apolloclient-functions), including `client.readQuery()` and `.writeQuery()`.

There are two more functions we can use—[`readFragment()`](https://www.apollographql.com/docs/react/api/core/ApolloClient/#ApolloClient.readFragment) and [`writeFragment()`](https://www.apollographql.com/docs/react/api/core/ApolloClient/#ApolloClient.writeFragment). `readQuery` can only read data from a root query type like `currentUser{ ... }` or `reviews(limit: 20){ ... }`. `readFragment` can read from any normalized object in our cache by its cache ID. 

A *cache ID* is the identifier Apollo uses to [normalize](5.md#caching) objects. [By default](https://www.apollographql.com/docs/react/caching/cache-configuration/#default-identifier-generation), it is `[__typename]:[id]`, for instance: `Review:5a6676ec094bf236e215f488`. We can see these IDs on the left of the Cache section in Apollo devtools:

![View of the cache in devtools](/img/devtools-cache.png)

On the left is the cache IDs of all objects in the cache. There are reviews with their random IDs, as well as sections with cache IDs like `Section:1-1`. We can read a section by its cache ID like this:

```js
import { useApolloClient } from '@apollo/client'

function MyComponent() {
  const client = useApolloClient()

  client.readFragment({
    id: 'Section:intro',
    fragment: gql`
      fragment exampleSection on Section {
        id
        views
        content
      }
    `
  })
}
```

The `readFragment()` arguments are the cache ID and a [fragment](2.md#fragments). It returns just that section:

```js
{
  content: "..."
  id: "intro"
  views: 67
  __typename: "Section"
  Symbol(id): "Section:intro"
}
```

Similarly, `writeFragment()` allows us to write to an object with a specific cache ID:

```js
client.writeFragment({
  id: 'Section:intro',
  fragment: gql`
    fragment sectionContent on Section {
      content
      __typename
    }
  `,
  data: {
    content: 'overwritten', 
    __typename: 'Section'
  }
})
```

If we ran this and then navigated to `/Introduction`, the section text would have changed to just the word "overwritten" 😅. Not to worry—we didn’t permanently overwrite a section of the book. It’s just changing the local client-side cache; when we reload, the actual Introduction text gets refetched from the server. We can try it out in the console, but first we have to (temporarily) add this line in any of our js files that imports `gql`:

```js
window.gql = gql
```

And then we replace `client` with `__APOLLO_CLIENT__`, which is a global variable available in development.

![Writing a fragment to the cache](/img/write-fragment.gif)
[*gif: Writing a fragment to the cache*](http://res.cloudinary.com/graphql/guide/write-fragment.gif)

## Creating reviews

> If you’re jumping in here, `git checkout 12_0.2.0` (tag [`12_0.2.0`](https://github.com/GraphQLGuide/guide/tree/12_0.2.0)). Tag [`13_0.2.0`](https://github.com/GraphQLGuide/guide/tree/13_0.2.0) contains all the code written in this section.

Adding the ability to create reviews will give us the opportunity to look at a more complex mutation and a different kind of `update()` function—we’ll be updating our list of reviews with a new review so that it shows up at the top of the Reviews page.

Let’s start out by adding a FAB ([floating action button](https://material-ui.com/demos/buttons/#floating-action-buttons)) that appears on the Reviews page when the user is logged in. The FAB will open a modal that has the form for a new review. Whether the modal is open is a state variable, so we need to convert `<Reviews>` from a function to a stateful component:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/blob/13_0.2.0/src/components/Review.js)

```js
import React, { useState } from 'react'
import { Favorite, Add } from '@material-ui/icons'
import { Fab, Modal } from '@material-ui/core'

import AddReview from './AddReview'

export default () => {
  const [addingReview, setAddingReview] = useState(false)

  const { data: { reviews } = {}, loading } = useQuery(REVIEWS_QUERY)

  const { user } = useUser()
  const favoriteCount = get(user, 'favoriteReviews.length')

  return (
    ...

        {user && (
          <div>
            <Fab
              onClick={() => setAddingReview(true)}
              color="primary"
              className="Reviews-add"
            >
              <Add />
            </Fab>

            <Modal open={addingReview} onClose={() => setAddingReview(false)}>
              <AddReview done={() => setAddingReview(false)} />
            </Modal>
          </div>
        )}
      </div>
    </main>
  )
}
```

`<AddReview>` will need a way to let us know it’s done (so we can close the modal), so we add a `done` prop. To set a primary color for the FAB that matches the rest of the site, we need a Material UI [theme](https://material-ui.com/customization/themes/). We can see from the [default theme](https://material-ui.com/customization/default-theme/) that `palette.primary.main` is the name of the value to change:

[`src/index.js`](https://github.com/GraphQLGuide/guide/blob/13_0.2.0/src/index.js)

```js
import { MuiThemeProvider, createMuiTheme } from '@material-ui/core/styles'

const GRAPHQL_PINK = '#e10098'

const theme = createMuiTheme({
  palette: { primary: { main: GRAPHQL_PINK } },
  typography: { useNextVariants: true },
})

render(
  <BrowserRouter>
    <ApolloProvider client={client}>
      <MuiThemeProvider theme={theme}>
        <App />
      </MuiThemeProvider>
    </ApolloProvider>
  </BrowserRouter>,
  document.getElementById('root')
)
```

Next up is the `<AddReview>` form:

[`src/components/AddReview.js`](https://github.com/GraphQLGuide/guide/blob/13_0.2.0/src/components/AddReview.js)

```js
import React, { useState } from 'react'
import StarInput from 'react-star-rating-component'
import { Button, TextField } from '@material-ui/core'
import { Star, StarBorder } from '@material-ui/icons'
import pick from 'lodash/pick'

import { validateReview } from '../lib/validators'

const GREY = '#0000008a'

export default ({ done }) => {
  const [text, setText] = useState(),
    [stars, setStars] = useState(),
    [errorText, setErrorText] = useState()

  function handleSubmit(event) {
    event.preventDefault()

    const errors = validateReview({ text, stars })
    if (errors.text) {
      setErrorText(errors.text)
      return
    }

    // TODO send mutation

    done()
  }

  return (
    <form className="AddReview" autoComplete="off" onSubmit={handleSubmit}>
      <TextField
        className="AddReview-text"
        label="Review text"
        value={text}
        onChange={(e) => setText(e.target.value)}
        helperText={errorText}
        error={!!errorText}
        multiline
        rowsMax="10"
        margin="normal"
        autoFocus={true}
      />

      <StarInput
        className="AddReview-stars"
        starCount={5}
        editing={true}
        value={stars}
        onStarClick={(newStars) => setStars(newStars)}
        renderStarIcon={(currentStar, rating) =>
          currentStar > rating ? <StarBorder /> : <Star />
        }
        starColor={GREY}
        emptyStarColor={GREY}
        name="stars"
      />

      <div className="AddReview-actions">
        <Button className="AddReview-cancel" onClick={done}>
          Cancel
        </Button>

        <Button type="submit" color="primary" className="AddReview-submit">
          Add review
        </Button>
      </div>
    </form>
  )
}
```

Before we mutate, we need to validate the form input and show the error message, if any. We’ll use the [revalidate](http://revalidate.jeremyfairbank.com/) library:

[`src/lib/validators.js`](https://github.com/GraphQLGuide/guide/blob/13_0.2.0/src/lib/validators.js)

```js
import {
  createValidator,
  composeValidators,
  combineValidators,
  isRequired,
  hasLengthLessThan,
} from 'revalidate'

const isString = createValidator(
  (message) => (value) => {
    if (!(typeof value === 'string')) {
      return message
    }
  },
  (field) => `${field} must be a String`
)

export const validateReview = combineValidators({
  text: composeValidators(
    isRequired,
    isString,
    hasLengthLessThan(500)
  )('Review text'),
  stars: createValidator(
    (message) => (value) => {
      if (![null, 1, 2, 3, 4, 5].includes(value)) {
        return message
      }
    },
    (field) => `${field} must be a number 1–5`
  )('Stars'),
})
```

We use [`createValidator`](http://revalidate.jeremyfairbank.com/usage/createValidator.html) to create custom validator functions, [`composeValidator`](http://revalidate.jeremyfairbank.com/usage/composeValidators.html) to compose multiple validator functions together, and [`combineValidators`](http://revalidate.jeremyfairbank.com/usage/combineValidators.html) to combine our validators in an object matching our data format, with `text` and `stars` fields. Here are some example outputs:

```js
validateReview({
  text: 1,
  stars: 5
})

// => {text: "Review text must be a String"}

validateReview({
  text: 'my review',
  stars: 'a string'
})

// => {stars: Stars must be a number 1–5`}
```

We don’t need to check for a `stars` error because our `<StarInput>` doesn’t produce an invalid value. But we include it in the validator so we can use the same code on the server.

Next we add the mutation! In the [Playground](https://api.graphql.guide/play), we find the `createReview` mutation. (The convention is that if the data type is `Foo`, the basic [CUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) mutations are called `createFoo`, `updateFoo`, and `deleteFoo`.) We’re used to `gql` and `useMutation()`, but, this time, we’ll have a larger `optimisticResponse` and a different kind of `update()`:

[`src/components/AddReview.js`](https://github.com/GraphQLGuide/guide/blob/13_0.2.0/src/components/AddReview.js)

```js
import { gql, useMutation } from '@apollo/client'
import pick from 'lodash/pick'

import { useUser } from '../lib/useUser'

const ADD_REVIEW_MUTATION = gql`
  mutation AddReview($input: CreateReviewInput!) {
    createReview(input: $input) {
      id
      text
      stars
      createdAt
      favorited
      author {
        id
        name
        photo
        username
      }
    }
  }
`

export default ({ done }) => {
  ...

  const { user } = useUser()

  const [addReview] = useMutation(ADD_REVIEW_MUTATION, {
    update: (store, { data: { createReview: newReview } }) => {
      // TODO
    },
  })

  function handleSubmit(event) {
    event.preventDefault()

    const errors = validateReview({ text, stars })
    if (errors.text) {
      setErrorText(errors.text)
      return
    }

    addReview({
      variables: {
        input: { text, stars },
      },
      optimisticResponse: {
        createReview: {
          __typename: 'Review',
          id: null,
          text,
          stars,
          createdAt: new Date(),
          favorited: false,
          author: pick(user, ['__typename', 'id', 'name', 'photo', 'username']),
        },
      },
    })
    done()
  }

  return ( ... )
}
```

We don’t know what the server-side `id` will be, so we set it to `null`, and it will be updated by Apollo when the server response arrives. Similarly, `createdAt` will be a little different on the server, but not enough to make a difference for optimistic display. We know that `favorited` is `false` because the user hasn’t had a chance to favorite the new review, and the `author` is the current user. 

So far our mutations have updated an existing object in the cache (the one with the same `id`), and that object, since it was part of a query result, triggers a component re-render. But this time, there is no existing object: we’re adding a new object to the cache. And the new object isn’t part of a query result. Apollo will add an object of type `Review` with `id: null` to the cache, but it won’t update the `<Reviews>` component’s `useQuery(REVIEWS_QUERY)` because Apollo doesn’t know the new review object should be part of the `REVIEWS_QUERY` results. So we have to change the `REVIEWS_QUERY` results ourselves in the `update` function. 
 
But first we need access to `REVIEWS_QUERY`, a variable inside `Reviews.js`. We’d run into trouble exporting it from `Reviews.js` because we’d have an import cycle—`Reviews.js` imports `AddReview`. So let’s create a new folder for GraphQL documents, `src/graphql/`, and make a new file:

[`src/graphql/Review.js`](https://github.com/GraphQLGuide/guide/blob/13_0.2.0/src/graphql/Review.js)

```js
import gql from 'graphql-tag'

export const REVIEWS_QUERY = gql`
  query ReviewsQuery {
    reviews(limit: 20) {
      id
      text
      stars
      createdAt
      favorited
      author {
        id
        name
        photo
        username
      }
    }
  }
`
```

And in `Reviews.js` and `AddReview.js`, we import it:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/blob/13_0.2.0/src/components/Reviews.js)

```js
import { REVIEWS_QUERY } from '../graphql/Review'
```

[`src/components/AddReview.js`](https://github.com/GraphQLGuide/guide/blob/13_0.2.0/src/components/AddReview.js)

```js
import { REVIEWS_QUERY } from '../graphql/Review'

...

  const [addReview] = useMutation(ADD_REVIEW_MUTATION, {
    update: (store, { data: { createReview: newReview } }) => {
      const { reviews } = store.readQuery({
        query: REVIEWS_QUERY,
      })
      store.writeQuery({
        query: REVIEWS_QUERY,
        data: { reviews: [newReview, ...reviews] },
      })
    },
  })
```

The second parameter to [`update`](https://www.apollographql.com/docs/react/basics/mutations.html#graphql-mutation-options-update) has the mutation response—it’s called first with the optimistic response, and then with the server response. So initially, `data.createReview` is the `optimisticResponse.createReview` object we just created. First we call `readQuery`, reading the current results from the cache. Then we call `writeQuery()` with the new array that has `newReview` at the beginning so that it shows up first, at the top of the page. 

![Optimistically adding review](/img/adding-review.gif)
[*gif: Optimistically adding review*](http://res.cloudinary.com/graphql/guide/adding-review.gif)

## Using fragments

[Fragments](2.md#fragments) are good for more than just [reading from and writing to the cache](#arbitrary-updates): they also can [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) up our queries and mutations. The selection set on `reviews` in the query we just relocated was the same as the selection set on `createReview` we used in our mutation. Let’s put that selection set in a fragment:

[`src/graphql/Review.js`](https://github.com/GraphQLGuide/guide/blob/13_0.2.0/src/graphql/Review.js)

```js
import gql from 'graphql-tag'

export const REVIEW_ENTRY = gql`
  fragment ReviewEntry on Review {
    id
    text
    stars
    createdAt
    favorited
    author {
      id
      name
      photo
      username
    }
  }
`

export const REVIEWS_QUERY = gql`
  query ReviewsQuery {
    reviews(limit: 20) {
      ...ReviewEntry
    }
  }
  ${REVIEW_ENTRY}
`
```

We can’t name the fragment `Review` because that’s the name of a type, so the convention is `ReviewEntry`. 

> If we were using prop types, we could now greatly simplify our `Review.propTypes` with our new fragment and the `propType()` function from [`graphql-anywhere`](https://github.com/apollographql/apollo-client/tree/master/packages/graphql-anywhere):

```js
import { propType } from 'graphql-anywhere'
import { REVIEW_ENTRY } from '../graphql/Review'

Review.propTypes = {
  review: propType(REVIEW_ENTRY).isRequired,
  favorite: PropTypes.func.isRequired
}
```

> `propType()` generates a React `propTypes`-compatible type-checking function for the `review` object from our `ReviewEntry` fragment. 

Lastly, we use the fragment in `AddReview.js`:

[`src/components/AddReview.js`](https://github.com/GraphQLGuide/guide/blob/13_0.2.0/src/components/AddReview.js)

```js
import { REVIEW_ENTRY } from '../graphql/Review'

const ADD_REVIEW_MUTATION = gql`
  mutation AddReview($input: CreateReviewInput!) {
    createReview(input: $input) {
      ...ReviewEntry
    }
  }
  ${REVIEW_ENTRY}
`
```

## Deleting

> If you’re jumping in here, `git checkout 13_0.2.0` (tag [`13_0.2.0`](https://github.com/GraphQLGuide/guide/tree/13_0.2.0)). Tag [`14_0.2.0`](https://github.com/GraphQLGuide/guide/tree/14_0.2.0) contains all the code written in this section.

Next let’s see how deleting an item works. We can add a dialog box confirming deletion, and when it’s confirmed, we’ll send the `removeReview` mutation:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/blob/14_0.2.0/src/components/Review.js)

```js
import  {  
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
  Button
} from 'material-ui/core'

const REMOVE_REVIEW_MUTATION = gql`
  mutation RemoveReview($id: ObjID!) {
    removeReview(id: $id)
  }
`

export default ({ review }) => {
  const { id, text, stars, createdAt, author } = review

  const [anchorEl, setAnchorEl] = useState()
  const [deleteConfirmationOpen, setDeleteConfirmationOpen] = useState(false)

  const [removeReview] = useMutation(REMOVE_REVIEW_MUTATION, {

  ...

  function deleteReview() {
    closeMenu()
    removeReview({ variables: { id } })
  }

  ...

      <Menu anchorEl={anchorEl} open={Boolean(anchorEl)} onClose={closeMenu}>
        <MenuItem onClick={editReview}>Edit</MenuItem>
        <MenuItem
          onClick={() => {
            closeMenu()
            setDeleteConfirmationOpen(true)
          }}
        >
          Delete
        </MenuItem>
      </Menu>

      <Dialog
        open={deleteConfirmationOpen}
        onClose={() => setDeleteConfirmationOpen(false)}
      >
        <DialogTitle>{'Delete review?'}</DialogTitle>
        <DialogContent>
          <DialogContentText>
            A better UX is probably just letting you single-click delete with an
            undo toast, but that's harder to code right{' '}
            <span role="img" aria-label="grinning face">
              😄
            </span>
          </DialogContentText>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDeleteConfirmationOpen(false)}>
            Cancel
          </Button>
          <Button onClick={deleteReview} color="primary" autoFocus>
            Sudo delete
          </Button>
        </DialogActions>
      </Dialog>
    </div>
  )
}
```

We see in the [Playground schema](https://api.graphql.guide/play) that `removeReview` resolves to a scalar type (`Boolean`), so unlike our previous mutations, it doesn’t have a selection set.

![Schema: removeReview](/img/schema-removeReview.png)

When we try out the new delete dialog, we notice that the review remains on the page. Did it work? We can check on the devtools Network tab, selecting the last `graphql` request, and switching to the Response tab: 

```json
{"data":{"removeReview":true}}
```

![Server response to removeReview](/img/remove-review-response.gif)
[*gif: Server response to removeReview*](http://res.cloudinary.com/graphql/guide/remove-review-response.gif)

So the deletion was successful (and when we refresh the page, the review is gone), but Apollo client didn’t know it should remove the review object from the cache. We can tell it to do so with `update()`:

```js
const [removeReview] = useMutation(REMOVE_REVIEW_MUTATION, {
  update: (cache) => {
    const { reviews } = cache.readQuery({ query: REVIEWS_QUERY })
    cache.writeQuery({
      query: REVIEWS_QUERY,
      data: { reviews: reviews.filter((review) => review.id !== id) },
    })

    const { currentUser } = cache.readQuery({ query: READ_USER_FAVORITES })
    cache.writeQuery({
      query: READ_USER_FAVORITES,
      data: {
        currentUser: {
          ...currentUser,
          favoriteReviews: currentUser.favoriteReviews.filter(
            (review) => review.id !== id
          ),
        },
      },
    })
  },
})
```

We need to remove the review not only from the `REVIEWS` query, but also from `currentUser.favoriteReviews`—otherwise, when we delete a favorited review, the count in the header of the reviews page will be inaccurate. 

We’re using `update()` without an `optimisticResponse`, which means it will only be called once, when the server response arrives. We’ll notice a delay between clicking `SUDO DELETE` and the review being removed from the page. If we want it to be removed immediately, we need an `optimisticResponse`, even if we’re not using the optimistic data:

```js
function deleteReview() {
  closeMenu()
  removeReview({
    variables: { id },
    optimisticResponse: {
      removeReview: true,
    },
  })
}
```

![Removing a review](/img/remove-review.gif)
[*gif: Removing a review*](http://res.cloudinary.com/graphql/guide/remove-review.gif)

## Error handling

Background: [GraphQL errors](1.md#security-&-error-handling)

> If you’re jumping in here, `git checkout 14_0.2.0` (tag [`14_0.2.0`](https://github.com/GraphQLGuide/guide/tree/14_0.2.0)). Tag [`15_0.2.0`](https://github.com/GraphQLGuide/guide/tree/15_0.2.0) contains all the code written in this section.

When we try to delete a review that isn’t ours, nothing happens. In the console, we see:

```
index.ts:49 Uncaught (in promise) Error: unauthorized
    at new ApolloError (index.ts:49)
    at Object.next (QueryManager.ts:223)
    ...
    at createHttpLink.ts:129
```

Let’s break that down:

- `Uncaught (in promise) Error: unauthorized`—There was a Promise that threw an error, and our code didn’t catch it.
- `at new ApolloError (index.ts:49)`—The error is coming from Apollo code.
- `at createHttpLink.ts:129`—The error is coming from our HTTP link, so it’s probably an error from the server. We can confirm this by looking at the network tab, finding the request to `api.graphql.guide` that has `operationName: "RemoveReview"` in the Request Payload, and seeing that the Response tab shows JSON with an `"errors"` attribute.

![Network tab of DevTools with the error response](/img/remove-review-network-error.png)

- `unauthorized`—This is the error message from the GraphQL server.

So the Guide server is saying that we’re not authorized to execute that `removeReview` mutation. This makes sense, because it’s not our review. We should have the app tell the user that, though. The `removeReview()` mutation function we get from `useMutation()` returns a Promise. This Promise will throw GraphQL errors, which we can catch like this:

```js
removeReview({ ... }).catch(e => console.log(e.graphQLErrors))
```

`e.graphQLErrors` is an array of all the errors returned from the server. In this case, we just have one:

```js
[
  {
    message: "unauthorized",
    locations: [{"line":2,"column":3}],
    path: ["removeReview"]
  }
]
```

We can now alert the user of the error, depending on whether we find an "unauthorized" message:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/blob/15_0.2.0/src/components/Review.js)

```js
import find from 'lodash/find'

  removeReview({
    variables: { id },
    optimisticResponse: {
      removeReview: true,
    },
  }).catch(e => {
    if (find(e.graphQLErrors, { message: 'unauthorized' })) {
      alert('👮‍♀️✋ You can only delete your own reviews!')
    }
  })
```

But what about other errors? We could get errors about anything bad happening on the server, from dividing by zero to a database query failing. We could add an `else` statement:

```js
} else {
  alert('Unexpected error occurred')
}
```      

But that wouldn’t cover unexpected errors occurring in all of our other queries and mutations. We can avoid peppering these unexpected-error alerts all over our code by checking errors globally as they arrive from the network. Whenever we want to do some logic that all requests or responses go through, we use a link. At the end of the [Logging in](#logging-in) section, we used a `setContext` link to set an authentication header on all outgoing HTTP requests. Here we can use an [`apollo-link-error`](https://github.com/apollographql/apollo-link/tree/master/packages/apollo-link-error). In `lib/apollo.js`, we rename our `link` to be `networkLink`, and then:

[`src/lib/apollo.js`](https://github.com/GraphQLGuide/guide/blob/15_0.2.0/src/lib/apollo.js)

```js
import { errorLink } from './lib/errorLink'

...

const networkLink = split( ... )

const link = errorLink.concat(networkLink)

export const apollo = new ApolloClient({ link, cache })
```

In a chain of links from left to right (where `leftLink.concat(rightLink)`), off the left side of the chain are our React components sending the operations, and off the right side is the network. We put `errorLink` to the left of `networkLink` because we need the GraphQL response coming from the network (off right side) to first go through the `networkLink` (the right end), and then to the `errorLink` (left end), before reaching our code (off left side). We create a new file for `errorLink`:

[`src/lib/errorLink.js`](https://github.com/GraphQLGuide/guide/blob/15_0.2.0/src/lib/errorLink.js)

```js
import { onError } from '@apollo/client/link/error'

const KNOWN_ERRORS = ['unauthorized']

export const errorLink = onError(({ graphQLErrors, networkError }) => {
  if (networkError) {
    console.log(`[Network error]: ${networkError}`)
    return
  }

  if (graphQLErrors) {
    const unknownErrors = graphQLErrors.filter(
      (error) => !KNOWN_ERRORS.includes(error.message)
    )

    if (unknownErrors.length) {
      alert('😳 An unexpected error occurred on the server')
      unknownErrors.map(({ message, locations, path }) =>
        console.log(`[GraphQL error]: Message: ${message}, Path: ${path}`)
      )
    }
  }
})
```

If there’s a known error, like `'unauthorized'`, let’s leave it to the originating component to alert the user, since that component knows the context of the error. For example, in `<Review>`, we can be specific, saying “You can only delete your own reviews!” Whereas if we made the alert in `errorLink`, like, “You are not authorized to view this data or perform this action,” it would be less helpful.

By default, when a GraphQL error is returned from the server, Apollo treats it as a fatal error in the query or mutation. In the case of an unauthorized deletion, the error is thrown from the mutation function, and `update()` isn’t called. This is why the review remains on the page. If we were sending a mutation for which we didn’t care about server errors, and we wanted the `update()` function to always run regardless, we could change the mutation’s default [error policy](https://www.apollographql.com/docs/react/features/error-handling.html#policies) like this:

`src/components/Review.js`

```js
const [removeReview] = useMutation(REMOVE_REVIEW_MUTATION, {
  errorPolicy: 'ignore',
  update: (cache) => { 
    ...
```

Then the call to `removeReview()` would resolve without an error being thrown, even if the server response contained an error, and the review would be removed from the cache and page.

Changing the error policy is more often useful when querying. Let’s see how the default error policy works when querying. We can change the `limit` argument on our `reviews` query to a special value of `-1` that will return demo reviews, some of which have a private `text` field.

> We can also see the effect of error policy in the [Apollo Error Handling Visualizer](https://apollo-visualizer.vercel.app/).

[`src/graphql/Review.js`](https://github.com/GraphQLGuide/guide/blob/15_0.2.0/src/graphql/Review.js)

```js
export const REVIEWS_QUERY = gql`
  query ReviewsQuery {
    reviews(limit: -1) {
```

When we do this query in [Playground](https://api.graphql.guide/play):

```js
{
  reviews(limit: -1) {
    stars
    text
  }
}
```

here’s the response we get back:

```
{
  "data": {
    "reviews": [
      {
        "stars": 5,
        "text": null
      },
      {
        "stars": 4,
        "text": "GraphQL is awesome, but React is soooo 2016. Write me a Vue chapter!"
      },
      {
        "stars": 3,
        "text": null
      }
    ]
  },
  "errors": [
    {
      "message": "unauthorized",
      "locations": [
        {
          "line": 4,
          "column": 5
        }
      ],
      "path": [
        "reviews",
        0,
        "text"
      ]
    },
    {
      "message": "unauthorized",
      "locations": [
        {
          "line": 4,
          "column": 5
        }
      ],
      "path": [
        "reviews",
        2,
        "text"
      ]
    }
  ]
}
```

<!-- [Playground: `query { reviews(limit: -1) { stars text } }`](https://graphqlbin.com/r02EC1) -->

The first and third reviews have private `text` fields, so we see `text: null` in `data.reviews` and the `errors` array has entries for each one with `"unauthorized"` messages. The first error `path` is `reviews.0.text`, corresponding to the 0th review in the `data.reviews` array, and the second error is at `review.2.text`. So the errors match up with the reviews that have `text: null`.

> The Review schema says that `text` is nullable. If `text` had been non-nullable (`text: String!`), then an error in the `text` resolver would have made the entire object `null`—`data` would have been `{ "reviews": null }`.

Let’s see how our app is handling this partially-null data response with an `errors` attribute. It looks like we’re getting an error:

```
Uncaught TypeError: Cannot read property 'map' of undefined
    at push../src/components/Reviews.js.__webpack_exports__.default (Reviews.js:35)
    ...
```

Which corresponds to this line:

```js
reviews.map(review => <Review key={review.id} review={review} />)
```

So it looks like `reviews` is undefined. Let’s also look at `data.error`:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/blob/15_0.2.0/src/components/Review.js)

```js
  const { data: { reviews } = {}, loading, error } = useQuery(REVIEWS_QUERY)
  console.log('error:', error)
```

It has these fields:

```json
error.stack
error.graphQLErrors
error.networkError
error.message
error.extraInfo
```

and `error.graphQLErrors` looks like this:

```js
[
  {
    message: "unauthorized",
    locations: [{ line: 10, column: 3 }],
    path: [ "reviews", 0, "text" ]
  },
  {
    message: "unauthorized",
    locations: [{ line: 10, column: 3 }],
    path: [ "reviews", 2, "text" ]
  }
]
```

If we want `reviews` to be defined, we can set `errorPolicy` to [`'all'`](https://www.apollographql.com/docs/react/features/error-handling.html#policies):

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/blob/15_0.2.0/src/components/Review.js)

```js
const { data: { reviews } = {}, loading } = useQuery(REVIEWS_QUERY, {
  errorPolicy: 'all',
})
```

We can handle `text` sometimes being `null` in `<Review>`:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/blob/15_0.2.0/src/components/Review.js)

```js
<CardContent>
  {text ? (
    <Typography component="p">{text}</Typography>
  ) : (
    <Typography component="i">Text private</Typography>
  )}
</CardContent>
```

If there were other errors that we thought might result in a null `text` field, we could take different actions based on `error` in `<Reviews>`. If we wanted to ignore all errors (reviews would be defined, and `error` would be undefined), we could set `errorPolicy: 'ignore'`.

![Private reviews](/img/private-reviews.png)

Let’s see what happens when we trigger a different error: first let’s sign out, and then let’s interact with a review. We notice that when we favorite, edit, or delete, the "unexpected error" alert appears:

![Unexpected error alert](/img/unexpected-error.png)

To figure out what it is, we could look at the GraphQL response in the Network panel, or we can just look in the console, since the `errorLink` we made logs unknown errors. There, we find that the error message is `must sign in`, for instance:

```
[GraphQL error]: Message: must sign in, Path: favoriteReview
```

Having a user see this alert isn’t good UX. One way to avoid it is by adding `must sign in` to `KNOWN_ERRORS` in `src/lib/errorLink.js`, and then handling the error in `<Review>` with a message like, “Sign in to favorite a review.” Another way to avoid the error is to just remove the UI controls when the user isn’t signed in 😄. Let’s go with the latter solution, but, before we do, note what happens to the review on the page right after we take the action, before we dismiss the alert: when we favorite, the heart stays filled in; when we delete, the review disappears, and when we edit, the review changes. In each case, when we dismiss the alert, the review changes back to its previous state. This is a great demonstration of optimistic updates—Apollo applies the optimistic change, then it receives an error back from the server, which goes through our `errorLink`, which puts up an alert, which halts JS execution until it is dismissed. Once it’s dismissed, Apollo is able to finish handling the response—it realizes that the mutation was unsuccessful, so it rolls back the optimistic update, restoring our cache to its previous state, which triggers new props being provided to our components, which triggers React to re-render them. 

To remove the UI elements, we check if `user` is defined with `user && <Component />`:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/blob/15_0.2.0/src/components/Review.js)

```js
import { useUser } from '../lib/useUser'

export default ({ review }) => {
  const { id, text, stars, createdAt, author } = review

  const { user } = useUser()

  ...

  <CardHeader
    action={
      user && (
        <IconButton onClick={this.openMenu}>
          <MoreVert />
        </IconButton>
      )
    }

    ...

    {user && <FavoriteButton {...review} />}
```

![Hidden review icons](/img/hidden-review-icons.png)

## Editing reviews

> If you’re jumping in here, `git checkout 15_0.2.0` (tag [`15_0.2.0`](https://github.com/GraphQLGuide/guide/tree/15_0.2.0)). Tag [`16_0.2.0`](https://github.com/GraphQLGuide/guide/tree/16_0.2.0) contains all the code written in this section.

The last piece of the reviews page we haven’t implemented yet is editing reviews! Let’s see how much of our `<AddReview>` component we can reuse by renaming it to `<ReviewForm>` and deciding which mutation to call (the update or create mutation) based on the props. We’ll need to add a `<Modal>` with the form to `<Review>` and pass in the review object as a prop:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/blob/16_0.2.0/src/components/Review.js)

```js
import { Modal } from '@material-ui/core'

import ReviewForm from './ReviewForm'

export default ({ review }) => {
  
  ...
  
  const [editing, setEditing] = useState(false)

  ...

  function editReview() {
    closeMenu()
    setEditing(true)
  }

  ...

      <Modal open={editing} onClose={() => setEditing(false)}>
        <ReviewForm done={() => setEditing(false)} review={review} />
      </Modal>
    </div>
  )
}
```

The mutation takes the review’s `id` and the new `text` and `stars` fields:

```gql
input UpdateReviewInput {
  text: String!
  stars: Int
}

type Mutation {
  updateReview(id: ObjID!, input: UpdateReviewInput!): Review
}
```

We know whether we’re editing based on the presence of the `review` prop, and we also use it to set initial values for the `text` and `stars` inputs:

[`src/components/ReviewForm.js`](https://github.com/GraphQLGuide/guide/blob/16_0.2.0/src/components/ReviewForm.js)

```js
import classNames from 'classnames'

const EDIT_REVIEW_MUTATION = gql`
  mutation EditReview($id: ObjID!, $input: UpdateReviewInput!) {
    updateReview(id: $id, input: $input) {
      id
      text
      stars
    }
  }
`

export default ({ done, review }) => {
  const [text, setText] = useState(review ? review.text : ''),
    [stars, setStars] = useState(review ? review.stars : null),
    [errorText, setErrorText] = useState()

  ...

  const [editReview] = useMutation(EDIT_REVIEW_MUTATION)

  const isEditing = !!review

  function handleSubmit(event) {
    event.preventDefault()

    const errors = validateReview({ text, stars })
    if (errors.text) {
      setErrorText(errors.text)
      return
    }

    if (isEditing) {
      editReview({
        variables: {
          id: review.id,
          input: { text, stars },
        },
        optimisticResponse: {
          updateReview: {
            __typename: 'Review',
            id: review.id,
            text,
            stars,
          },
        },
      })
    } else {
      addReview({ ... })
    }

    done()
  }

  return (
    <form
      className={classNames('ReviewForm', { editing: isEditing })}
      autoComplete="off"
      onSubmit={handleSubmit}
    >
    
      ...

        <Button type="submit" color="primary" className="AddReview-submit">
          {isEditing ? 'Save' : 'Add review'}
        </Button>
      </div>
    </form>
  )
}
```

When editing a single object, we only need to select the `id` and fields that are changing. When the response arrives (and when the `optimisticResponse` is handled), just those fields are updated in the cache (the other fields like `author` and `favorited` will remain). 

![Editing a review*](http://res.cloudinary.com/graphql/guide/edit-review.gif)
[*gif: Editing a review*](http://res.cloudinary.com/graphql/guide/edit-review.gif)

# Advanced querying

Section contents:

* [Paginating](6.md#paginating)
  * [Offset-based](6.md#offset-based)
    * [page](6.md#page)
    * [skip & limit](6.md#skip-&-limit)
  * [Cursors](6.md#cursors)
    * [after](6.md#after)
    * [orderBy](6.md#orderby)
* [Client-side ordering & filtering](6.md#client-side-ordering-&-filtering)
* [Local state](6.md#local-state)
  * [Reactive variables](6.md#reactive-variables)
  * [In cache](6.md#in-cache)
* [REST](6.md#rest)
* [Review subscriptions](6.md#review-subscriptions)
  * [Subscription component](6.md#subscription-component)
  * [Add new reviews](6.md#add-new-reviews)
  * [Update on edit and delete](6.md#update-on-edit-and-delete)
* [Prefetching](6.md#prefetching)
  * [On mouseover](6.md#on-mouseover)
  * [Cache redirects](6.md#cache-redirects)
* [Batching](6.md#batching)
* [Persisting](6.md#persisting)
* [Multiple endpoints](6.md#multiple-endpoints)

## Paginating

* [Offset-based](6.md#offset-based)
  * [page](6.md#page)
  * [skip & limit](6.md#skip-&-limit)
* [Cursors](6.md#cursors)
  * [after](6.md#after)
  * [orderBy](6.md#orderby)

Our `ReviewsQuery` currently has `limit: 20` because loading all the reviews would be unwise 😄. We don’t know how many reviews there will be in the database, and receiving thousands of them over the network would take a long time on mobile. They’d take a lot of memory in the Apollo cache, they’d take a long time to render onto the page, and we’d have the problems that come along with a high DOM (and VDOM) node count: interacting with the DOM takes longer, and the amount of memory the browser uses grows—in the worst case, it exceeds the available memory on the device. On mobile, the OS kills the browser process, and on a computer, the OS starts using the hard drive for memory, which is very slow.

😅 So! In any app where the user might want to see a potentially long list of data, we paginate: we request and display a set amount of data, and when the user wants more (either by scrolling down—in the case of infinite scroll—or by clicking a “next page” link or “page 3” link), we request and display more. There are two main methods of pagination: offset-based, which we’ll talk about first, and [cursors](#cursors). 

We can display the data however we want. The two most common methods are pages (with next/previous links and/or numbered page links like Google search results) and infinite scroll. We can use either data-fetching method with either display method.

### Offset-based

Offset-based pagination is the easier of the two methods to implement—both on the client and on the server. In its simplest form, we request a `page` number, and each page has a set number of items. The Guide server sends 10 items per page, so page 1 has the first 10, page 2 has items 11-20, etc. A more flexible form is using two parameters: `offset` (or `skip`) and `limit`. The client decides how large each page is by setting the `limit` of how many items the server should return. For instance, we can have 20-item pages by first requesting `skip: 0, limit: 20`, then requesting `skip: 20, limit: 20` (“give me 20 items starting with #20”, so items 20-39), then `skip: 40, limit: 20`, etc.

The downside of offset-based pagination is that if the list is modified between requests, we might miss items or see them twice. Take, for example, this scenario:

1. We fetch page 1 with the first 10 items. 
2. Some other user deletes the 4th and 5th items.
3. If we were to fetch page 1 again, we would get the new first 10 items, which would now be items 1–3 and 6–12. But we don’t refetch page 1—we fetch page 2. 
4. Page 2 returns items 13–22. Which means now we’re showing the user items 1-10 and 13-22, and we’re missing items 11 and 12, which are now part of page 1.

On the other hand, if things are added to the list, we’ll see things twice:

1. We fetch page 1 with the first 10 items.
2. Some other user submits two new items.
3. If we were to fetch page 1 again, we would get the 2 new items and then items 1–8. But instead we fetch page 2.
4. Page 2 returns items 9-18, which means our list has items 9 and 10 twice—once from page 1 and once from page 2. 

Depending on our application, these issues might never happen, or if they do, it might not be a big deal. If it is a big deal, switching to [cursor-based](#cursors) pagination will fix it. Another possible solution, depending on how often items are added/deleted, is requesting extra pages (to make sure not to miss items) and de-duplicating (to make sure not to display the same item twice). For example, first we could request just page 1, and then when we want page 2, we request both pages 1 and 2. Now if we were in the first scenario above, and the 4th and 5th items were deleted, re-requesting page 1 would get items 11 and 12, which we previously missed. We’ll get items 1–3 and 6–10 a second time, but we can match their IDs to objects already in the cache and discard them.

Let’s see this in action. Normally an API will support a single pagination method, but, as we can see from this schema comment, the `reviews` query supports three different methods:

![reviews Query in the schema](/img/reviews-schema.png)

#### page

> If you’re jumping in here, `git checkout 16_0.2.0` (tag [`16_0.2.0`](https://github.com/GraphQLGuide/guide/tree/16_0.2.0)). Tag [`17_0.2.0`](https://github.com/GraphQLGuide/guide/tree/17_0.2.0) contains all the code written in this section.

Let’s try `page` first. We switch our `ReviewQuery` from using the `limit` parameter to using the `page` parameter, and we use a variable so that `<Reviews>` can say which page it wants.

`src/graphql/Review.js`

```js
export const REVIEWS_QUERY = gql`
  query ReviewsQuery($page: Int) {
    reviews(page: $page) {
      ...ReviewEntry
    }
  }
  ${REVIEW_ENTRY}
`
```

`src/components/Reviews.js`

```js
const { data: { reviews } = {}, loading } = useQuery(REVIEWS_QUERY, {
  variables: { page: 1 },
  errorPolicy: 'all',
})
```

Now the page displays the first 10 reviews. If we change it to `{ page: 2 }`, we see the second 10 reviews. We could make the page number dynamic, but let’s instead make the next method dynamic: skip and limit.

#### skip & limit

To use the `skip` and `limit` parameters, we replace `page` with them in the query:

[`src/graphql/Review.js`](https://github.com/GraphQLGuide/guide/blob/17_0.2.0/src/graphql/Review.js)

```js
export const REVIEWS_QUERY = gql`
  query ReviewsQuery($skip: Int, $limit: Int) {
    reviews(skip: $skip, limit: $limit) {
      ...ReviewEntry
    }
  }
  ${REVIEW_ENTRY}
`
```

and update our component:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/blob/17_0.2.0/src/components/Reviews.js)

```js
const { data: { reviews } = {}, loading } = useQuery(REVIEWS_QUERY, {
  variables: { skip: 0, limit: 10 },
  errorPolicy: 'all',
})
```

We still see the first 10 reviews, as expected. To make sure it works, we can view the next 10 by editing it to be `{ skip: 10, limit: 10 }`. 

Let’s implement infinite scroll, during which the component will provide new values for `skip` when the user scrolls to the bottom of the page. First, let’s simplify what we’re working with by extracting out the list of reviews to `<ReviewList>`. `<Reviews>` will be left with the header and the add button:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/blob/17_0.2.0/src/components/Reviews.js)

```js
import ReviewList from './ReviewList'

...

export default () => {
  ...

  return (
    <main className="Reviews mui-fixed">
      <div className="Reviews-header-wrapper">
        ...
      </div>

      <ReviewList />

      {user && (
        <div>
          <Fab
            onClick={() => setAddingReview(true)}
            color="primary"
            className="Reviews-add"
          >
            <Add />
          </Fab>

          <Modal open={addingReview} onClose={() => setAddingReview(false)}>
            <ReviewForm done={() => setAddingReview(false)} />
          </Modal>
        </div>
      )}
    </main>
  )
}
```

Here’s our new `<ReviewList>`:

[`src/components/ReviewList.js`](https://github.com/GraphQLGuide/guide/blob/17_0.2.0/src/components/ReviewList.js)

```js
import React from 'react'
import { useQuery } from '@apollo/client'

import Review from './Review'
import { REVIEWS_QUERY } from '../graphql/Review'

export default () => {
  const { data: { reviews } = {}, loading } = useQuery(REVIEWS_QUERY, {
    variables: { skip: 0, limit: 10 },
    errorPolicy: 'all',
  })

  return (
    <div className="Reviews-content">
      {loading ? (
        <div className="Spinner" />
      ) : (
        reviews.map((review) => <Review key={review.id} review={review} />)
      )}
    </div>
  )
}
```

We’re going to want a spinner at the bottom of the list of reviews to indicate that we’re loading more. When the list is really long—as it is in the case of reviews—we don’t need to code hiding the spinner, since it’s unlikely users will reach the end 😄. Since we’ll always have a spinner, we no longer need `loading`:

```js
export default () => {
  const { data } = useQuery(REVIEWS_QUERY, {
    variables: { skip: 0, limit: 10 },
    errorPolicy: 'all',
  })

  const reviews = (data && data.reviews) || []

  return (
    <div className="Reviews-content">
      {reviews.map((review) => (
        <Review key={review.id} review={review} />
      ))}
      <div className="Spinner" />
    </div>
  )
}
```

Note that `reviews` is `undefined` during loading, so in order to prevent `reviews.map` from throwing an error, we need a default value of `[]` for `reviews`.

`useQuery()` returns a [`fetchMore`](https://www.apollographql.com/docs/react/basics/queries.html#graphql-query-data-fetchMore) property that we can use to fetch more data using the same query but different variables—in our case, the next set of reviews.

Let’s call `fetchMore()` when the user approaches the bottom of the page:

```js
import { useEffect } from 'react'

export default () => {
  const { data, fetchMore } = useQuery(REVIEWS_QUERY, {
    variables: { skip: 0, limit: 10 },
    errorPolicy: 'all',
  })

  const reviews = (data && data.reviews) || []

  const onScroll = () => {
    const currentScrollHeight = window.scrollY + window.innerHeight
    const pixelsFromBottom =
      document.documentElement.scrollHeight - currentScrollHeight
    const closeToBottom = window.scrollY > 0 && pixelsFromBottom < 250

    if (closeToBottom) {
      // TODO call fetchMore
    }
  }

  useEffect(() => {
    window.addEventListener('scroll', onScroll)
    return () => window.removeEventListener('scroll', onScroll)
  }, [onScroll])

  return ...
}
```

We register a scroll listener inside of `useEffect()`. The listener checks the current scroll position, and if we’re less than 250 pixels from the bottom, will call `fetchMore()`, which we’ll implement next:

```js
if (closeToBottom) {
  fetchMore({ variables: { skip: reviews.length } })
}
```

We can keep the same `limit` by not including it in `variables`. And we know how many to skip for the next query—the amount we currently have, `data.reviews.length`. 

If we test this out, nothing happens! If we check the cache, we see that another entry was added to `ROOT_QUERY`:

```
> __APOLLO_CLIENT__.cache.data.data.ROOT_QUERY
...
reviews({"limit":10,"skip":0}): (10) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]
reviews({"limit":10,"skip":10}): (10) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]
```

The second entry, with `"skip":10` was added after we scrolled to the bottom of the page. But our `<ReviewsList />` component still just displays the first list. The solution is to *merge* the second list into the first list when it arrives from the server. We do this with a cache merge function. There’s a built-in merge function called `concatPagination` that just concats the incoming list onto the end of the existing list, so let’s try that:

[`src/lib/apollo.js`](https://github.com/GraphQLGuide/guide/blob/17_0.2.0/src/lib/apollo.js)

```js
import { concatPagination } from '@apollo/client/utilities'

const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        reviews: concatPagination(),
      },
    },
  },
})

export const apollo = new ApolloClient({ link, cache })
```

Now when we re-test, it works! One issue is that scroll events fire often, so once the user passes the threshold, we’re calling `fetchMore()` a **lot** 😜. We only need to once, so we want to stop ourselves from calling it again if we just called it. We can tell whether we just called it by looking at [`networkStatus`](https://www.apollographql.com/docs/react/data/queries/#inspecting-loading-states), a property returned by `useQuery()`, which has a numerical value corresponding with different statuses—loading, ready, polling, refetching, etc. It’s `3` while Apollo is fetching more data, and then goes back to `7` (ready) when the data has arrived. Here are all the possible values:

```
1: "loading"
2: "setVariables"
3: "fetchMore"
4: "refetch"
6: "poll"
7: "ready"
8: "error"
```

They’re also exported in the `NetworkStatus` enum. Let’s skip `fetchMore()` if the current status is `NetworkStatus.fetchMore`:

[`src/components/ReviewList.js`](https://github.com/GraphQLGuide/guide/blob/17_0.2.0/src/components/ReviewList.js)

```js
import { NetworkStatus } from '@apollo/client'
import throttle from 'lodash/throttle'

export default () => {
  const { data, fetchMore, networkStatus } = useQuery(REVIEWS_QUERY, {
    variables: { skip: 0, limit: 10 },
    errorPolicy: 'all',
    notifyOnNetworkStatusChange: true,
  })

  const reviews = (data && data.reviews) || []
  
  const onScroll = throttle(() => {
    if (networkStatus !== NetworkStatus.fetchMore) {
      const currentScrollHeight = window.scrollY + window.innerHeight
      const pixelsFromBottom =
        document.documentElement.scrollHeight - currentScrollHeight
      const closeToBottom = window.scrollY > 0 && pixelsFromBottom < 250

      if (closeToBottom && reviews.length > 0) {
        fetchMore({ ... })
      }
    }
  }, 100)

  useEffect(() => {
    window.addEventListener('scroll', onScroll)
    return () => window.removeEventListener('scroll', onScroll)
  }, [onScroll])

  return ...
}
```

In addition to the `if (networkStatus !== NetworkStatus.fetchMore)` check, we also added:

- `notifyOnNetworkStatusChange: true` option to `useQuery()` so that the `networkStatus` property gets updated.
- `throttle(() => ..., 100)` to `onScroll` so that the function isn’t run more than once every 100 milliseconds.
- `if (closeToBottom && reviews.length > 0)` in case the response to the initial reviews query hasn’t yet arrived.

Another issue we’ve got is what happens when someone else adds a review during the time between when the user loads the page and when they scroll to the bottom. `loadMoreReviews()` will query for `reviews(skip: 10, limit: 10)`, which will return items 11-20. However, the 11th item now is the same as the 10th item before, and we already have the 10th item in the cache. When they’re combined with `concatPagination()`, the reviews list has a duplicated item. And since we use the review’s `id` for the `key`, React gives us this error in the console:

```
Warning: Encountered two children with the same key
```

We can prevent duplicate objects from being saved in the cache by writing a custom merge function:

[`src/lib/apollo.js`](https://github.com/GraphQLGuide/guide/blob/17_0.2.0/src/lib/apollo.js)

```js
import find from 'lodash/find'

const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        reviews: {
          merge(existing = [], incoming, { readField }) {
            const notAlreadyInCache = (review) =>
              !find(
                existing,
                (existingReview) =>
                  readField('id', existingReview) === readField('id', review)
              )

            const newReviews = incoming.filter(notAlreadyInCache)

            return [...existing, ...newReviews]
          },
          keyArgs: false,
        },
      },
    },
  },
})
```

The merge function gets three arguments: 

- `existing`: The result currently in the cache.
- `incoming`: The result being written to the cache (usually it just arrived from the server).
- An object with helper functions.

First, we filter out all of the reviews that are already in the cache (see note at the end of the [Client-side ordering & filtering](#client-side-ordering-&-filtering) section for how to make this more efficient). Then we concatenate the existing reviews with the new reviews. Since `Review` objects are normalized in the cache, `existing` and `incoming` are arrays of references to `Review`s. This means we can’t do `review.id`—instead, we use the `readField` helper function: `readField('id', review)`.

`keyArgs` defines which arguments result in a different entry in the cache. It defaults to all the arguments, which in this case would be `keyArgs: ['skip', 'limit']`. We do not want a different entry in the cache created when we change our pagination arguments, so we do `keyArgs: false`.

We can test it out by setting a `skip` that’s too low, for instance:

```js
variables: { skip: reviews.length - 5 },
```

Now when we scroll down, we should have 15 total reviews on the page instead of 20, and we no longer get the React duplicate key error. 

It seems strange at first, but subtracting some number from the length is a good idea to leave in the code! It makes sure—in the case in which some of the first 10 items are deleted—that we don’t miss any items. If we still want 10 new items to (usually) show up when we scroll down, then we can also change `limit` to 15:

[`src/components/ReviewList.js`](https://github.com/GraphQLGuide/guide/blob/17_0.2.0/src/components/ReviewList.js)

```js
  variables: { skip: reviews.length - 5, limit: 15 },
```

While our pagination now works, creating and deleting reviews has stopped working! When we try, we get an error:

```
MissingFieldError
message: "Can't find field 'reviews' on ROOT_QUERY object"
path: ["reviews"]
query: {kind: "Document", definitions: Array(2), loc: Location}
variables: {}
```

In our add and remove `update` functions, we’re trying to read `REVIEWS_QUERY` from the cache. Since we’re not specifying variables there, it looks in the cache for the root query field `reviews({})`, with no arguments. And we don’t have that in our cache, because we’ve never done a `REVIEWS_QUERY` without arguments—we’ve only done it with a `skip` and `limit`. We can enter the below into the browser console to print out the current Apollo cache’s state:

```
> __APOLLO_CLIENT__.cache.data.data.ROOT_QUERY
{
  chapters: (14) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]
  currentUser: {__ref: "User:5a4ca4eb10bda60096ea8f01"}
  githubStars: 103
  reviews({"limit":10,"skip":0}): (10) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]
  __typename: "Query"
}
```
We can see that our `reviews` query has both arguments:

```
reviews({"limit":10,"skip":0}): ...
```

We could try to fix this by providing the same arguments to `cache.readQuery`, so that Apollo knows which field on `ROOT_QUERY` to read from:

`src/graphql/Review.js`

```js
export const REVIEWS_QUERY = ...

export const REVIEWS_QUERY_FROM_CACHE = {
  query: REVIEWS_QUERY,
  variables: {
    skip: 0,
    limit: 10,
  },
}
```

`src/components/ReviewForm.js`

```js
import { REVIEW_ENTRY, REVIEWS_QUERY_FROM_CACHE } from '../graphql/Review'

const [addReview] = useMutation(ADD_REVIEW_MUTATION, {
  update: (store, { data: { createReview: newReview } }) => {
    const { reviews } = store.readQuery(REVIEWS_QUERY_FROM_CACHE)
    store.writeQuery({
      ...REVIEWS_QUERY_FROM_CACHE,
      data: { reviews: [newReview, ...reviews] },
    })
  },
})
```

`src/components/Review.js`

```js
import { REVIEWS_QUERY_FROM_CACHE } from '../graphql/Review'

const [removeReview] = useMutation(REMOVE_REVIEW_MUTATION, {
  update: (cache) => {
    const { reviews } = cache.readQuery(REVIEWS_QUERY_FROM_CACHE)
    cache.writeQuery({
      ...REVIEWS_QUERY_FROM_CACHE,
      data: { reviews: reviews.filter((review) => review.id !== id) },
    })
```

However, the problem with this approach is that doing `writeQuery()` runs the data through our `InMemoryCache` `typePolicies`—in particular, our reviews `merge` function. In the case of adding a review, our `merge` puts the new review at the end of the list, not the beginning, and in the case of removing a review, does nothing: the `merge` function gets the list of all-but-one reviews, filters them through `notAlreadyInCache` (resulting in `newReviews = []`), and returns `[...existing, ...newReviews]`:

[`src/lib/apollo.js`](https://github.com/GraphQLGuide/guide/blob/17_0.2.0/src/lib/apollo.js)

```js
import find from 'lodash/find'

const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        reviews: {
          merge(existing = [], incoming, { readField }) {
            const notAlreadyInCache = (review) =>
              !find(
                existing,
                (existingReview) =>
                  readField('id', existingReview) === readField('id', review)
              )

            const newReviews = incoming.filter(notAlreadyInCache)

            return [...existing, ...newReviews]
          },
          keyArgs: false,
        },
      },
    },
  },
})
```

The solution is to use [`cache.modify()`](https://www.apollographql.com/docs/react/caching/cache-interaction/#cachemodify) instead of `cache.writeQuery()`. `cache.modify()` directly modifies the data in the cache, bypassing all `typePolicies`. Let’s fix `addReview`’s `update` function:

[`src/components/ReviewForm.js`](https://github.com/GraphQLGuide/guide/blob/17_0.2.0/src/components/ReviewForm.js)

```js
export default ({ done, review }) => {
  ...

  const [addReview] = useMutation(ADD_REVIEW_MUTATION, {
    update: (cache, { data: { createReview: newReview } }) => {
      cache.modify({
        fields: {
          reviews(existingReviewRefs = []) {
            const newReviewRef = cache.writeFragment({
              data: newReview,
              fragment: gql`
                fragment NewReview on Review {
                  id
                  text
                  stars
                  createdAt
                  favorited
                  author {
                    id
                  }
                }
              `,
            })

            return [newReviewRef, ...existingReviewRefs]
          },
        },
      })
    },
  })
```

`cache.modify()` takes a `fields` object, and we provide a `reviews()` function to modify the `reviews` root query field in the cache (`__APOLLO_CLIENT__.cache.data.data.ROOT_QUERY.reviews`). `reviews()` receives as an argument the current cache contents, which is a list of reviews. But unlike `.readQuery()`, it’s an array of references to the normalized `Review` cache objects rather than the objects themselves. And instead of adding an object to the beginning of the array, we write a new `Review` object to the cache and put a reference to it in the array.

Next we’ll fix `removeReview`’s `update` function:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/blob/17_0.2.0/src/components/Review.js)

```js
const [removeReview] = useMutation(REMOVE_REVIEW_MUTATION, {
  update: (cache) => {
    cache.modify({
      fields: {
        reviews: (reviewRefs, { readField }) =>
          reviewRefs.filter((reviewRef) => readField('id', reviewRef) !== id),
      }
    })
  }
})
```

TODO https://github.com/apollographql/apollo-client/issues/7321

As we did with our `merge` function, we use `readField` to read review object properties from the cache. And to help ourselves remember that we’re dealing with references to normalized objects in the cache instead of the review objects themselves, we name the variables `reviewRefs` and `reviewRef`.

Now our new reviews are successfully written to the cache. However, we might notice that when we delete a favorited review, the favorite count in the header doesn’t update. We need to update the `currentUser.favoriteReviews` field in our cache. To update a nested field, we can make another call to `cache.modify()` inside the `fields.currentUser` function:

```js
const [removeReview] = useMutation(REMOVE_REVIEW_MUTATION, {
  update: (cache) => {
    cache.modify({
      fields: {
        reviews: (reviewRefs, { readField }) =>
          reviewRefs.filter((reviewRef) => readField('id', reviewRef) !== id),
        currentUser(currentUserRef) {
          cache.modify({
            id: currentUserRef.__ref,
            fields: {
              favoriteReviews: (reviewRefs, { readField }) =>
                reviewRefs.filter(
                  (reviewRef) => readField('id', reviewRef) !== id
                ),
            },
          })
          return currentUserRef
        },
      },
    })
  },
})
```

In the case of our first call to `cache.modify()`, we didn’t need an `id` because we’re editing root query fields. But for the second call, `currentUser` is a normalized `User` object, and to modify a normalized object, we need to provide its `id`.

This works, but it’s a lot of code to remove a single object. (And it doesn’t actually even remove the object from the cache. It’s still there, we just removed two references to it.) Fortunately, there’s another cache method we can use to simplify: [`cache.evict()`](https://www.apollographql.com/docs/react/caching/garbage-collection/#cacheevict). Given the cache ID of an object, it removes the object from the cache:

```js
const [removeReview] = useMutation(REMOVE_REVIEW_MUTATION, {
  update: (cache) => cache.evict({ id: cache.identify(review) }),
})
```

We use the [`cache.identify()`](https://www.apollographql.com/docs/react/caching/cache-interaction/#obtaining-an-objects-custom-id) method to get the cache ID of `review`. It works on any object that has both a `__typename` and an `id`. 

Our `cache.evict()` appears to work just as well as our `cache.modify()` code. What happened to the references, we might wonder? They’re still there. They’re called *dangling references*, because the object they refer to no longer exists. They’re not a problem for us because by default, Apollo [filters them out of array fields](https://www.apollographql.com/docs/react/caching/garbage-collection/#dangling-references).

We may recall this `favoriteReviews` filtering from our `FAVORITE_REVIEW_MUTATION` update function, where we used `readQuery()` and `writeQuery()`. We can shorten that code by using a nested `cache.modify()`:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/blob/17_0.2.0/src/components/Review.js)

```js
const [favorite] = useMutation(FAVORITE_REVIEW_MUTATION, {
  update: (cache, { data: { favoriteReview } }) => {
    cache.modify({
      fields: {
        currentUser(currentUserRef) {
          cache.modify({
            id: currentUserRef.__ref,
            fields: {
              favoriteReviews: (reviewRefs, { readField }) =>
                favoriteReview.favorited
                  ? [...reviewRefs, { __ref: `Review:${id}` }]
                  : reviewRefs.filter(
                      (reviewRef) => readField('id', reviewRef) !== id
                    ),
            },
          })
          return currentUserRef
        },
      },
    })
  },
})
```

If the review was just favorited, we add a reference to it to the `favoriteReviews` list. Otherwise, we filter it out. The format of a cache reference is `{ __ref: 'cache-ID' }`. If we had a `review` cache object like `{ __typename: 'Review', id: '5a4ca4eb10bda60096ea8f01' }`, then we could do `{ __ref: cache.identify(review) }`, but since all we have here is the `id` prop, we construct the cache ID manually: `{ __ref: `Review:${id}` }`.

Back in our reviews query, what happens when `fetchMore()` changes `skip` to 10 or 20? Do we need to also update our calls to `cache.modify()` or `readQuery()`? It turns out that we don’t need to: since we set `keyArgs: false` in the `reviews` field policy, when we call `fetchMore()`, the additional results get added to the cache under the original root query field. We can see this is the case by scrolling down, opening Apollo devtools -> Cache, and looking at `ROOT_QUERY`:

![fetchMore reviews in Cache](img/fetchMore-reviews-cache.png)

Or by entering `__APOLLO_CLIENT__.cache.data.data.ROOT_QUERY` in the console.

### Cursors

> If you’re jumping in here, `git checkout 17_0.2.0` (tag [`17_0.2.0`](https://github.com/GraphQLGuide/guide/tree/17_0.2.0)). Tag [`18_0.2.0`](https://github.com/GraphQLGuide/guide/tree/18_0.2.0) contains all the code written in this section.

Subsections:

* [after](6.md#after)
* [orderBy](6.md#orderby)

Cursor-based pagination uses a **cursor**—a pointer to where we are in a list. With cursors, the schema looks different from the Guide schema we’ve been working with. Our queries could look something like:

```gql
{
  listReviews (cursor: $cursor, limit: $limit) {
    cursor
    reviews {
      ...ReviewEntry
    }
  }
}
```

Each query comes back with a cursor, which we then include as an argument in our next query. A cursor usually encodes both the ID of the last item and the list’s sort order, so that the server knows what to return next. For instance, if the first 10 reviews ended with a review that had an ID of `100`, and the list was ordered by most recently created, the cursor could be `100:createdAt_DESC`, and the query could be:

```gql
{
  listReviews (cursor: "100:createdAt_DESC", limit: 10) {
    cursor
    reviews {
      ...ReviewEntry
    }
  }
}
```

It would return:

```json
{
  "data": {
    "listReviews": {
      "cursor": "90:createdAt_DESC",
      "reviews": [{
        "id": "99"
        ...
      },
      ...
      {
        "id": "90"
        ...
      }]
    }
  }
}
```

And then our next query would be `listReviews (cursor: "90:createdAt_DESC", limit: 10)`. 

This is a simple version of cursors. If we’re working with a server that follows the [Relay Cursor Connections spec](https://facebook.github.io/relay/graphql/connections.htm) (with `edges` and `node`s and `pageInfo`s), we can follow [this example](https://www.apollographql.com/docs/react/recipes/pagination.html#cursor-pages) for querying it.

#### after

Let’s implement a version of pagination that has the same information—last ID and sort order—but works within the Guide schema. We can see in [Playground](https://api.graphql.guide/play) that there are a couple of arguments we haven’t used yet—`after` and `orderBy`:

```gql
enum ReviewOrderBy {
  createdAt_ASC 
  createdAt_DESC
}

# To paginate, use page, skip & limit, or after & limit
reviews(limit: Int, page: Int, skip: Int, after: ObjID, orderBy: ReviewOrderBy): [Review!]
```

First, let’s use the last review’s ID for `after`, and remove `skip`:

[`src/components/ReviewList.js`](https://github.com/GraphQLGuide/guide/blob/18_0.2.0/src/components/ReviewList.js)

```js
export default () => {
  const { data, fetchMore, networkStatus } = useQuery(REVIEWS_QUERY, {
    variables: { limit: 10 },
    ...
  }

  ...

    if (closeToBottom && reviews.length > 0) {
      const lastId = reviews[reviews.length - 1].id

      fetchMore({ variables: { after: lastId } })
```

We also have to update the query:

[`src/graphql/Review.js`](https://github.com/GraphQLGuide/guide/blob/18_0.2.0/src/graphql/Review.js)

```js
query ReviewsQuery($after: ObjID, $limit: Int) {
  reviews(after: $after, limit: $limit) {
```

It works! And it’s so precise that we don’t have to worry about things getting added or deleted between `fetchMore`s. We could even switch our `merge` field policy back to `concatPagination`. One might be concerned about the possibility of the review we’re using as a cursor being deleted, but some server implementations cover this case—the Guide API is backed by MongoDB, which has IDs that are comparable based on order of creation, so the server can still find IDs that were created before or after the deleted ID.

#### orderBy

Next let’s figure out how to get sort order working as well. The two possible values are `createdAt_DESC` (newest reviews first, the default) and `createdAt_ASC`. If we put a “Newest/Oldest” select box in `<Reviews>`, then we can pass the value down to `<ReviewList>` to use in the query’s `variables`:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/blob/18_0.2.0/src/components/Reviews.js)

```js
import { MenuItem, FormControl, Select } from '@material-ui/core'

export default () => {
  const [orderBy, setOrderBy] = useState('createdAt_DESC')

  ...

  return (
    <main className="Reviews mui-fixed">
      <div className="Reviews-header-wrapper">
        <header className="Reviews-header">
          ...

          <FormControl>
            <Select
              value={orderBy}
              onChange={(e) => setOrderBy(e.target.value)}
              displayEmpty
            >
              <MenuItem value="createdAt_DESC">Newest</MenuItem>
              <MenuItem value="createdAt_ASC">Oldest</MenuItem>
            </Select>
          </FormControl>
        </header>
      </div>

      <ReviewList orderBy={orderBy} />
```          

In `<ReviewList>`, we need to use the new prop in the query:

[`src/components/ReviewList.js`](https://github.com/GraphQLGuide/guide/blob/18_0.2.0/src/components/ReviewList.js)

```js
export default ({ orderBy }) => {
  const { data, fetchMore, networkStatus } = useQuery(REVIEWS_QUERY, {
    variables: { limit: 10, orderBy },

  ...

    fetchMore({ variables: { after: lastId, orderBy } })
```

Testing it out, we find that nothing happens when we change the select input to “Oldest.” We can also see in the Network tab that no GraphQL request is sent. Since the `Query.reviews` field policy `keyArgs` is `false`, there is only a single entry in the cache for all sets of variables. And since this query is using the default `cache-first` fetch policy, Apollo looks in the cache for results that match, finds the existing entry (which was created when the “Newest” query was made on pageload), and returns it.

To fix this, we want separate entries in the cache for `orderBy: createdAt_DESC` and `orderBy: createdAt_ASC`. We tell Apollo to do this by changing `keyArgs: false`:

[`src/lib/apollo.js`](https://github.com/GraphQLGuide/guide/blob/18_0.2.0/src/lib/apollo.js)

```js
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        reviews: {
          merge ...
          keyArgs: ['orderBy'],
        },
```

The select input now works—when we change it to “Oldest”, the query variable updates, and a different list of reviews loads. When we go back to “Newest”, the original list immediately appears, because Apollo has that list cached under the original `orderBy`. We can see in devtools that both lists are indeed cached:

![Cache with orderBy](img/cache-with-orderBy.png)

However, we have another bug! Can you find it? 🔍🐞

When we switch to “Oldest” and create a new review, it appears at the top of the list as if it were the oldest review. But it’s the newest. Our `ADD_REVIEW_MUTATION` `cache.modify()` puts the new review at the beginning of the list. And when we have multiple `reviews` entries in our cache (since we changed `keyArgs`), our `cache.modify()` field functions are called once for each cache entry. So the new review is added to the top of both the `createdAt_DESC` entry and the `createdAt_ASC` entry. Let’s only add it to `createdAt_DESC` by checking the `storeFieldName`, which has the argument in it (for example, `reviews:{"orderBy":"createdAt_DESC"}` is the field name for the “Oldest” entry):

[`src/components/ReviewForm.js`](https://github.com/GraphQLGuide/guide/blob/18_0.2.0/src/components/ReviewForm.js)

```js
const [addReview] = useMutation(ADD_REVIEW_MUTATION, {
  update: (cache, { data: { createReview: newReview } }) => {
    cache.modify({
      fields: {
        reviews(existingReviewRefs = [], { storeFieldName }) {
          if (!storeFieldName.includes('createdAt_DESC')) {
            return existingReviewRefs
          }
          
          const newReviewRef = cache.writeFragment({
            data: newReview,
            fragment: gql`
              fragment NewReview on Review {
                id
                text
                stars
                createdAt
                favorited
                author {
                  id
                }
              }
            `,
          })

          return [newReviewRef, ...existingReviewRefs]
        },
      },
    })
  },
})
```

Fixed! 

The other mutation we have that modifies the reviews list is `REMOVE_REVIEW_MUTATION`. In that case, it’s helpful that our `cache.modify()` `reviews` function gets run on all `Query.reviews` cache entries. This means that if the deleted review is in both lists, it will be deleted from both.

## Client-side ordering & filtering

> If you’re jumping in here, `git checkout 18_0.2.0` (tag [`18_0.2.0`](https://github.com/GraphQLGuide/guide/tree/18_0.2.0)). Tag [`18-filtering_0.2.0`](https://github.com/GraphQLGuide/guide/tree/18-filtering_0.2.0) contains all the code written in this section.

We learned in the [pagination section](#skip-&-limit) that by default, Apollo creates a new cache entry when arguments change. To get pagination working, we configured the cache to only use a single entry with `keyArgs: false`. In the last section, we changed it to `keyArgs: ['orderBy']` so that we'd have two cache entries: one for each possible value of the `orderBy` argument.

In this section, we’ll add arguments to our `reviews` query that filter out some reviews. We’ll look at different options for `keyArgs` and add a [`read`](https://www.apollographql.com/docs/react/caching/cache-field-behavior/#handling-pagination) function to our field policy.

The last two available arguments for `Query.reviews` are `minStars: Int` and `minSentences: Int`. They filter on the number of stars and the number of sentences in the review text. Let’s add them to our query, along with select inputs to change the values. First, the query:

[`src/graphql/Review.js`](https://github.com/GraphQLGuide/guide/blob/18-filtering_0.2.0/src/graphql/Review.js)

```js
export const REVIEWS_QUERY = gql`
  query ReviewsQuery(
    $after: ObjID
    $limit: Int
    $orderBy: ReviewOrderBy
    $minStars: Int
    $minSentences: Int
  ) {
    reviews(
      after: $after
      limit: $limit
      orderBy: $orderBy
      minStars: $minStars
      minSentences: $minSentences
    ) {
      ...ReviewEntry
    }
  }
  ${REVIEW_ENTRY}
`
```

Next, the UI:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/blob/18-filtering_0.2.0/src/components/Reviews.js)

```js
export default () => {
  const [filters, setFilters] = useState({
    orderBy: 'createdAt_DESC',
    minStars: '1',
    minSentences: '1',
  })

  ...

  return (
    <main className="Reviews mui-fixed">
      <div className="Reviews-header-wrapper">
        <header className="Reviews-header">
          ...

          <FormControl>
            <Select
              value={filters.orderBy}
              onChange={(e) =>
                setFilters({ ...filters, orderBy: e.target.value })
              }
              displayEmpty
            >
              <MenuItem value="createdAt_DESC">Newest</MenuItem>
              <MenuItem value="createdAt_ASC">Oldest</MenuItem>
            </Select>

            <Select
              value={filters.minStars}
              onChange={(e) =>
                setFilters({ ...filters, minStars: e.target.value })
              }
              displayEmpty
            >
              <MenuItem value="1">1+ stars</MenuItem>
              <MenuItem value="2">2+ stars</MenuItem>
              <MenuItem value="3">3+ stars</MenuItem>
              <MenuItem value="4">4+ stars</MenuItem>
              <MenuItem value="5">5 stars</MenuItem>
            </Select>

            <Select
              value={filters.minSentences}
              onChange={(e) =>
                setFilters({
                  ...filters,
                  minSentences: e.target.value,
                })
              }
              displayEmpty
            >
              <MenuItem value="1">1+ sentences</MenuItem>
              <MenuItem value="2">2+ sentences</MenuItem>
              <MenuItem value="3">3+ sentences</MenuItem>
              <MenuItem value="4">4+ sentences</MenuItem>
              <MenuItem value="5">5+ sentences</MenuItem>
            </Select>
          </FormControl>
        </header>
      </div>

      <ReviewList {...filters} />
```

We pass all three arguments to `ReviewList`, which makes the query:

[`src/components/ReviewList.js`](https://github.com/GraphQLGuide/guide/blob/18-filtering_0.2.0/src/components/ReviewList.js)

```js
export default ({ orderBy, minStars, minSentences }) => {
  const variables = { limit: 10, orderBy }
  if (minStars) {
    variables.minStars = parseInt(minStars)
  }
  if (minSentences) {
    variables.minSentences = parseInt(minSentences)
  }

  const { data, fetchMore, networkStatus } = useQuery(REVIEWS_QUERY, {
    variables,
    errorPolicy: 'all',
    notifyOnNetworkStatusChange: true,
  })
```

If we test out our new code by loading [`localhost:3000/reviews`](http://localhost:3000/reviews) and selecting "5+ sentences," we find that the list of reviews shown on the page doesn’t change! This is due to a combination of two settings:

- The default cache-first fetch policy, in which Apollo first checks the cache for results, and if there are results, doesn’t query the server.
- `keyArgs: ['orderBy']`, which tells Apollo to just create new cache entries for `Query.reviews` when there are new values of the `orderBy` argument. 

When we select "5+ sentences," we’re updating the `minSentences` argument, but the `orderBy` argument stays the same, so Apollo looks in the cache for `Query.reviews` and finds the data saved from the query with the same `orderBy` that happened on pageload. Apollo returns that data and doesn’t query the server for more.

Now we know why the list of reviews isn’t changing. How can we get it to change? 

- Change the fetch policy to `network-only` and remove our `merge` function. Then whenever we changed an argument, Apollo would send the request to the server and replace the cache entry with the new result. This would result in a delay before the user sees the UI update, and it would break our pagination.
- Use `keyArgs: ['orderBy', 'minStars', 'minSentences']`. Then Apollo would create a new cache entry for each new set of ordering and filtering arguments (but not for pagination arguments). This would result in a delay in seeing results the first time we changed a filter, and then immediate updates when going back to a filter choice that’s cached. It would also result in a lot of cache entries with overlapping reviews.
- Use `keyArgs: false`, `fetchPolicy: cache-and-network`, and a [`read`](https://www.apollographql.com/docs/react/caching/cache-field-behavior/#handling-pagination) function. All reviews are placed into a single cache entry and we use a `read` function to order and filter reviews being read from the cache. Apollo will first display anything in the cache that matches the current arguments and will also send the request to the server in case there are more or updated results. 

The last is the solution that’s recommended for most lists that have sorting and filtering arguments, and it’s the one we’ll implement. Let’s start with the `read` function, which we add to the field policy:

[`src/lib/apollo.js`](https://github.com/GraphQLGuide/guide/blob/18-filtering_0.2.0/src/lib/apollo.js)

```js
import { countSentences } from './helpers'

const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        reviews: {
          merge ...,
          keyArgs: false,
          read(
            reviewRefs,
            { args: { orderBy, minStars, minSentences }, readField }
          ) {
            if (!reviewRefs) {
              return reviewRefs
            }

            const filtered = reviewRefs.filter((reviewRef) => {
              const stars = readField('stars', reviewRef),
                text = readField('text', reviewRef)
              return stars >= minStars && countSentences(text) >= minSentences
            })

            filtered.sort((reviewRefA, reviewRefB) => {
              const createdAtA = readField('createdAt', reviewRefA),
                createdAtB = readField('createdAt', reviewRefB)

              if (orderBy === 'createdAt_DESC') {
                return createdAtB - createdAtA
              } else {
                return createdAtA - createdAtB
              }
            })

            return filtered
          },
        },
      },
    },
  },
})
```

When Apollo Client reads data from the cache to provide to our `useQuery()` hooks, it will first go through this function. The first argument we receive is the list of review refs in the cache. The second argument contains the query’s `args` as well as the same helper functions provided to the `merge` function. First, we filter out reviews that don’t fit our two filter arguments. Then we sort the reviews by their `createdAt` according to the `orderBy` arg.

We use a `countSentences` helper function:

[`src/lib/helpers.js`](https://github.com/GraphQLGuide/guide/blob/18-filtering_0.2.0/src/lib/helpers.js)

```js
export const countSentences = (text) => {
  const matches = text.match(/\w[.?!](\s|$)/g)
  return matches ? matches.length : 1
}
```

And finally, we need to update the fetch policy:

[`src/components/ReviewList.js`](https://github.com/GraphQLGuide/guide/blob/18-filtering_0.2.0/src/components/ReviewList.js)

```js
const { data, fetchMore, networkStatus } = useQuery(REVIEWS_QUERY, {
  variables,
  errorPolicy: 'all',
  notifyOnNetworkStatusChange: true,
  fetchPolicy: 'cache-and-network',
})
```

And we’re done! Now, when we change a filter, we’ll immediately get any matching cached reviews, and then might see additional reviews when the query result arrives from the server. We’ll also see this behavior when changing the sort order: when we switch from the default "Newest" to "Oldest", we first see the newest 10 reviews in reverse order (so the oldest of the reviews in the cache), and then the absolute oldest reviews arrive from the server and are displayed first.

One last thing to note is that we can store any data structure in the cache—it doesn’t have to be an array. We just have to have a `read` function that returns an array. The runtime of our merge function could be improved by using a map: instead of returning an array to be stored in the cache, we return an object with `id` keys and review object values. Then we don’t have to search through an array to figure out whether an incoming review is already in the cache—we just add it to the map, and, if there was an existing object, it gets overwritten. We would need to modify our `read` function accordingly: the `reviewRefs` first argument coming from the cache would be a map, so we would do `Object.values(reviewRefs)` to get an array for filtering and sorting.

## Local state

Section contents:

* [Reactive variables](6.md#reactive-variables)
* [In cache](6.md#in-cache)

In most of the apps we build, the majority of our *state* (the data that backs our UI) is *remote state*—it comes from a server and is saved in a database. But some of our state doesn’t come from the server and isn’t stored in a database—it originates locally on the client and stays there. This type of data is called our *local state*. One example of local state is a user setting that for whatever reason we didn’t want to send to the server to persist. Another example is data from a device API: if we were making a navigation app, we would want to display the device’s location and speed. A simple solution would be to put the state in a variable, for instance `window.gps`:

```js
navigator.geolocation.watchPosition(position => {
  window.gps = position.coords
}
```

And then we’d reference that variable when we needed it. However, there are a couple of issues with this solution. One is that we’d like to be able to trigger view updates when the data changes. We could move it to a component’s `this.state`, but A) when the component is unmounted, we lose the data, and B) if we need the data in different places in the app, we’d have to pass it around as a prop a lot or use Context. The other issue is the lack of structure—with a large app and many developers, it gets hard to know what state is out there in variables scattered around the codebase, the data format of each variable, and how each should be modified. A popular solution that addresses both of these issues is [Redux](https://redux.js.org/), a library for maintaining global state. 

> *Global state* means state accessible from anywhere in your app, as opposed to *component state*, which is accessible as `this.state` inside the component in which it’s created, or as a prop if the data is passed to children. **Global vs component** state is tangential to **local vs remote** state. The former is about where on the client the state is kept, and the latter is about whether or not the data is stored on the server.

Redux provides a structure for reading and modifying data, and it re-renders components when the data changes. While Redux is great, Apollo has its own solution to local state which addresses the same issues. Choosing the system we’re already using for local state will make it simpler to implement and result in more understandable, concise code.

There are three ways to store local state with Apollo, and different ways to read it. We can store it in:

* [Reactive variables](6.md#reactive-variables)
* [The Apollo cache](6.md#in-cache)
* Anywhere else (for example `window` or `LocalStorage`)

Reactive variables can be read just by importing the variable into our code. The cache can be read with the cache methods [`cache.readQuery()`](https://www.apollographql.com/docs/react/caching/cache-interaction/#readquery) and [`cache.readFragment()`](https://www.apollographql.com/docs/react/caching/cache-interaction/#readfragment) or `useQuery()` by adding the `@client` [*directive*](2.md#directives) to our query:

```gql
query LocationQuery {
  gps @client {
    lat
    lng
  }
}
```

We can also use a field policy `read` function to supply `readyQuery/readFragment/useQuery` with any combination of data: reactive variables, cache data, LocalStorage, etc.

```js
const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        amalgam: {
          read: (amalgam) => myReactiveVar() + localStorage.getItem('myString') + amalgam
        },
      },
    },
  },
})

const myReactiveVar = makeVar('Amal')
localStorage.setItem('myString', 'ga')
cache.modify({
  fields: { amalgam: () => 'don' },
})

const { data } = useQuery(gql`
  query ExampleLocalQuery { 
    amalgam @client 
  }
`)

console.log(data)
// { amalgam: 'Amalgadon' }
```

Our read function combines 3 strings: a Reactive variable, a LocalStorage value, and a string stored in the cache. Whenever the `amalgam` query is made with the `@client` directive, the function is run to produce the result, and no request is sent to the server.

### Reactive variables

> If you’re jumping in here, `git checkout 18_0.2.0` (tag [`18_0.2.0`](https://github.com/GraphQLGuide/guide/tree/18_0.2.0)). Tag [`19_0.2.0`](https://github.com/GraphQLGuide/guide/tree/19_0.2.0) contains all the code written in this section.

A [reactive variable](https://www.apollographql.com/docs/react/local-state/reactive-variables/) can store any type of data, and when we change its value, any code that depends on it *reacts* to the change: 

- Any `useQuery` hook that selects a field with a `read` function that uses a reactive var (like the example just before this section) will provide a new `data` object to the React component, which gets re-rendered.
- The `useReactiveVar` hook that we’ll use in this section also provides a new value to the component.

We create a reactive var with `makeVar(initialValue)`:

```js
import { makeVar } from '@apollo/client'

const lastRouteVar = makeVar('home')
```

`makeVar()` returns a function that we call without arguments to get the value, and we call with an argument to change the value:

```js
console.log(lastRouteVar())
// home

lastRouteVar('profile')
console.log(lastRouteVar())
// profile
```

A place in our app where a simple piece of local state would be useful is during login. Right now, our `useUser()` hook provides a `loggingIn` boolean that’s true when the `currentUser` query is `loading`. But it would be more accurate if `loggingIn` were true as soon as the user clicks the “Sign in” button. If we had a piece of state that was true while the user went through the Auth0 login process, then we could update `loggingIn` to be `loading || loginInProgress`. Let’s create a reactive variable for it:

[`src/lib/auth.js`](https://github.com/GraphQLGuide/guide/blob/19_0.2.0/src/lib/auth.js)

```js
import { makeVar } from '@apollo/client'

export const loginInProgressVar = makeVar(false)
```

And let’s set it to `true` during login:

```js
export const login = () => {
  loginInProgressVar(true)

  auth0Login({
    onCompleted: (e) => {
      loginInProgressVar(false)
      if (e) {
        console.error(e)
        return
      }

      apollo.reFetchObservableQueries()
    },
  })
}
```

Now we can use it in our `useUser()` hook:

[`src/lib/useUser.js`](https://github.com/GraphQLGuide/guide/blob/19_0.2.0/src/lib/useUser.js)

```js
import { useReactiveVar } from '@apollo/client'

import { loginInProgressVar } from './auth'

export function useUser() {
  const { data, loading } = useQuery(USER_QUERY)

  const loginInProgress = useReactiveVar(loginInProgressVar)

  return {
    user: data && data.currentUser,
    loggingIn: loading || loginInProgress,
  }
}
```

If we did `loggingIn: loading || loginInProgressVar()`, then the function wouldn’t be rerun when the var changed. So we use the `useReactiveVar()` hook instead.

Now it’s working—when we click the “Sign in” button, we can see the spinner while the Auth0 popup is open and before our `USER_QUERY` is sent 😊.

### In cache

> If you’re jumping in here, `git checkout 19_0.2.0` (tag [`19_0.2.0`](https://github.com/GraphQLGuide/guide/tree/19_0.2.0)). Tag [`20_0.2.0`](https://github.com/GraphQLGuide/guide/tree/20_0.2.0) contains all the code written in this section.

We can also store local state in the cache: we can add client-side root query fields, new objects, or new fields to existing objects. In this section, we’ll add a field to existing objects (`Section` objects) that were fetched from the server.

Currently, whenever we switch between sections, one of two things happens to our scroll position:

- If we don’t have the section content on the client, `scrollY` is set to 0 when the loading skeleton is displayed.
- If we do have the section content on the client, `scrollY` remains the same.

It would be nice for the user if, when switching back to a section they were previously reading, the scroll position updates to where they were. So let’s save their last position for each section in local state! While we could use [reactive variables](#reactive-variables), it will be easier to manage if the position is co-located with the section data. We can add a `scrollY` field to each `Section` object that’s been read. We write the field using [`writeFragment()`](https://www.apollographql.com/docs/react/api/core/ApolloClient/#ApolloClient.writeFragment):

```js
cache.writeFragment({
  id: `Section:${id}`,
  fragment: gql`
    fragment SectionScrollBy on Section {
      scrollY
    }
  `,
  data: {
    scrollY: 100,
  },
})
```

And we read it by adding the `scrollY` field to our queries:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/20_0.2.0/src/components/Section.js)

```js
const SECTION_BY_ID_QUERY = gql`
  query SectionContent($id: String!) {
    section(id: $id) {
      id
      content
      views
      scrollY @client
    }
  }
`

const SECTION_BY_CHAPTER_TITLE_QUERY = gql`
  query SectionByChapterTitle($title: String!) {
    chapterByTitle(title: $title) {
      title
      section(number: 1) {
        id
        content
        views
        scrollY @client
      }
    }
  }
`

const SECTION_BY_NUMBER_QUERY = gql`
  query SectionByNumber($chapterNumber: Int!, $sectionNumber: Int!) {
    chapterByNumber(number: $chapterNumber) {
      number
      section(number: $sectionNumber) {
        id
        number
        title
        content
        views
        scrollY @client
      }
    }
  }
`
```

We use the field in `useLayoutEffect()` to set the window’s scroll position to the saved position:

```js
const { data, loading } = useQuery(query, { variables })

const section = ...

const currentScrollY = get(section, 'scrollY')
useLayoutEffect(() => {
  if (currentScrollY === undefined || currentScrollY === window.scrollY) {
    return
  }

  window.scrollTo(0, currentScrollY)
}, [currentScrollY])
```

Lastly, we need to decide when to call `cache.writeFragment()` and save the scroll position. Let’s do it a second after the user stops scrolling (using [debounce()](https://lodash.com/docs/4.17.15#debounce)), provided they haven’t switched sections:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/20_0.2.0/src/components/Section.js)

```js
import debounce from 'lodash/debounce'

import { cache } from '../lib/apollo'

const updateScrollY = debounce((scrollY) => {
  const scrollHasChangedSinceLastEvent = scrollY !== window.scrollY
  const scrollNeedsToBeUpdated = scrollY !== section.scrollY

  if (scrollHasChangedSinceLastEvent || !scrollNeedsToBeUpdated) {
    return
  }

  cache.writeFragment({
    id: `Section:${id}`,
    fragment: gql`
      fragment SectionScrollBy on Section {
        scrollY
      }
    `,
    data: {
      scrollY,
    },
  })
}, 1000)

useLayoutEffect(() => {
  const onScroll = () => updateScrollY(window.scrollY)

  window.addEventListener('scroll', onScroll)
  return () => window.removeEventListener('scroll', onScroll)
}, [updateScrollY])
```

When the component mounts, we add the scroll listener, and on unmount, we remove the listener. For performance, we [debounce](https://css-tricks.com/the-difference-between-throttling-and-debouncing/) the listener (we prevent it from being called continuously, waiting until the user has stopped scrolling for a second). Then inside the listener, we call the mutation (first checking to make sure the `scrollY` has changed).

When we test it out, we get the message: `TypeError: Cannot read property 'toLocaleString' of undefined` referring to this line of `<Section>`:

```js
footerContent = `Viewed ${section.views.toLocaleString()} times`
```

`section` is undefined because the `data` returned from `useQuery()` is undefined. Apollo returns undefined `data` when it can’t read an `@client` field. So we need to provide a default value:

[`src/lib/apollo.js`](https://github.com/GraphQLGuide/guide/blob/20_0.2.0/src/lib/apollo.js)

```js
export const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        reviews: { ... }
      },
    },
    Section: {
      fields: {
        scrollY: (scrollY) => scrollY || 0,
      },
    },
  },
})
```

It now works! When we scroll, wait a second, go to another section, and go back, our scroll position is restored. And we can see the new `scrollY` property in the devtools cache:

![Section:preface in the cache with a scrollY field](img/scrollY-in-cache.png)

If we want to document our new ability to query `Section.scrollY` (for our teammates or forgetful future selves 🤗), we can add a client-side schema:

[`src/lib/apollo.js`](https://github.com/GraphQLGuide/guide/blob/20_0.2.0/src/lib/apollo.js)

```js
import { gql } from '@apollo/client'

const typeDefs = gql`
  extend type Section {
    scrollY: Int
  }
`

export const apollo = new ApolloClient({ link, cache, typeDefs })
```

Now `scrollY` is included in devtools GraphiQL schema Docs:

![scrollY added to the devtools GraphiQL Docs](img/apollo-devtools-docs-scrollY.png)

## REST

> If you’re jumping in here, `git checkout 20_0.2.0` (tag [`20_0.2.0`](https://github.com/GraphQLGuide/guide/tree/20_0.2.0)). Tag [`21_0.2.0`](https://github.com/GraphQLGuide/guide/tree/21_0.2.0) contains all the code written in this section.

You might be thinking, “What is a section on REST doing in a chapter on GraphQL client dev??” The thing is, not all of our colleagues have seen the light of GraphQL yet, so they’re still making REST APIs! 😉 And we might want to use them in our app. The common solution is for your backend GraphQL server to proxy the REST API. For example, the server will add a query to the schema:

```gql
type Query {
  githubStars
  ...
  latestSatelliteImage(lon: Float!, lat: Float!, sizeInDegrees: Float): String
}
```

And we would write our client query:

```gql
query WhereAmI {
  latestSatelliteImage(lon: -73.94, lat: 40.7, sizeInDegrees: 0.3)
}
```

And when the server received our query, it would send this GET request to NASA:

https://api.nasa.gov/planetary/earth/imagery/?lon=-73.94&lat=40.7&dim=0.3&api_key=DEMO_KEY

The server would get back a URL of an image, which it would return to us, which we would put in the `src` of an `<img>` tag:

![Satellite image of Brooklyn and Manhattan](/img/satellite-image.png)

So that’s how proxying through our GraphQL backend works (and we’ll go into more detail in the server chapter). But what if our backend can’t proxy the REST API? Maybe we don’t have control over the backend, or maybe some less common reason applies, like needing to reduce load on the server or needing better latency (proxying through the server is slightly slower). In that case, we can use [`apollo-link-rest`](https://www.apollographql.com/docs/link/links/rest.html) to send some of our GraphQL queries as REST requests to a REST API instead of to our GraphQL server!

We need to find a REST API to use in our Guide app so that we can learn by example in this section of the book 😜. Displaying a satellite image isn’t useful, but displaying the temperature in the header might conceivably be useful (albeit completely unrelated to GraphQL 😄). If we google “weather api”, the first result is OpenWeatherMap, and we see that it’s free to use—great. Now we want to open up Playground to look at the OpenWeatherMap’s schema to figure out which query to use. But it’s a REST API! And REST doesn’t have a specified way of reporting what the API can do, so we can’t have a standard tool like Playground that shows us. So we have to read their docs. Let’s use their [current weather data](https://openweathermap.org/current) endpoint, `api.openweathermap.org/data/2.5/weather`, which looks like it has a number of options for specifying the location with query parameters: 

- `?q=[city name]`
- `?id=[city id]`
- `?lat=[latitude]&lon=[longitude]`
- `?zip=[zip code]`

Which one can we use? We don’t know the client’s city or GPS coordinates or zip code... so at the moment, none of them! There are a couple of ways, though, to get the user’s location: 

- Query an IP geolocation API, which looks up the client’s IP in a database and returns that IP’s city and approximate coordinates.
- Use the web standard [geolocation API](https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API), which according to [caniuse](https://caniuse.com/#search=geolocation) works in all browsers after IE 8! Except for Opera Mini 😄.

The browser API is more precise, easier to code, and gets the user’s consent via a built-in permission dialog. So let’s do that. All we need to do is just `navigator.geolocation.getCurrentPosition`, and after the user approves, we get the coordinates in a callback:

```js
window.navigator.geolocation.getCurrentPosition(
  ({ coords: { latitude, longitude } }) => {
    console.log(latitude, longitude)
    // logs: 40.7 -73.94
  }
)
```

Now we have numbers to put into our URI format, which was:

`api.openweathermap.org/data/2.5/weather?lat=[latitude]&lon=[longitude]`

And we also need an API key, which their docs say should go in an `appid` query param. The full URL, broken down:

```
http://
api.openweathermap.org
/data/2.5/weather
?lat=40.7
&lon=-73.94
&appid=4fb00091f111862bed77432aead33d04
```

And the link:

[http://api.openweathermap.org/data/2.5/weather?lat=40.7&lon=-73.94&appid=4fb00091f111862bed77432aead33d04](http://api.openweathermap.org/data/2.5/weather?lat=40.7&lon=-73.94&appid=4fb00091f111862bed77432aead33d04)

> If this API key is over its limit, you can [get a free one here](https://home.openweathermap.org/users/sign_up).

We get a response like this:

```json
{
  "coord": { "lon": -73.94, "lat": 40.7 },
  "weather": [
    {
      "id": 803,
      "main": "Clouds",
      "description": "broken clouds",
      "icon": "04n"
    }
  ],
  "base": "stations",
  "main": {
    "temp": 283.59,
    "pressure": 1024,
    "humidity": 66,
    "temp_min": 280.95,
    "temp_max": 285.95
  },
  "visibility": 16093,
  "wind": { "speed": 2.26, "deg": 235.503 },
  "clouds": { "all": 75 },
  "dt": 1539575760,
  "sys": {
    "type": 1,
    "id": 2121,
    "message": 0.0044,
    "country": "US",
    "sunrise": 1539601626,
    "sunset": 1539641711
  },
  "id": 5125125,
  "name": "Long Island City",
  "cod": 200
}
```

That’s a lot of stuff. Since it’s not GraphQL, we didn’t know what we were going to get back until we tried it, unless we were able to find it in their docs (which author Loren did, eventually—under the heading “Weather parameters in API respond”). Looking through the response JSON, we find `main.temp`, which is a weirdly high number, so we might suspect it’s Kelvin, and we can search the docs to confirm. (In a GraphQL API, this could have been included in a schema comment, and we wouldn’t have had to search 😎.) 

If we didn’t have Apollo, we would use [`fetch()`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) or [`axios.get()`](https://github.com/axios/axios#example) to make the HTTP request:

```js
const weatherEndpoint = 'http://api.openweathermap.org/...'
const response = await fetch(weatherEndpoint)
const data = await response.json();
console.log(`It is ${data.main.temp} degrees Kelvin`);
```

[Run in browser](https://codesandbox.io/s/814v12k739?expanddevtools=1&module=%2Fsrc%2Findex.js)

And we would use component lifecycle methods and `setState` to get the returned data into our JSX. Or if we wanted the data cached so that we can use it in other components or on future instances of the current component, or if we wanted all of our data fetching logic separated from our presentational components, we might use [Redux](https://redux.js.org/) instead.

However, with [`apollo-link-rest`](https://www.apollographql.com/docs/link/links/rest.html) we can get Apollo to make the HTTP request for us, cache the response data for future use, and provide the data to our components. 

Before we set up the link, `apollo.js` is getting long. Let’s move all the existing link code to a new file `link.js` so that we can simplify `apollo.js`:

[`src/lib/apollo.js`](https://github.com/GraphQLGuide/guide/blob/21_0.2.0/src/lib/apollo.js)

```js
import { ApolloClient, InMemoryCache, gql } from '@apollo/client'
import find from 'lodash/find'

import link from './link'

export const cache = new InMemoryCache({ ... })

const typeDefs = ...

export const apollo = new ApolloClient({ link, cache, typeDefs })
```

Now we set up the new link:

[`src/lib/link.js`](https://github.com/GraphQLGuide/guide/blob/21_0.2.0/src/lib/link.js)

```js
import { ApolloLink } from '@apollo/client'
import { RestLink } from 'apollo-link-rest'

...

const restLink = new RestLink({
  uri: 'https://api.openweathermap.org/data/2.5/'
})

const link = ApolloLink.from([errorLink, restLink, networkLink])
```

Since requests flow from left to right in the link chain, we want our `restLink` to be to the left of `networkLink` (it won’t pass on REST requests to `networkLink`, which would send them to our GraphQL server). And since responses (and errors) flow from right to left, we want `restLink` to be to the right of `errorLink` so that errors from `restLink` go through `errorLink`.

Let’s add a temperature component in the header:

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/blob/21_0.2.0/src/components/App.js)

```js
import CurrentTemperature from './CurrentTemperature'

...

<header className="App-header">
  <StarCount />
  <Link ... />
  <CurrentUser />
  <CurrentTemperature />
</header>
```

And now for its implementation. Let’s start with the query:

```gql
{
  weather(lat: $lat, lon: $lon)
    @rest(
      type: "WeatherReport"
      path: "weather?appid=4fb00091f111862bed77432aead33d04&{args}"
    ) {
    main
  }
}
```

Anything with the `@rest` [directive](2.md#directives) `apollo-link-rest` will resolve itself. We’ve already configured the link with the base of the URI, so here we give the rest of it. Since we’re getting back an object, we also need to make up a name for what the object’s type will be in the Apollo cache. And we want the `"main"` attribute from the JSON response, so `{ main }` is our selection set.

If we want to be even more explicit about which data we’re using, we could select just `main.temp` instead of the whole `main` object. But when we want to select fields in objects, we need the object to have a type, so we add an `@type` directive:

```gql
query TemperatureQuery {
  weather(lat: $lat, lon: $lon)
    @rest(
      type: "WeatherReport"
      path: "weather?appid=4fb00091f111862bed77432aead33d04&{args}"
    ) {
    main @type(name: "WeatherMain") {
      temp
    }
  }
}
```

Now let’s think about the UX. At some point, we need to call `window.navigator.geolocation.getCurrentPosition`, after which the browser prompts the user to share their location. We don’t want to annoy users with this prompt every time they use the app, so let’s start out with a button and go through these steps:

- Display location button
- User clicks button and we request their location from the browser
- User gives permission through browser dialog
- We receive the location and make the query
- We receive the query results and display them

Here’s the shell of our component with that logic and our lat/lon state:

[`src/components/CurrentTemperature.js`](https://github.com/GraphQLGuide/guide/blob/21_0.2.0/src/components/CurrentTemperature.js)

```js
import React, { useState } from 'react'
import { useQuery, gql } from '@apollo/client'
import { IconButton } from '@material-ui/core'
import { MyLocation } from '@material-ui/icons'

const TEMPERATURE_QUERY = gql`
  query TemperatureQuery {
    weather(lat: $lat, lon: $lon)
      @rest(
        type: "WeatherReport"
        path: "weather?appid=4fb00091f111862bed77432aead33d04&{args}"
      ) {
      main
    }
  }
`

function Content() {
  const [position, setPosition] = useState(null)

  function requestLocation() { ... }

  const haveLocation = !!position

  const { data, loading } = useQuery(TEMPERATURE_QUERY, {
    skip: !haveLocation,
    variables: position,
  })

  if (!haveLocation) {
    return (
      <IconButton
        className="Weather-get-location"
        onClick={requestLocation}
        color="inherit"
      >
        <MyLocation />
      </IconButton>
    )
  }

  return data.weather.main.temp
}

export default () => (
  <div className="Weather">
    <Content />
  </div>
)
```

When we don’t yet have the user’s location, we skip running the query and show the location button. Once we do have the location, we pass it to our query and display `data.weather.main.temp`. 

![A location button displayed in the header](/img/location-button.png)

It would be nice to display a spinner while we’re waiting for the location and the weather API, so let’s fill in `requestLocation()` and add `gettingPosition` to the state:

```js
function Content() {
  const [position, setPosition] = useState(null)
  const [gettingPosition, setGettingPosition] = useState(false)

  function requestLocation() {
    setGettingPosition(true)
    window.navigator.geolocation.getCurrentPosition(
      ({ coords: { latitude, longitude } }) => {
        setGettingPosition(false)
        setPosition({
          lat: latitude,
          lon: longitude,
        })
      }
    )
  }

  ...
  
  if (loading || gettingPosition) {
    return <div className="Spinner" />
  }
```

![Loading spinner in place of the location button](/img/loading-temperature.png)

And now it works, and we’re reminded that the API returns Kelvin, so let’s show it in Celsius and Fahrenheit (and default to the former, because it’s just silly that the latter is still in use 😆):

```js
const kelvinToCelsius = kelvin => Math.round(kelvin - 273.15)
const kelvinToFahrenheit = kelvin =>
  Math.round((kelvin - 273.15) * (9 / 5) + 32)

function Content() {
  const [displayInCelsius, setDisplayInCelsius] = useState(true)

  ...

  const kelvin = data.weather.main.temp
  const formattedTemp = displayInCelsius
    ? `${kelvinToCelsius(kelvin)} °C`
    : `${kelvinToFahrenheit(kelvin)} °F`

  return (
    <IconButton onClick={() => setDisplayInCelsius(!displayInCelsius)}>
      {formattedTemp}
    </IconButton>
  )
}
```

![Temperature in Celsius](/img/temperature.png)

To recap, we added `@rest` to our root query field, which made our REST link intercept the query before it was sent to our GraphQL server. The REST link returns data from the weather REST API, which gets saved to our cache and provided to our component. We get all the nice things we’re used to in Apollo, like declarative data fetching and loading state. And because the data is in the cache, we can reuse the data in other components, and we can update the data (through re-querying or direct writes), and our components will automatically update.

## Review subscriptions

> If you’re jumping in here, `git checkout 21_0.2.0` (tag [`21_0.2.0`](https://github.com/GraphQLGuide/guide/tree/21_0.2.0)). Tag [`22_0.2.0`](https://github.com/GraphQLGuide/guide/tree/22_0.2.0) contains all the code written in this section.

Section contents:

* [Subscription component](6.md#subscription-component)
* [Add new reviews](6.md#add-new-reviews)
* [Update on edit and delete](6.md#update-on-edit-and-delete)

Early on in this chapter we set up our [first subscription](#subscriptions) for an updated GitHub star count. That was a very simple example—each event we received from the server contained a single integer:

```gql
type Subscription {
  githubStars: Int
}
```

In this section we’ll see what it’s like to work with more complex subscriptions:

```gql
type Subscription {
  reviewCreated: Review
  reviewUpdated: Review
  reviewDeleted: ObjID
}
```

The first subscription sends a response event when someone creates a new review. `reviewUpdated` fires whenever a review’s text or stars are edited, and `reviewDeleted` fires when one is deleted. For the first two, the events contain the review created/updated. For the last, it contains just the review’s id.

In general, we recommend re-querying in lieu of subscriptions—either by [polling](6.md#polling) or manually re-running the query with [`client.query()`](https://www.apollographql.com/docs/react/api/core/ApolloClient/#ApolloClient.query). In our app, it would be sufficient and easier to add polling to our reviews query:

`src/components/ReviewList.js`

```js
const { data, fetchMore, networkStatus } = useQuery(REVIEWS_QUERY, {
  variables: { limit: 10, orderBy },
  errorPolicy: 'all',
  notifyOnNetworkStatusChange: true,
  pollInterval: 5000
})
```

If we didn’t want to learn more about subscriptions, we’d just be doing the above.

We recommend using subscriptions when polling becomes a performance bottleneck: perhaps the amount of data being queried is large, or updates are needed every 500ms and that many queries tax the servers. Or it’s something real-time like a game, and the lowest possible latency is required (sending a message over an already-established WebSocket connection is faster than even `pollInterval: 1`, since polling creates a new network connection for each request).

### useSubscription

The first feature we’ll build is a notification when the user is on the reviews page and a new review is created:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/blob/22_0.2.0/src/components/Reviews.js)

```js
import ReviewCreatedNotification from './ReviewCreatedNotification'

<main className="Reviews mui-fixed">
  ...

  <ReviewList orderBy={orderBy} />

  <ReviewCreatedNotification />
```

Now that we’ve got a `<ReviewCreatedNotification>` on the reviews page, what do we put in it? Apollo has a [`useSubscription()`](https://www.apollographql.com/docs/react/api/react/hooks/#usesubscription) hook that provides new data whenever an event is received from the server:

[`src/components/ReviewCreatedNotification.js`](https://github.com/GraphQLGuide/guide/blob/22_0.2.0/src/components/ReviewCreatedNotification.js)

```js
import React from 'react'
import { useSubscription } from '@apollo/client'
import get from 'lodash/get'

import { ON_REVIEW_CREATED_SUBSCRIPTION } from '../graphql/Review'

export default () => {
  const { data } = useSubscription(ON_REVIEW_CREATED_SUBSCRIPTION)
  console.log(data)
  return null
}
```

We’ll see what the event looks like in a moment, but first we need the subscription itself:

[`src/graphql/Review.js`](https://github.com/GraphQLGuide/guide/blob/22_0.2.0/src/graphql/Review.js)

```js
export const ON_REVIEW_CREATED_SUBSCRIPTION = gql`
  subscription onReviewCreated {
    reviewCreated {
      ...ReviewEntry
    }
  }
  ${REVIEW_ENTRY}
`
```

And now we can see what happens when we create a review:

- Apollo sends the `createReview` mutation to the server
- The server sends a subscription response event with data
- `useSubscription()` gives us the data, and we log it:

```json
{
  "reviewCreated": {
    "id": "5c4b732bcd0a7103471de19b",
    "text": "It's good",
    "stars": 4,
    "createdAt": 1548448555245,
    "favorited": false,
    "author": {
      "id": "5a3cd78368e9c40096ab5e3f",
      "name": "Loren Sands-Ramshaw",
      "photo": "https://avatars2.githubusercontent.com/u/251288?v=4",
      "username": "lorensr",
      "__typename": "User"
    },
    "__typename": "Review"
  }
}
```

The data is in the same format we would expect if we made a Query named `reviewCreated`. We can also see the data arriving from the server. First let’s see what it looks like initially by opening the Network tab of devtools, refreshing the page, scrolling down to “subscriptions” on the left, and selecting the “Frames” tab:

![Four websocket messages](img/subscription-start.png)

We see that the first message the client always sends once the websocket is established has `type: "connection_init"`. Then it sends two messages, each with an operation and sequential `id` numbers. They are `type: "start"` because they are starting subscriptions. The message with `"id": "1"` has our GitHub stars subscription and the message with `id: "2"` has our `onReviewCreated` subscription, which we see in `payload.query`. There’s also a `payload.variables` field that we’re not using. If we were subscribing to a review’s comments, we might use a `commentCreated(review: ObjID!): Comment` subscription, in which case we would see:

```js
{
  id: "3",
  payload: {
    operationName: "onCommentCreated",
    query: "subscription onCommentCreated {↵ commentCreated(review: $review) {↵ id↵ text↵} }",
    variables: { review: "5c4bb280cd0a7103471de19e" }
  },
  type: "start"
}
```

The last websocket message is from the server and has `type: "connection_ack"`, which means that the server acknowledges that it has received the `connection_init` message.

Now let’s create a review and see what happens:

![Message containing the new review appears](img/websocket-data.png)

We receive another message from the server—this one with `type: "data"`, meaning it contains data! 😜 The ID is 2, telling us that it’s an event from the `onReviewCreated` subscription (which we sent to the server earlier with the matching `id: "2"`). And this time the `payload` is the same `data` object that the `<Subscription>` component gave us and we logged to the console. 

But our users usually won’t see messages logged to the console, so let’s think about how we want to display the new review notification to the user. We could `window.alert()`, but that requires dismissal and is annoying 😆. We could put it on the page—for example in the header—but then the notification would be stuck there until either a new subscription event arrived or the page got re-rendered. It doesn’t need to be shown for long, taking up the user’s brainspace and annoying them (at least Loren is annoyed when he can’t dismiss a notification 😄). So let’s show a temporary message somewhere off to the side. We can search the Material UI [component library](https://material-ui.com/demos/app-bar/) and find the component meant for this purpose—the [Snackbar](https://material-ui.com/demos/snackbars/). We control whether it’s visible with an `open` prop, so we need state for that, and the `onClose` prop gets called when the user dismisses the Snackbar.

[`src/components/ReviewCreatedNotification.js`](https://github.com/GraphQLGuide/guide/blob/22_0.2.0/src/components/ReviewCreatedNotification.js)

```js
import React, { useState } from 'react'
import { useSubscription } from '@apollo/client'
import { Snackbar } from '@material-ui/core'
import get from 'lodash/get'

import { ON_REVIEW_CREATED_SUBSCRIPTION } from '../graphql/Review'

export default () => {
  const [isOpen, setIsOpen] = useState(false)

  const { data } = useSubscription(ON_REVIEW_CREATED_SUBSCRIPTION, {
    onSubscriptionData: () => {
      setIsOpen(true)
      setTimeout(() => setIsOpen(false), 5000)
    },
  })

  const review = get(data, 'reviewCreated')
  return review ? (
    <Snackbar
      anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      open={isOpen}
      onClose={() => setIsOpen(false)}
      message={`New review from ${review.author.name}: ${review.text}`}
    />
  ) : null
}
```

We use `isOpen` for the state. We want to set `isOpen` to true whenever we receive a new event, so we use the `onSubscriptionData` option. And we want to automatically dismiss the Snackbar after a few seconds, so we use a `setTimeout()`. Now when we create a review, a message slides up from the bottom of the window, stays for a few seconds, and then slides back down!

![Review created notification](/img/review-created.gif)
[*gif: Review created notification*](http://res.cloudinary.com/graphql/guide/review-created.gif)

### Add new reviews

Currently when we create a review, the new review card appears at the top of the list on our page because of our optimistic update. But other users just see the notification—the review card doesn’t appear in the list. 
Let’s figure out how to get it there.

We could use our existing `ON_REVIEW_CREATED_SUBSCRIPTION` to add the new review to the list. `onSubscriptionData` is called with these arguments: `{ client, subscriptionData }`, so we could get the new review (`subscriptionData.data.reviewCreated`) and write it to the cache using `client.writeQuery()`. 

However, there’s another way that’s better suited to this case: the same `subscribeToMore` prop we used for `StarCount.js`. The query we want to use `subscribeToMore` with is `REVIEWS_QUERY`, our list of reviews. We get the previous query result and the subscription data, and then we return a new query result:

`src/components/ReviewList.js`

```js
import {
  REVIEWS_QUERY,
  ON_REVIEW_CREATED_SUBSCRIPTION,
} from '../graphql/Review'

export default ({ orderBy }) => {
  const { data, fetchMore, networkStatus, subscribeToMore } = useQuery(
    REVIEWS_QUERY,
    {
      variables: { limit: 10, orderBy },
      errorPolicy: 'all',
      notifyOnNetworkStatusChange: true,
    }
  )

  useEffect(() => {
    subscribeToMore({
      document: ON_REVIEW_CREATED_SUBSCRIPTION,
      updateQuery: (prev, { subscriptionData }) => {
        // Assuming infinite reviews, we don't need to add new reviews to
        // Oldest list
        if (orderBy === 'createdAt_ASC') {
          return prev
        }

        const newReview = subscriptionData.data.reviewCreated
        return {
          reviews: [newReview, ...prev],
        }
      },
    })
  }, [orderBy, subscribeToMore])
```

Here we add the new review to the beginning of the list. This code actually doesn’t work! It *would* work if we didn’t have a `merge` function on `Query.reviews`. Since we do, the `merge` function removes all the duplicate reviews (`...prev`) and adds the new review to the *end* of the list. 

TODO cc @benjamn https://github.com/apollographql/apollo-feature-requests/issues/270

```js
useEffect(() => {
  subscribeToMore({
    document: ON_REVIEW_CREATED_SUBSCRIPTION,
    updateQuery: (prev, { subscriptionData }) => {
      cache.modify({
        fields: {
          reviews(existingReviewRefs = [], { storeFieldName }) {
            if (!storeFieldName.includes('createdAt_DESC')) {
              return existingReviewRefs
            }

            const newReview = subscriptionData.data.reviewCreated

            const newReviewRef = cache.writeFragment({
              data: newReview,
              fragment: gql`
                fragment NewReview on Review {
                  id
                  text
                  stars
                  createdAt
                  favorited
                  author {
                    id
                  }
                }
              `,
            })

            return [newReviewRef, ...existingReviewRefs]
          },
        },
      })
      return prev
    },
  })
}, [orderBy, subscribeToMore])
```



Now when we’re viewing the most recent reviews (`createdAt_DESC`) and receive a subscription event, we add the new review to the front of the list of reviews, and it appears first on the page. We can test this out by opening a second browser tab, creating a new review in that tab, and seeing it immediately appear in the first tab.

### Update on edit and delete

It would also be nice to see updates to reviews when someone else edits or deletes them. If we look at the Playground schema, we can see that the server has more subscription options related to reviews: `reviewUpdated: Review` and `reviewDeleted: ObjID`. So let’s use ’em! Step 1 is writing the subscription documents and step 2 is adding more calls to `subscribeToMore`. (`subscribeToMore` doesn’t mean that we’re necessarily subscribing to new documents—just that we’re subscribing to more related data, and, in this case, the data is either the review that was updated or the ID of the review that was deleted.) First, the documents:

[`src/graphql/Review.js`](https://github.com/GraphQLGuide/guide/blob/22_0.2.0/src/graphql/Review.js)

```js
export const ON_REVIEW_UPDATED_SUBSCRIPTION = gql`
  subscription onReviewUpdated {
    reviewUpdated {
      ...ReviewEntry
    }
  }
  ${REVIEW_ENTRY}
`

export const ON_REVIEW_DELETED_SUBSCRIPTION = gql`
  subscription onReviewDeleted {
    reviewDeleted
  }
`
```

Because the return type of `reviewDeleted` is a scalar (a custom one called `ObjID`), we don’t write a selection set. `subscriptionData.data.reviewDeleted` will be an `ObjID` string, not an object. Next, `subscribeToMore`:

TODO cc @benjamn https://github.com/apollographql/apollo-feature-requests/issues/270
convert below to hooks

[`src/components/ReviewList.js`](https://github.com/GraphQLGuide/guide/blob/22_0.2.0/src/components/ReviewList.js)

```js
import reject from 'lodash/reject'

import {
  REVIEWS_QUERY,
  REVIEW_ENTRY,
  ON_REVIEW_CREATED_SUBSCRIPTION,
  ON_REVIEW_UPDATED_SUBSCRIPTION,
  ON_REVIEW_DELETED_SUBSCRIPTION
} from '../graphql/Review'

...

const withReviews = graphql(REVIEWS_QUERY, {
  options: ...,
  props: ({
    data: { reviews, fetchMore, networkStatus, subscribeToMore },
    ownProps: { orderBy }
  }) => ({
    reviews,
    networkStatus,
    loadMoreReviews: ...,
    subscribeToReviewUpdates: () => {
      subscribeToMore({
        document: ON_REVIEW_CREATED_SUBSCRIPTION,
        updateQuery: ...
      })
      subscribeToMore({
        document: ON_REVIEW_UPDATED_SUBSCRIPTION,
        updateQuery: (prev, { subscriptionData }) => {
          const updatedReview = subscriptionData.data.reviewUpdated
          return {
            reviews: prev.reviews.map(review =>
              review.id === updatedReview.id ? updatedReview : review
            )
          }
        }
      })
      subscribeToMore({
        document: ON_REVIEW_DELETED_SUBSCRIPTION,
        updateQuery: (prev, { subscriptionData }) => {
          const deletedId = subscriptionData.data.reviewDeleted
          return {
            reviews: reject(prev.reviews, { id: deletedId })
          }
        }
      })
    }
  })
})
```

For review updates, we replace the review in the list from the cache (`prev`) with the updated one we get from the subscription. For deletions, we remove it from the list.

## Prefetching

Background: [browser performance](bg.md#browser-performance)

Section contents:

* [On mouseover](6.md#on-mouseover)
* [Cache redirects](6.md#cache-redirects)

Prefetching is fetching data from the server before we need it so that when we do need it, we already have it on the client and can use it right away. This is great for UX because the user doesn’t have to look at a loading screen waiting for data to load. It’s a common pattern—both [Gatsby](https://www.gatsbyjs.org/docs/gatsby-link/) and [Next.js](https://nextjs.org/docs/#prefetching-pages) prefetch entire webpages with their `<Link>` components.

The most useful thing to prefetch in our app is the section content! We can prefetch just by making a query with the Apollo client:

```js
client.query({
  query: ...
})
```

This will place the results in the cache, so that when we render a `<Section>` and it makes a query for section data, it will immediately find the data in the cache. We could prefetch all the sections using the `sections` root query field:

```js
import React, { useEffect } from 'react'
import { gql, useApolloClient } from '@apollo/client'

const ALL_SECTIONS = gql`
  query AllSections {
    sections {
      id
      content
      views
    }
  }
`

function App() {
  const client = useApolloClient()
  
  useEffect(
    () =>
      requestIdleCallback(() =>
        client.query({
          query: ALL_SECTIONS,
        })
      ),
    [client]
  )

  return <div className="App">...</div>
}
```

For the query selection set, we check the queries in `Section.js` and see that it needs the `content` and `views`. We use `useApolloClient()` to get access to the client instance, and we use `requestIdleCallback()` (which calls the callback when the browser isn’t busy) so that we don’t delay any of the work involved with the initial app render. When the `AllSections` query response arrives, the data is put in the cache, and any future render of `<Section>` is immediate, without need to talk to the server.

### On mouseover

> If you’re jumping in here, `git checkout 22_0.2.0` (tag [`22_0.2.0`](https://github.com/GraphQLGuide/guide/tree/22_0.2.0)). Tag [`23_0.2.0`](https://github.com/GraphQLGuide/guide/tree/23_0.2.0) contains all the code written in this section.

The potential issue with the above approach is how much data we’re prefetching—the entire content of the book. The more data we fetch, the more work the server has to do, and the more work the client has to do—first to receive and cache it, and then later to interact with the larger cache. The client’s workload is more likely to become an issue because Apollo runs in the main thread (it interacts with React, which interacts with the DOM, which is in the main thread), and things it does might delay user interaction or freeze animations (see [Background > Browser performance](bg.md#browser-performance) for more info). It takes longer for Apollo to query and update the cache when there’s more data in the cache.

So usually instead of prefetching all of the data we could possibly need, we selectively prefetch some of it. One common way to do this is prefetching when the user mouses over something clickable. We might know that we’ll need certain data if they click that particular link or button, in which case we can fetch the data when the mouseover happens instead of waiting for the click. It’s possible that they won’t click, in which case we’ll have extra data that we don’t need, but this usually isn’t a problem.

For the Guide, when a user hovers over a link in the table of contents, we know what data we’ll need—that section’s contents. We can export the query for section contents from `Section.js` and use it in `TableOfContents.js` to make the query  inside the `onMouseOver` function:

[`src/components/TableOfContents.js`](https://github.com/GraphQLGuide/guide/blob/23_0.2.0/src/components/TableOfContents.js)

```js
import { useApolloClient } from '@apollo/client'

import { SECTION_BY_ID_QUERY } from './Section'

export default () => {
  const { data: { chapters } = {}, loading } = useQuery(CHAPTER_QUERY)
  const client = useApolloClient()

  return (
    <nav className="TableOfContents">
      ...
        <NavLink
          to={{
            pathname: slugify(chapter),
            state: { chapter, section: chapter.sections[0] },
          }}
          className="TableOfContents-chapter-link"
          activeClassName="active"
          isActive={(_, location) => {
            const rootPath = location.pathname.split('/')[1]
            return rootPath.includes(withHyphens(chapter.title))
          }}
          onMouseOver={() => 
            client.query({
              query: SECTION_BY_ID_QUERY,
              variables: {
                id: chapter.sections[0].id,
              },
            })
          }
        >
          ...
        </NavLink>
          ...
            <NavLink
              to={{
                pathname: slugify(chapter, section),
                state: { chapter, section },
              }}
              className="TableOfContents-section-link"
              activeClassName="active"
              onMouseOver={() =>
                client.query({
                  query: SECTION_BY_ID_QUERY,
                  variables: {
                    id: section.id,
                  },
                })
              }              
            >
              {section.title}
            </NavLink>
```

We have two `onMouseOver`s: When mousing over a chapter link, we query for the first section of that chapter. When mousing over a section link, we query for that section. 

We also need to add the export:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/23_0.2.0/src/components/Section.js)

```js
export const SECTION_BY_ID_QUERY = gql`
  query SectionContent($id: String!) {
    section(id: $id) {
      id
      content
      views
      scrollY @client
    }
  }
`
```

And now it works! When the user hovers over a link, the query is made. Then, when the link is clicked, `<Section>` calls `useQuery()` for the section data, and `useQuery()` instantly returns that data, because it’s already in the cache. We can check this in two ways:

- Opening the devtools Network tab and watching when the `SectionContent` query is sent to the server.
- Seeing whether the loading skeleton appears when we hover over a new link for a second before clicking, versus immediately clicking it. If we want to see the difference more clearly, we can slow down the connection to “Fast 3G” in the devtools Network tab.

Depending on how long we hover, we may still see the loading skeleton: for example, if it takes three seconds to load when we immediately click, and then we hover on the next link for two seconds before clicking, we will still see the skeleton for one second.

One issue to consider is whether we’re making a lot of extra queries, because users may mouse over sections that we’ve already loaded. But the default Apollo client fetch policy is [`cache-first`](https://www.apollographql.com/docs/react/data/queries/#configuring-fetch-logic), which means that if Apollo finds the query results in the cache, it won’t send the query to the server. We’re using the default, so we don’t need to do anything, but if we had set a different default in the [`ApolloClient` constructor](https://www.apollographql.com/docs/react/api/apollo-client.html#apollo-client) like this:

`src/lib/apollo.js`

```js
export const apollo = new ApolloClient({ 
  link, 
  cache,
  defaultOptions: {
    query: {
      fetchPolicy: 'cache-and-network'
    }
  }
})
```

> `cache-and-network` immediately returns any results available in the cache *and also* queries the server

then we could set a different fetch policy just for our prefetching:

```js
onMouseOver={() =>
  client.query({
    query: SECTION_BY_ID_QUERY,
    variables: {
      id: section.id,
    },
    fetchPolicy: 'cache-first',
  })
}
```

### Cache redirects

> If you’re jumping in here, `git checkout 23_0.2.0` (tag [`23_0.2.0`](https://github.com/GraphQLGuide/guide/tree/23_0.2.0)). Tag [`24_0.2.0`](https://github.com/GraphQLGuide/guide/tree/24_0.2.0) contains all the code written in this section.

There are often more ways than just mouseovers to intelligently prefetch certain data. What the ways are depends on the type of app. We have to think about how the user uses the app, and what they might do next. In our app, one common action will probably be to read the next section. So a simple thing we can do is whenever we show a section, we prefetch the next section:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/24_0.2.0/src/components/Section.js)

```js
import { useApolloClient } from '@apollo/client'

export default () => {
  ...
  
  const id = get(section, 'id')
  
  const client = useApolloClient()

  useEffect(() => {
    client.query({
      query: ...
      variables: {
        id: ...
      },
    }),
  }, [id, client])
}
```

But what query do we make? We could take the current section ID, eg `1_3` (chapter 1, section 3) and try the next section number, eg `1-4`, and if that failed (because it was the end of the chapter), we could go to the next chapter with `2_1`. That would look something like:

```js
useEffect(() => {
  async function prefetchSectionData() {
    const nextSectionId = ...
    const { data } = await client.query({
      query: SECTION_BY_ID_QUERY,
      variables: {
        id: nextSectionId,
      },
    })

    if (!data.section) {
      const nextChapterId = ...
      client.query({
        query: SECTION_BY_ID_QUERY,
        variables: {
          id: `${nextChapterId}_1`,
        },
      })
    }
  }

  prefetchSectionData()
}, [id, client])
```

[`client.query()`](https://www.apollographql.com/docs/react/api/core/ApolloClient/#ApolloClient.query) returns a Promise, which we can `await`, and our API resolves the `section` query to `null` when there is no such section. So when `data.section` is null, we query for the next chapter. (Alternatively, if our API instead returned a “No such section” error, we could use a `try...catch` statement.)

However, there’s a way to get the next section in a single query—the `Section` type has a field `next` of type `Section`! Let’s write a query for that:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/24_0.2.0/src/components/Section.js)

```js
const NEXT_SECTION_QUERY = gql`
  query NextSection($id: String!) {
    section(id: $id) {
      id
      next {
        id
        content
        views
        scrollY @client
      }
    }
  }
`

...

useEffect(() => {
  if (!id) {
    return
  }

  client.query({
    query: NEXT_SECTION_QUERY,
    variables: { id },
  })
}, [id, client])
```

For the `next` selection set, we copy the fields from the other queries in `Section.js`, since those are the fields that will be needed if the user navigates to the next section. It now seems like we’re done, and if we look at the Network tab, we see that the prefetch query is made. We can also see in Apollo devtools that the Section object with the next section ID is in the cache. However, when we navigate to the next section, the `SectionContent` query is still being made!

```gql
query SectionContent($id: String!) {
  section(id: $id) {
    id
    content
    views
    scrollY @client
  }
}
```

The problem is that Apollo doesn’t have a way of knowing that the server will respond to a `section` query that has an `id` argument with the `Section` object matching that ID. We can inform Apollo of this using a field policy `read` function that checks the cache:

[`src/lib/apollo.js`](https://github.com/GraphQLGuide/guide/blob/24_0.2.0/src/lib/apollo.js)

```js
export const cache = new InMemoryCache({
  typePolicies: {
    Query: {
      fields: {
        reviews: ...
        section: (_, { args: { id }, toReference }) => 
          toReference({
            __typename: 'Section',
            id,
          }),
      },
    },
  },
})
```

Now when we query the `section` root query field, Apollo will call the `Query.fields.section` read function, which will return a reference to a `Section` object in the cache. If the object is present and contains all the fields selected in the query, Apollo will return it. Otherwise, Apollo will send the query to the server.

And it works! If we turn on Slow 3G in the Network tab and click on the next section, it will render immediately, because it was prefetched when the previous section rendered 😊.

## Batching

> If you’re jumping in here, `git checkout 24_0.2.0` (tag [`24_0.2.0`](https://github.com/GraphQLGuide/guide/tree/24_0.2.0)). We won’t be leaving the code from this section in our app, so the next section will also start at tag `24`. 

If we load the site with the Network tab of devtools open, we see a lot of requests that say “graphql” on the left—that’s the path, so the full endpoint is `api.graphql.guide/graphql`, our GraphQL API. By default, each of the GraphQL queries in our app is sent in its own HTTP request. We can look at the request payload to see which query it is, for example our simple `StarsQuery`: 

![Network tab request payload](/img/request-payload.png)

We can **batch** our initial queries into one request, which will look like this:

![Array request payload](/img/array-request-payload.png)

> We also see that the third request is to `/graphql`, but the Request Method is `OPTIONS` instead of the normal `POST`, and the status code is `204` instead of the normal `200`. This is called a **preflight** request that Chrome makes to the server to check its security policy ([CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing)), since it’s going to a different domain from the client (`localhost:3000`). To avoid `OPTIONS` requests in production, we can host our frontend and API at the same domain, like `example.com` for the frontend and `example.com/graphql` for the API.

At first glance, it seems better to batch—fewer requests is more efficient for our browser, and it reduces the HTTP request load on our server. However, the big drawback is that we only get one response. This means that the server keeps all of our results until the last query in the batch completes, and *then* sends all the results back to us together in one response. Without batching, we get results to our faster queries faster, and those parts of the page get rendered, while the other parts stay in loading state for longer. For this reason, it’s recommended that we keep the default unbatched requests, and only try batching when we have server load issues *and* have [already made other performance improvements](https://blog.apollographql.com/batching-client-graphql-queries-a685f5bcd41b). If we ever get to that point, here’s the simple setup:

`src/lib/link.js`

```js
import { BatchHttpLink } from '@apollo/client/link/batch'

const httpLink = new BatchHttpLink({ uri: 'https://api.graphql.guide/graphql' })
```

We replace our previous `HttpLink` with Apollo’s [`BatchHttpLink`](https://www.apollographql.com/docs/link/links/batch-http.html). One thing you may notice in the Network tab is that soon after our initial batched request, we see another—this one only contains a single operation, named `ViewedSection`:

![Array request payload](/img/viewed-section-request.png)

The reason this wasn’t included in the initial batch request is because it happens a second later: only queries that are made within a certain window are batched together. The default `batchInterval` is 10 milliseconds, and can be changed [as an option](https://www.apollographql.com/docs/link/links/batch-http.html#options) to `BatchHttpLink()`.

If we know there are certain queries that will take longer than others, and we want them to bypass batching, we can set up both a normal http link and a batched link. Then we can use `split()` to decide which link to send a request to:

```js
const client = new ApolloClient({
  link: split(
    operation => operation.getContext().slow,
    httpLink, 
    batchHttpLink
  )
})

useQuery(SLOW_QUERY, { context: { slow: true } })
useQuery(NORMAL_QUERY)
```

We add data to the context, and then we check it inside `split()`: if the context has `slow: true`, then send via the `httpLink`. Otherwise, send via the `batchHttpLink`. 

## Persisting

> If you’re jumping in here, `git checkout 24_0.2.0` (tag [`24_0.2.0`](https://github.com/GraphQLGuide/guide/tree/24_0.2.0)). Tag [`25_0.2.0`](https://github.com/GraphQLGuide/guide/tree/25_0.2.0) contains all the code written in this section.

The Apollo cache is cached in page-specific memory. When the webpage is closed or reloaded, the memory is cleared, which means the next time our app loads, the cache is empty—it has to fetch all the data it needs from the server again. **Persisting** is saving the data in the Apollo cache so that on future pageloads, we can restore the data to the cache, and we don’t have to fetch it. The main benefit is we can show the data to the user much faster than we could if we had to fetch it from the server. We can easily set this up with the [`apollo3-cache-persist`](https://github.com/apollographql/apollo-cache-persist) package:

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/blob/25_0.2.0/src/components/App.js)

```js
import { persistCache } from 'apollo3-cache-persist'

import { cache } from '../lib/apollo'

persistCache({
  cache,
  storage: window.localStorage,
  maxSize: 4500000, // little less than 5 MB
  debug: true
})
```

The `persistCache()` function sets up persistence. `debug: true` has it log the size of the cache whenever it’s saved. The `storage` parameter has a number of options:

- `window.localStorage`
- `window.sessionStorage`
- [localForage](https://github.com/localForage/localForage): uses WebSQL or IndexedDB when available (most browsers), and falls back to `localStorage`
- `AsyncStorage` in React Native

`sessionStorage` is rarely used, since it is cleared when the browser is closed, and we usually want to cache data for a longer period. `localStorage` is simple to use and can consistently cache 5–10 MB. localForage is good for complex querying and larger sets of data. However, it is generally slower than `localStorage` for simple operations (and our operation is simple: it’s just saving and getting a single piece of data—the contents of the Apollo cache). We also have to import it from npm, which adds an additional [8 KB gzipped](https://bundlephobia.com/result?p=localforage@1.9.0) to our JavaScript bundle.

So we probably would only want to use localForage if we needed more than 5 MB of space. Let’s think about what kind of data our app queries for, how much space it takes up, and how much we might want of it. The largest thing the Guide queries for is section text, and according our new logging, each section takes up 2 KB:

```
[apollo-cache-persist] Persisted cache of size 34902
[apollo-cache-persist] Persisted cache of size 37014
```

> The second line was printed after hovering over a section link in the table of contents.

At this rate, we would fill up the cache after loading 5000 KB / 2 KB = 2500 sections, so 5 MB is currently plenty of room for us. Let’s go with `localStorage`. 

`maxSize` is the maximum number of bytes to persist. When `maxSize` is reached, it will stop saving data changes in the current session, and the next time the app starts, the cache will be cleared. We could set a different `maxSize` depending on which browser we’re in, but, for simplicity, let’s just assume we’re in the [lowest-quota browser](https://www.html5rocks.com/en/tutorials/offline/quota-research/), Safari, which can store 5 MB. We set `maxSize` to 4.5 MB to leave a little room for other uses (for instance our Auth0 library uses `localStorage`, and maybe we’ll decide later that we want to use it for something else).

Alright—we’ve covered all the arguments we used with `persistCache()` ([there are others](https://github.com/apollographql/apollo-cache-persist#additional-options) we’re not using). But we’re not done: the cache is getting persisted fine, but when a saved cache is restored on subsequent pageloads, our components are still querying, and they don’t get data until the query response comes back from the server. 

> We can verify this by changing the speed to “Slow 3G” in Network devtools and see A) the graphql requests being sent and B) both the first load and subsequent loads take a few seconds for the loading skeleton to be replaced with text.

The reason for this is that `persistCache()` takes time to complete (at least 150 ms on Loren’s computer), and, by that time, `@apollo/client` has already sent off our components’ queries. And when it does complete, our components don’t know that there’s new data in the cache. So when there’s a saved cache to restore, we want to wait for `persistCache()` to complete before rendering our components and triggering their queries. Then all of our `cache-first` queries will see that the data is in the cache and use it instead of requesting it from the server. We can tell if there’s a saved cache by checking in `localStorage` for the key that `persistCache()` uses, `apollo-cache-persist`:

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/blob/25_0.2.0/src/components/App.js)

```js
const cacheHasBeenSaved = !!localStorage.getItem('apollo-cache-persist')

export default () => {
  const [loadingFromCache, setLoadingFromCache] = useState(cacheHasBeenSaved)

  useEffect(() => {
    async function persist() {
      await persistCache({
        cache,
        storage: window.localStorage,
        maxSize: 4500000, // little less than 5 MB
        debug: true,
      })

      setLoadingFromCache(false)
    }

    persist()
  }, [])

  if (loadingFromCache) {
    return null
  }

  return (
    <div className="App">
      ...
    </div>
  )
}
```

Now let’s test it out. When we load the app for the first time, we see something like this:

```
[apollo-cache-persist] No stored cache to restore
[apollo-cache-persist] Persisted cache of size 17005
[apollo-cache-persist] Persisted cache of size 17129
```

The first message prints out on load, and the second appears a second after the page content appears, saying that the Apollo cache was saved to `localStorage` and what its size was. The third appears shortly after that, meaning the cache was re-saved, and the size only goes up by about a hundred bytes. What caused the re-save? We must have made another request to the server after the initial set of requests. We can check the Network tab to see what the last GraphQL request was, and we see that it’s the `ViewedSection` mutation. But why would that mutation change the Apollo cache? It’s not a query fetching data. Let’s look at the cache to see. In the Cache tab of Apollo devtools, there’s a `ROOT_MUTATION`:

![ROOT_MUTATION key in Apollo cache](/img/root-mutation.png)

We see that our mutation is indeed in the cache, and it resolved to a `Section` object. Is the entire cache, including mutation results, persisted? We can look at what’s saved by entering this in the browser console:

```js
JSON.parse(localStorage.getItem('apollo-cache-persist'))
```

![ROOT_MUTATION property in localStorage](/img/root-mutation-console.png)

And we see that it is present, and the `viewedSection` mutation has `type: "id"`, meaning that it has been normalized, linking to the top-level object with `id: "Section:5-1"`.

Now let’s see what happens when we reload the app. 

```
[apollo-cache-persist] Restored cache of size 17129
[apollo-cache-persist] Persisted cache of size 17129
```

The cache is restored! We can check to make sure the cache is being used to immediately provide data to our components by: 1) seeing in Network devtools that our initial batch of GraphQL requests are not being made, and 2) slowing the network speed to “Slow 3G” and seeing that there is no loading skeleton. Versus if we delete the cache and reload, we see the skeleton for a few seconds:

- Application devtools
- Select `Local Storage` on the left
- Select `http://localhost:3000`
- Select `apollo-cache-persist` on the right
- Click the `X` delete button
- Reload

So the persisting is working correctly, but, if we test the app further, we find that we can’t log out! Well, technically, we can, but it doesn’t look like we are—after clicking “Sign out” on the profile page, the site reloads and we still see our GitHub profile photo on the top-right, and we can still click it to see our profile. Why is that? 

On load, the app reads all the queries from the cache, including the `currentUser` query, which was saved to the cache when we logged in. It’s still there, along with any private data we had, like our email address. To fix this, we can clear the cache when we log out. In order to clear the cache, we need to use a different API from `apollo3-cache-persist`. We’ve been using the basic API, `persistCache()`. The more advanced API is [`CachePersistor`](https://github.com/apollographql/apollo-cache-persist#advanced-usage):

```js
const persistor = new CachePersistor(options)
```

And then we call methods on the `persistor` object when we want things to happen: for instance, `persistor.restore()` when we want to restore the cache (which `persistCache()` did automatically, but now we need to do ourselves). So let’s update `App.js`:

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/blob/25_0.2.0/src/components/App.js)

```js
import { CachePersistor } from 'apollo3-cache-persist'

import { cache, apollo } from '../lib/apollo'

const persistor = new CachePersistor({
  cache,
  storage: window.localStorage,
  maxSize: 4500000, // little less than 5 MB
  debug: true,
})

apollo.onResetStore(() => persistor.purge())

const cacheHasBeenSaved = !!localStorage.getItem('apollo-cache-persist')

export default () => {
  const [loadingFromCache, setLoadingFromCache] = useState(cacheHasBeenSaved)

  useEffect(() => {
    async function persist() {
      await persistor.restore()
      setLoadingFromCache(false)
    }

    persist()
  }, [])
```

This line deletes our data stored in LocalStorage when the cache is reset:

```js
apollo.onResetStore(() => persistor.purge())
```

And since we call `apollo.resetStore()` on logout in `src/lib/auth.js`, clicking “Sign out” clears the cache, and we see “Sign in” instead of our photo! ✅

But there’s another bug! 😅 When we’re signed out, we get truncated section content back from the API. This gets saved in the cache, and when we sign in, the current section gets refetched (due to `apollo.reFetchObservableQueries()` being called in `auth.js` on login). But if we looked at more than the current section before signing in, the other sections don’t get refetched, because there are no current (“observable”) queries for them. So they get stuck with the truncated content—when we revisit them, the truncated content is loaded from the cache. We can make sure they’re updated either by:

- changing the section content queries’ fetch policy to [`cache-and-network`](https://www.apollographql.com/docs/react/data/queries/#configuring-fetch-logic), or
- replacing `apollo.reFetchObservableQueries()` with `apollo.resetStore()`

The second would be simpler, but let’s do the first, because it also fixes another issue: when data is cached, it’s saved until it reaches `maxSize`, which could take a long time. The book content will periodically be updated, and we want our users to see the updated content. With `cache-and-network`, the latest version will always be fetched from the server. We make the change by adding the `fetchPolicy` option to our `useQuery()` hook:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/25_0.2.0/src/components/Section.js)

```js
const { data, loading } = useQuery(query, {
  variables,
  fetchPolicy: 'cache-and-network',
})
```

And we can test with these steps:

- Sign out
- Click “Preface” and then “Introduction”
- Sign in
- Click “Preface”

The preface content is no longer truncated, but we see a loading skeleton before the full content appears. So `loading` must be initially true, even though we have the truncated preface content in the cache. This is because `loading` is true whenever there is a network request in progress (which there is, because we’re using `cache-and-network`). And we see the skeleton when loading any section—even those with full content in the cache. It’s as if we don’t even have a cache anymore. To stop showing the skeleton, we have to go by whether there’s data instead of using Apollo’s `loading` variable. So let’s set `loading` ourselves:

```js
const { data } = useQuery(query, {
  variables,
  fetchPolicy: 'cache-and-network',
})

let section, chapter, loading

// eslint-disable-next-line default-case
switch (query) {
  case SECTION_BY_ID_QUERY:
    section = {
      ...state.section,
      content: get(data, 'section.content'),
      views: get(data, 'section.views'),
      scrollY: get(data, 'section.scrollY'),
    }
    chapter = state.chapter
    loading = !get(data, 'section')
    break
  case SECTION_BY_CHAPTER_TITLE_QUERY:
    section = get(data, 'chapterByTitle.section')
    chapter = {
      ...get(data, 'chapterByTitle'),
      number: null,
    }
    loading = !get(data, 'chapterByTitle')
    break
  case SECTION_BY_NUMBER_QUERY:
    section = get(data, 'chapterByNumber.section')
    chapter = get(data, 'chapterByNumber')
    loading = !get(data, 'chapterByNumber')
    break
}
```

And now it works! When we revisit the preface, it shows the truncated content in the cache first, and then shows the full content fetched from the server.

## Multiple endpoints

> If you’re jumping in here, `git checkout 25_0.2.0` (tag [`25_0.2.0`](https://github.com/GraphQLGuide/guide/tree/25_0.2.0)). Tag [`26_0.2.0`](https://github.com/GraphQLGuide/guide/tree/26_0.2.0) contains all the code written in this section.

So far, we’ve been working with a single GraphQL endpoint, `api.graphql.guide/graphql` (and its websocket counterpart, `/subscriptions`). Would we ever want our app to talk to another endpoint? Maybe. Similarly to the APIs in the [REST section](#REST), we usually would want to proxy the other GraphQL endpoint through our GraphQL server (we’ll go over how to do this in the server chapter). There are two main reasons: 

- If the endpoint is authenticated, we usually will want to keep it private on our server.
- It’s nice for our GraphQL endpoint to have the complete graph of data our app might need, so that devs have one source of truth, and so that our server-side tools—including caching, logging, and analytics—cover all our queries.

However, there are cases in which we might not want to proxy: we might not have control over the backend, or maybe we want to reduce load on our server or get a slightly better latency than we would while proxying. So we need a GraphQL API from which to fetch some data for this section. Apollo GraphQL shares the name of NASA’s Apollo project, which landed the first humans on the moon in 1969. And Apollo GraphQL identifies with the rocket emoji 🚀. So let’s put that emoji somewhere and make it an easter egg—if it’s clicked, we’ll show the next SpaceX launch using the (unofficial) [SpaceX GraphQL API](https://github.com/spacexland/api).

So far, all our queries know what endpoint to talk to because of the `<ApolloProvider>` wrapped around the `<App>`:

`src/index.js`

```js
render(
  <BrowserRouter>
    <ApolloProvider client={apollo}>
      <MuiThemeProvider theme={theme}>
        <App />
      </MuiThemeProvider>
    </ApolloProvider>
  </BrowserRouter>,
  document.getElementById('root')
)
```

where `apollo` is the `ApolloClient` instance we created with an HTTP link to `api.graphql.guide/graphql`:

`src/lib/link.js`

```js
const httpLink = new HttpLink({
  uri: 'https://api.graphql.guide/graphql'
})
```

`src/lib/apollo.js`

```js
import link from './link'

export const apollo = new ApolloClient({ link, cache, typeDefs })
```

We’re going to need a second `ApolloClient` instance to use for our launch query:

[`src/lib/apollo.js`](https://github.com/GraphQLGuide/guide/blob/26_0.2.0/src/lib/apollo.js)

```js
import link, { spaceXLink } from './link'

export const apollo = new ApolloClient({ link, cache, typeDefs })

export const apolloSpace = new ApolloClient({
  link: spaceXLink,
  cache: new InMemoryCache(),
})
```

[`src/lib/link.js`](https://github.com/GraphQLGuide/guide/blob/26_0.2.0/src/lib/link.js)

```js
export const spaceXLink = ApolloLink.from([
  errorLink,
  new HttpLink({
    uri: 'https://api.spacex.land/graphql',
  }),
])
```

Now to use it, we can put it in the `client` option of `useQuery()`, which overrides its normal behavior of using the client provided by `<ApolloProvider>`.

```js
useQuery(LAUNCH_QUERY, { client: apolloSpace })
```

For building the `LAUNCH_QUERY`, let’s see what data is available from the API by browsing its GraphiQL: [api.spacex.land/graphql/](https://api.spacex.land/graphql/). From the available queries, it looks like the relevant one for us is `launchNext`, and we can pick a few fields to display:

![SpaceX GraphiQL with launchNext query](/img/launch-next-query.png)

[`src/components/Profile.js`](https://github.com/GraphQLGuide/guide/blob/26_0.2.0/src/components/Profile.js)

```js
import { gql } from '@apollo/client'

const LAUNCH_QUERY = gql`
  query LaunchQuery {
    launchNext {
      details
      launch_date_utc
      launch_site {
        site_name
      }
      mission_name
      rocket {
        rocket_name
      }
    }
  }
`
```

Now we can use it—let’s put the 🚀 button on the bottom of `Profile`. Then we put the data from the response into a `<dl>`:

[`src/components/Profile.js`](https://github.com/GraphQLGuide/guide/blob/26_0.2.0/src/components/Profile.js)

```js
import React, { useState } from 'react'
import { gql, useQuery } from '@apollo/client'

import { apolloSpace } from '../lib/apollo'

const LAUNCH_QUERY = gql`...`

function Launch() {
  const { data, loading } = useQuery(LAUNCH_QUERY, {
    fetchPolicy: 'cache-and-network',
    client: apolloSpace,
    onCompleted: () =>
      window.scrollTo({ top: 1000, left: 0, behavior: 'smooth' }),
  })

  if (loading) {
    return <div className="Spinner" />
  }

  const {
    launchNext: { details, launch_date_utc, launch_site, mission_name, rocket },
  } = data

  return (
    <div>
      The next SpaceX launch will be:
      <dl>
        <dt>Date</dt>
        <dd>
          <code>{new Date(launch_date_utc).toString()}</code>
        </dd>

        <dt>Mission</dt>
        <dd>
          <code>{mission_name}</code>
        </dd>

        <dt>Rocket</dt>
        <dd>
          <code>{rocket.rocket_name}</code>
        </dd>

        <dt>Launch site</dt>
        <dd>
          <code>{launch_site.site_name}</code>
        </dd>

        <dt>Details</dt>
        <dd className="-non-code">{details}</dd>
      </dl>
    </div>
  )
}

export default () => {
  const { user, loggingIn } = useUser()
  const [showLaunch, setShowLaunch] = useState(false)
  
  ...

        <div className="Profile-footer">
          <button
            className="Profile-toggle-launch"
            onClick={() => setShowLaunch(!showLaunch)}
          >
            <span role="img" aria-label="rocket">
              🚀
            </span>
          </button>

          {showLaunch && <Launch />}
        </div>
      </main>
    )
  }
}
```

When the 🚀 button is clicked, the launch info appears below, but, depending on our screen height and browser settings, we might be at the bottom of the page already—in which case we won’t be able to see the info without scrolling. It would be nice UX to autoscroll down to show the info. `useQuery()` has an [`onCompleted` option](https://www.apollographql.com/docs/react/api/react/hooks/#params) that is called after the query results are provided to us and our component has re-rendered, so we can call `window.scrollTo` then.

We’re using `fetchPolicy: 'cache-and-network'` instead of the default `cache-first` to make sure we always have the latest results. If a user checked the next launch, left the browser open for a while, and checked back later, it’s possible that the launch we have in the cache will be old—either the launch already happened, or the plans changed. With `cache-and-network`, `useQuery()` will first provide us with the cache data, then send the request to the server, then provide us with the response data. However, something unexpected is now happening when we repeatedly toggle the launch info. Do you notice it?

Every time we show the launch info, it shows the loading spinner. As we learned in the last section, `loading` is true whenever there’s a network request in flight, even when there’s cached data available.
Let’s test whether there’s data instead of using `loading`:

```js
const {
  launchNext: {
    details,
    launch_date_utc,
    launch_site,
    mission_name,
    rocket,
  } = {},
} = data || {}

if (!details) {
  return <div className="Spinner" />
}
```

Now we’ll only see the spinner the first time.

We’re done! We can add more SpaceX data to different parts of our app by importing `apolloSpace` and using the `useQuery()` `client` option. And we can add more APIs by creating more `ApolloClient` instances.

# Extended topics

Section contents:

* [Linting](6.md#linting)
  * [Setting up linting](6.md#setting-up-linting)
  * [Fixing linting errors](6.md#fixing-linting-errors)
  * [Using linting](6.md#using-linting)
* [Uploading files](6.md#uploading-files)
* [Testing](6.md#testing)

## Linting

> If you’re jumping in here, `git checkout 26_0.2.0` (tag [`26_0.2.0`](https://github.com/GraphQLGuide/guide/tree/26_0.2.0)). Tag [`27_0.2.0`](https://github.com/GraphQLGuide/guide/tree/27_0.2.0) contains all the code written in this section.

Linters analyze code for errors without running the code—they just look at the code. [ESLint](https://eslint.org/docs/about/) is the main linter for JavaScript. It’s already being used in our app by Create React App. However, their ESLint settings just cover JavaScript—they don’t check our GraphQL queries to see if they’re valid. Let’s set that up!

First, let’s run ESLint as it’s currently set up. We have a script in our `package.json` that just runs `eslint src/`:

```sh
$ npm run lint 

> guide@0.2.0 lint /guide
> eslint src/

```

It doesn’t print out any linting errors. We can check the exit code to make sure:

```sh
$ echo $?
0
```

In Mac and Linux, each program has an **exit code**. In Bash, we can print out the last exit code with `echo $?`. An exit code of `0` means success.

### Setting up linting

To extend CRA’s linting, we need to set the `EXTEND_ESLINT` env var, which we can either do in `.env` or here:

[`package.json`](https://github.com/GraphQLGuide/guide/blob/27_0.2.0/package.json)

```js
{
  ...
  "scripts": {
    "start": "EXTEND_ESLINT=true react-scripts start",
    ...
```

The npm package `eslint-plugin-graphql` (already in our `package.json` dependencies) is an ESLint plugin that checks our GraphQL queries against a schema. We can tell ESLint to use it by modifying our config file:

[`.eslintrc.js`](https://github.com/GraphQLGuide/guide/src/components/27_0.2.0/.eslintrc.js)

```js
module.exports = {
  extends: 'react-app',
  plugins: ['graphql'],
  parser: 'babel-eslint',
  rules: {
    'graphql/template-strings': [
      'error',
      {
        schemaJson: require('./schema.json')
      }
    ]
  },
}
```

- `.eslintrc.js`: We add `.js` to the filename (formerly `.eslintrc`) so that we can use `require()`.
- `extends: 'react-app'`: Use Create React App’s rules as a base.
- `plugins: ['graphql']`: Use `eslint-plugin-graphql`.
- `schemaJson: require('./schema.json')`: Look in the current directory for the schema.

What schema? We want ESLint to validate our queries against our API’s schema—the one the `api.graphql.guide` server has, that Playground shows us in the SCHEMA tab. It makes sense that ESLint is going to need it. But how do we get it in a JSON file? Apollo has a CLI we can use to download it. It’s already in our dependencies, and its name is `apollo`. Our `update-schema` script uses it:

`"update-schema": "apollo schema:download --endpoint https://api.graphql.guide/graphql schema.json"`

So we can run `npm run update-schema`, and now we have a `schema.json`. It’s like a verbose form of what we see in the Playground SCHEMA tab, and starts with:

```json
{
  "data": {
    "__schema": {
      "queryType": {
        "name": "Query"
      },
      "mutationType": {
        "name": "Mutation"
      },
      "subscriptionType": {
        "name": "Subscription"
      },
      "types": [
        {
          "kind": "OBJECT",
          "name": "Query",
          "description": "",
          "fields": [
            {
              "name": "sections",
              "description": "",
              "args": [
                {
                  "name": "lastCreatedAt",
                  "description": "",
                  "type": {
                    "kind": "SCALAR",
                    "name": "Float",
                    "ofType": null
                  },
                  "defaultValue": null
                },
                {
                  "name": "limit",
                  "description": "",
                  "type": {
                    "kind": "SCALAR",
                    "name": "Int",
                    "ofType": null
                  },
                  "defaultValue": null
                }
              ],
```

We can see that a `__schema` has `types` that include an object with `name: "Query"` and a field named `sections`, which has args `lastCreatedAt` and `limit`. And if we scroll down, we see more familiar fields and types.

### Fixing linting errors

Now we can try running ESLint again:

```sh
$ npm run lint

> guide@0.2.0 lint /Users/me/gh/guide
> eslint src/


/Users/me/gh/guide/src/components/CurrentTemperature.js
  8:5  error  Cannot query field "weather" on type "Query"  graphql/template-strings

/Users/me/gh/guide/src/components/Profile.js
  10:5  error  Cannot query field "launchNext" on type "Query"  graphql/template-strings

/Users/me/gh/guide/src/components/Section.js
  18:7   error  Cannot query field "scrollY" on type "Section"            graphql/template-strings
  31:9   error  Cannot query field "scrollY" on type "Section"            graphql/template-strings
  47:9   error  Cannot query field "scrollY" on type "Section"            graphql/template-strings
  70:9   error  Cannot query field "scrollY" on type "Section"            graphql/template-strings
  169:11 error  Cannot query field "scrollY" on type "Section"            graphql/template-strings

/Users/me/gh/guide/src/lib/apollo.js
  41:3  error  The "Section" definition is not executable  graphql/template-strings

✖ 8 problems (8 errors, 0 warnings)

npm ERR! code ELIFECYCLE
npm ERR! errno 1
npm ERR! guide@0.2.0 lint: `eslint src/`
npm ERR! Exit status 1
npm ERR!
npm ERR! Failed at the guide@0.2.0 lint script.
npm ERR! This is probably not a problem with npm. There is likely additional logging output above.

npm ERR! A complete log of this run can be found in:
npm ERR!     /Users/me/.npm/_logs/2019-03-04T01_50_08_741Z-debug.log
```

We get a lot of errors! And we can see that the exit code is no longer `0`: 

```
npm ERR! code ELIFECYCLE
npm ERR! errno 1
npm ERR! guide@0.2.0 lint: `eslint src/`
npm ERR! Exit status 1
```

`Exit status 1` means that the exit code of the command `eslint src/` was `1`.

Let’s go through the errors. First up:

```
/Users/me/gh/guide/src/components/CurrentTemperature.js
  80:5  error  Cannot query field "weather" on type "Query"  graphql/template-strings
```

which is referring to:

[`src/components/CurrentTemperature.js`](https://github.com/GraphQLGuide/guide/blob/27_0.2.0/src/components/CurrentTemperature.js)

```js
const TEMPERATURE_QUERY = gql`
  query TemperatureQuery {
    weather(lat: $lat, lon: $lon)
      @rest(
        type: "WeatherReport"
        path: "weather?appid=4fb00091f111862bed77432aead33d04&{args}"
      ) {
      main
    }
  }
`
```

ESLint is looking at our `schema.json` and not finding `weather` as a top-level Query field. Of course it’s not! `weather` isn’t part of the Guide API—it’s from our [weather REST API](#rest). So we don’t want this query linted against the schema. We can tell ESLint to ignore this file by adding `/* eslint-disable graphql/template-strings */` to the top of the file. Now if we re-run `npm run lint`, we no longer see that error. 

Seven errors left to go! The next is:

```
/Users/me/gh/guide/src/components/Profile.js
  10:5  error  Cannot query field "launchNext" on type "Query"  graphql/template-strings
```

`launchNext` is from our query to the SpaceX API, which of course has a different schema from the rest of our queries. So far we’ve only told ESLint about `schema.json`, the Guide API schema. But `eslint-plugin-graphql` does support multiple schemas. It determines what strings to parse as GraphQL by the template literal tag name (`gql`). We can use a different tag name for the SpaceX query and have that tag be checked against a different schema. Let’s use `spaceql` instead of our current `gql`:

[`src/components/Profile.js`](https://github.com/GraphQLGuide/guide/blob/27_0.2.0/src/components/Profile.js)

```js
import { gql as spaceql } from '@apollo/client'

const LAUNCH_QUERY = spaceql`
  query LaunchQuery {
    launchNext {
      details
      launch_date_utc
      launch_site {
        site_name
      }
      mission_name
      rocket {
        rocket_name
      }
    }
  }
`
```

And we update the config file:

[`.eslintrc.js`](https://github.com/GraphQLGuide/guide/blob/27_0.2.0/.eslintrc.js)

```js
module.exports = {
  extends: 'react-app',
  plugins: ['graphql'],
  parser: 'babel-eslint',
  rules: {
    'graphql/template-strings': [
      'error',
      {
        schemaJson: require('./schema.json')
      },
      {
        tagName: 'spaceql',
        schemaJson: require('./spacex.json')
      }
    ]
  }
}
```

We added this object:

```
{
  tagName: 'spaceql',
  schemaJson: require('./spacex.json')
}
```

Which says, “for any GraphQL document created with the template literal tag name `spaceql`, validate it against the schema located in `spacex.json`.” We can get `spacex.json` with `npm run update-schema-spacex`:

```
  "update-schema-spacex": "apollo schema:download --endpoint https://api.spacex.land/graphql spacex.json"
```

And now when we lint, we get one fewer error ✅. The next set of errors is:

```
/Users/me/gh/guide/src/components/Section.js
  18:7   error  Cannot query field "scrollY" on type "Section"            graphql/template-strings
  31:9   error  Cannot query field "scrollY" on type "Section"            graphql/template-strings
  47:9   error  Cannot query field "scrollY" on type "Section"            graphql/template-strings
  70:9   error  Cannot query field "scrollY" on type "Section"            graphql/template-strings
  169:11 error  Cannot query field "scrollY" on type "Section"            graphql/template-strings
```

`scrollY` is the piece of [local state](#local-state) in our Section queries:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/27_0.2.0/src/components/Section.js)

```js
const NEXT_SECTION_QUERY = gql`
  query NextSection($id: String!) {
    section(id: $id) {
      id
      next {
        id
        content
        views
        scrollY @client
      }
    }
  }
`
```

Since `scrollY` is local, ESLint won’t find it in the Guide API schema. We can suppress the error by adding this line to the top of the file:

```js
/* eslint-disable graphql/template-strings */
```

Lastly, we have:

```
/Users/me/gh/guide/src/lib/apollo.js
  41:3  error  The "Section" definition is not executable  graphql/template-strings
```

This refers to the `Section` in our local state schema:


```js
const typeDefs = gql`
  extend type Section {
    scrollY: Int
  }
`
```

Instead of `eslint-disable`-ing the whole file, let’s just disable part of it. That way, if we later add a document to a different part of the file, it will be linted.

[`src/lib/apollo.js`](https://github.com/GraphQLGuide/guide/blob/27_0.2.0/src/lib/apollo.js)

```js
/* eslint-disable graphql/template-strings */
const typeDefs = gql`
  extend type Section {
    scrollY: Int
  }
`
/* eslint-enable graphql/template-strings */
```

Now when we lint, we don’t see an error, and we get a successful exit code 😊.

```sh
$ npm run lint

> guide@1.0.0 lint /Users/me/gh/guide
> eslint src/

$ echo $?
0
```

### Using linting

Usually people don’t manually run `npm run lint` on the command line. Instead, they set up one or more of the following, which all automatically run the linter:

- [Editor integration](#editor-integration)
- [Pre-commit hook](#pre-commit-cook)
- [Continuous integration](#continuous-integration)

#### Editor integration

Most editors have a linting plugin. VSCode has this [ESLint plugin](https://github.com/Microsoft/vscode-eslint). It looks for a configuration file in the current workspace (for us it would find `.eslintrc.js`) and runs ESLint in the background whenever we type something new into the editor. For instance, if we type in `first` as a field of `currentUser`, it is underlined:

![ESLint underlining error in VSCode](/img/eslint-vscode.png)

And if we hover over the word, we see the linting error:

![ESLint error message tooltip](/img/eslint-vscode-tooltip.png)

> Cannot query field "first" on type "User". Did you mean "firstName"?

Since ESLint has the schema, it knows that `currentUser` resolves to a `User`, and that `first` isn’t one of the fields of the `User` type. When we change it to `firstName`, the error underline goes away.

Some linting errors have automatic fixes, and we can have the plugin make those fixes whenever we save the file by enabling this setting:

```
"eslint.autoFixOnSave": true
```

#### Pre-commit hook

Git has [a lot of hooks](https://git-scm.com/docs/githooks)—times when git will run a program for you. One such hook is pre-commit. A pre-commit hook will be called when a dev enters `git commit` and before git actually does the committing. If the hook program ends with a non-zero exit code, the commit will be canceled. The best way to set up git hooks in our project is with [Husky](https://github.com/typicode/husky). To do that, we would:

```
npm install husky --save-dev
```

And add to our `package.json`:

```json
{
  "husky": {
    "hooks": {
      "pre-commit": "npm run lint"
    }
  }
}
```

Then if we tried to commit but `npm run lint` failed, the commit would be canceled, and we would see the ESLint output with the problem(s) we need to fix. 

#### Continuous integration

Background: [Continuous integration (CI)](bg.md#continuous-integration)

Our CI server can do `npm run lint` as one of its tests, prevent deployment if linting fails, display a build failure symbol next to the commit or PR, and link to its site where we can view the error output.

## Uploading files

Background: [CDN](bg.md#cdn)

There are two ways to do file uploads: client-side and server-side. In client-side uploads, the client sends the file directly to a cloud service that stores the files. In server-side, the client sends the file to our server, which then stores it someplace (either on a hard drive or with a cloud service—usually the latter). For ease of coding, we recommend client-side. The only possible downside is that someone could upload a lot of files to our service, costing us more money. However, in the unlikely event that this becomes a problem, there are ways with most services to make sure only logged-in users can upload.

The two main services we recommend are: 

- Cloudinary (file storage, CDN, and media file processor)
- Amazon S3 (file storage) and CloudFront ([CDN](bg.md#cdn))

Usually, an app needs to process images or videos—resizing an image, centering on a face and cropping it, brightening, etc.—before using them. For these apps, we recommend Cloudinary as the all-in-one solution. If you’re just saving files that need to be stored, and maybe downloaded later unchanged, then S3 is fine.

### Client-side

There are two ways to upload to Cloudinary from the client—we can use their upload UI, or we can create our own. Here’s what [theirs](https://cloudinary.com/documentation/upload_widget) looks like:

![Cloudinary upload widget](/img/cloudinary-upload-widget.jpg)

When we open the widget, we give it a callback. The user uses the widget to upload a file to our Cloudinary account, and the widget calls our callback, providing us the ID of the file as an argument. We send the ID to our server in a mutation, and our server saves it to our database. We use the ID to construct the URL of the file, for example:

```
http://res.cloudinary.com/graphql/guide/file-id.jpg
```

If we want our own UI, we can render a file input styled however we want, and then we POST the input file to the Cloudinary server [like in this React example](https://github.com/cloudinary/cloudinary-react/blob/f83e4e561f9709268afbe11812f116f382cc117f/samples/photo_album/src/components/PhotosUploader.js#L99-L119). (And then, as before, we get an ID back to send in a mutation to the server.)

### Server-side

Here’s what we would do to upload a file to our server:

```sh
npm install apollo-upload-client
```

`apollo.js`

```js
import { ApolloClient, InMemoryCache } from '@apollo/client'
import { createUploadLink } from 'apollo-upload-client'

const client = new ApolloClient({
  cache: new InMemoryCache(),
  link: createUploadLink({
    uri: 'https://api.graphql.guide/graphql'
  })
})
```

`FileUpload.js`

```js
import { gql, useMutation } from '@apollo/client'

const UPLOAD_FILE_MUTATION = gql`
  mutation UploadFile($file: Upload!) {
    uploadFile(file: $file) {
      id
      fileName
    }
  }
`

export default function () {
  const [uploadFile] = useMutation(UPLOAD_FILE_MUTATION)

  return (
    <input
      type="file"
      required
      onChange={({
        target: {
          validity,
          files: [file]
        }
      }) => validity.valid && uploadFile({ 
        variables : { file } 
      })}
    />
  )
}

export default FileUpload
```

Our server needs to support the [GraphQL multipart request spec](https://github.com/jaydenseric/graphql-multipart-request-spec#server). Apollo server supports it, or, if we’re using a different JS server, we can add support with the [`graphql-upload`](https://github.com/jaydenseric/graphql-upload) package. We’ll see the Apollo server implementation in [Chapter 11: Server Dev > File uploads > Server-side](11.md#server-side).

## Testing

Background: [Testing](bg.md#testing)

> If you’re jumping in here, `git checkout 27_0.2.0` (tag [`27_0.2.0`](https://github.com/GraphQLGuide/guide/tree/27_0.2.0)). Tag [`28_0.2.0`](https://github.com/GraphQLGuide/guide/tree/28_0.2.0) contains all the code written in this section.

As we learned in [Background > Testing > Types of tests](#types-of-tests), we should be writing *some* unit and e2e tests but mostly integration tests. When we test a component, for instance `<TableOfContents />`, that contains Apollo operations, we need to wrap it with a *provider* like we do in the app:

[`index.js`](https://github.com/GraphQLGuide/guide/blob/27_0.2.0/src/index.js)

```js
render(
  <BrowserRouter>
    <ApolloProvider client={apollo}>
      <MuiThemeProvider theme={theme}>
        <App />
      </MuiThemeProvider>
    </ApolloProvider>
  </BrowserRouter>,
  document.getElementById('root')
)
```

We could use the same `<ApolloProvider client={apollo}>` in our tests, but that would cause queries to be sent to the GraphQL server. In integration tests (and in our component library, if we’re using something like [Storybook](https://storybook.js.org/)), we usually [mock](#mocking) network requests in order to reduce test runtime and avoid test failures due to internet connection issues or the backend data changing. If we mock our GraphQL operations, then:

- We decide what data is returned, so we can:
  - Test for the presence of the same data.
  - Trust that the data won’t change.
- The operation response "arrives" immediately 😄.

There are two main methods of mocking GraphQL operations with Apollo Client: 

- [`<MockedProvider>`](https://www.apollographql.com/docs/react/development-testing/testing/#mockedprovider): A basic mocking provider included in Apollo Client, with which we write out `{ request, result }` pairs to match requests in our component.
- [`apollo-mocked-provider`](https://github.com/benawad/apollo-mocked-provider): An easier-to-use library that allows us to create an `<ApolloMockedProvider>` with reusable resolvers and customizable links. It also allows us to create an error provider and a loading provider.

We’ll use the latter in our code, and show an example of the former at the end.

For React integration and unit tests, we recommend [`react-testing-library`](https://testing-library.com/react) with [Jest](https://jestjs.io/). We’ll be using both in this section. If you’d like a video introduction to them, as well as testing in general, we recommend [this course](https://testingjavascript.com/) from Kent Dodds.

We run our tests with `npm test`, which runs `react-scripts test`, which runs Jest. It looks for JS files in any `__tests__` directory, for instance `src/components/__tests__/Foo.js`, or with the `.test.js` suffix. The only file it finds is:

[`src/components/App.test.js`](https://github.com/GraphQLGuide/guide/blob/27_0.2.0/src/components/App.test.js)

```js
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'

it('renders without crashing', () => {
  const div = document.createElement('div')
  ReactDOM.render(<App />, div)
})
```

The test fails with this error message:

`Invariant failed: You should not use <Switch> outside a <Router>`

![npm test output with red FAIL message](img/npm-test-App-fail.png)

We’re rendering `<App />`, which contains a `<Switch>`, without wrapping it in a router like `<BrowserRouter>` as we do in `src/index.js`. Instead of including a router component in each test, we can make [our own render function](https://testing-library.com/docs/react-testing-library/setup#custom-render) to use in lieu of `ReactDOM.render()`:

[`src/setupTests.js`](https://github.com/GraphQLGuide/guide/blob/28_0.2.0/src/setupTests.js)

```js
import React from 'react'
import {
  createApolloErrorProvider,
  createApolloMockedProvider,
  createApolloLoadingProvider,
} from 'apollo-mocked-provider'
import { printSchema, buildClientSchema } from 'graphql'
import fs from 'fs'
import { render, waitFor } from '@testing-library/react'
import { createMemoryHistory } from 'history'
import { Router } from 'react-router-dom'

const schema = JSON.parse(fs.readFileSync('schema.json'))
const typeDefs = printSchema(buildClientSchema(schema.data))
const ApolloMockedProvider = createApolloMockedProvider(typeDefs)

global.ApolloMockedProvider = ApolloMockedProvider
global.ApolloErrorProvider = createApolloErrorProvider()
global.ApolloLoadingProvider = createApolloLoadingProvider()

const RouterWrapper = ({ children }) => {
  const history = createMemoryHistory()

  return <Router history={history}>{children}</Router>
}

global.render = (ui, options) =>
  render(ui, { wrapper: RouterWrapper, ...options })

global.mockedRender = (ui, customResolvers, options) => {
  const MockedWrapper = ({ children }) => (
    <RouterWrapper>
      <ApolloMockedProvider customResolvers={customResolvers}>
        {children}
      </ApolloMockedProvider>
    </RouterWrapper>
  )

  return render(ui, { wrapper: MockedWrapper, ...options })
}

global.wait = () => waitFor(() => {})
```

We create two global render functions: `render(<Component />)`, which wraps the component with a router, and `mockedRender(<Component />)`, which also adds an `<ApolloMockedProvider>`, which we get from `createApolloMockedProvider(typedefs)`, which comes from `apollo-mocked-provider`. The `typeDefs` we get from parsing the `schema.json` file we got from introspecting the server. For testing, we don’t need the `<BrowserRouter>` we use in the app—we can use a plain `<Router>` with history tracked in memory.

`apollo-mocked-provider` also exports `createApolloErrorProvider` and `createApolloLoadingProvider`, which we use to create the `<ApolloErrorProvider>` and `<ApolloLoadingProvider>` components. The former causes operations to return an error and no data, and the latter causes operations to just return `loading: true`. Lastly, we add a global `wait()` that we can `await` during our tests. Before the `wait()`, Apollo hooks will return `loading: true`, and after the `wait()`, they’ll return the data or error (except for the `<ApolloLoadingProvider>`, which keeps Apollo in the loading state).

Let’s delete `src/components/App.test.js` and use `mockedRender()` with a smaller component, `<TableOfContents>`:

`src/components/TableOfContents.test.js`

```js
import React from 'react'
import { screen } from '@testing-library/react'

import TableOfContents from './TableOfContents'

describe('TableOfContents', () => {
  it('renders loading status and chapters', async () => {
    mockedRender(<TableOfContents />, {
      Chapter: () => ({
        title: () => 'Chapter-title',
      }),
    })

    screen.getByRole('status')
    await wait()
    screen.getAllByText('Chapter-title')
  })
})
```

We pass a custom resolver for `Chapter.title` to `mockedRender()` so that all the chapter titles in the mocked response have the title `Chapter-title`. Then, we can check at the end of the test whether that text is found (`screen.getAllByText('Chapter-title')` will error if it doesn’t find any matching nodes). 

To check that the loading skeleton renders at first, we need something to search for. The recommended priority order for queries is:

- `getByRole` (role refers to [ARIA roles](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques#Roles))
- `getByLabelText`
- `getByPlaceholderText`
- `getByText`
- `getByDisplayValue` (the current value of a form field)
- `getByAltText`
- `getByTitle`
- `getByTestId` (e.g., `<div data-testid="custom-element" />`)

We’re using `getByRole`. Some HTML elements have inherent roles: for instance, a `<button>` has the `button` role. We just have divs and a header in our `LoadingSkeleton` component, so we need to set the role attribute. While we’re at it, let’s also add loading text that a screen reader would read (hidden with CSS):

[`src/components/TableOfContents.js`](https://github.com/GraphQLGuide/guide/blob/28_0.2.0/src/components/TableOfContents.js)

```js
const LoadingSkeleton = () => (
  <div>
    <div className="sr-only" role="status">
      Loading
    </div>
    <h1>
      <Skeleton />
    </h1>
    <Skeleton count={4} />
  </div>
)
```

Now we can run the test and see that it passes, albeit with an error:

```sh
$ npm test
```

![Warning: Encountered two children with the same key, `9`](/img/table-of-contents-test-error.png)

Our `<li>`s have duplicate `key` attributes:

```js
<ul className="TableOfContents-sections">
  {chapter.sections.map((section) => (
    <li key={section.number}>
```

So `section.number` must be the same for multiple sections. To see what the mocked provider is returning, let’s add a link that logs all responses:

[`src/setupTests.js`](https://github.com/GraphQLGuide/guide/blob/28_0.2.0/src/setupTests.js)

```js
import { ApolloLink } from '@apollo/client'

const responseLogger = new ApolloLink((operation, forward) => {
  return forward(operation).map((result) => {
    console.log(JSON.stringify(result, null, '  '))
    return result
  })
})

const ApolloMockedProvider = createApolloMockedProvider(typeDefs, {
  links: () => [responseLogger],
})
```

Now when we `npm test`, we see in the terminal:

```
console.log src/setupTests.js:18
  {
    "data": {
      "chapters": [
        {
          "id": 46,
          "number": -59.910131803037636,
          "title": "Chapter-title",
          "sections": [
            {
              "id": "Hello World",
              "number": 19,
              "title": "Hello World",
              "__typename": "Section"
            },
            {
              "id": "Hello World",
              "number": 17,
              "title": "Hello World",
              "__typename": "Section"
            }
          ],
          "__typename": "Chapter"
        },
        {
          "id": -74,
          "number": 27.46611005161776,
          "title": "Chapter-title",
          "sections": [
            {
              "id": "Hello World",
              "number": 73,
              "title": "Hello World",
              "__typename": "Section"
            },
            {
              "id": "Hello World",
              "number": 14,
              "title": "Hello World",
              "__typename": "Section"
            }
          ],
          "__typename": "Chapter"
        }
      ]
    }
  }
```

The sections have different numbers in the response, so how do they wind up with the same number in the JSX? 

Since the section `id`s are the same, only a single `Section` object is saved to the cache, and the JSX maps over two references to that object. We can fix this issue by adding a custom resolver for `id` to the `ApolloMockedProvider` we set up here:

[`src/setupTests.js`](https://github.com/GraphQLGuide/guide/blob/28_0.2.0/src/setupTests.js)

```js
global.mockedRender = (ui, customResolvers, options) => {
  const MockedWrapper = ({ children }) => (
    <RouterWrapper>
      <ApolloMockedProvider customResolvers={customResolvers}>
        {children}
      </ApolloMockedProvider>
    </RouterWrapper>
  )

  return render(ui, { wrapper: MockedWrapper, ...options })
}
```

We can either pass in `customResolvers` to `mockedRender()` or add them here. Since distinct `id`s is something we’d like throughout all of our tests, let’s add it here:

```js
global.mockedRender = (ui, customResolvers, options) => {
  let id = 1

  const MockedWrapper = ({ children }) => (
    <RouterWrapper>
      <ApolloMockedProvider
        customResolvers={{
          Section: () => ({
            id: id++,
            number: id++,
          }),
          ...customResolvers,
        }}
      >
        {children}
      </ApolloMockedProvider>
    </RouterWrapper>
  )

  return render(ui, { wrapper: MockedWrapper, ...options })
}
```

Now any `Section.id` will be a distinct number. We include `Section.number` (which is currently randomly generated) as well, just to make sure it will also be distinct.

And now our test passes:

```
 PASS  src/components/TableOfContents.test.js
  TableOfContents
    ✓ renders loading status and chapters (173ms)

  console.log src/setupTests.js:18
    {
      "data": {
        "chapters": [
          {
            "id": 52,
            "number": 4.76048836297727,
            "title": "Chapter-title",
            "sections": [
              {
                "id": "1",
                "number": 2,
                "title": "Hello World",
                "__typename": "Section"
              },
              {
                "id": "3",
                "number": 4,
                "title": "Hello World",
                "__typename": "Section"
              }
            ],
            "__typename": "Chapter"
          },
          {
            "id": -26,
            "number": -66.27698741173478,
            "title": "Chapter-title",
            "sections": [
              {
                "id": "5",
                "number": 6,
                "title": "Hello World",
                "__typename": "Section"
              },
              {
                "id": "7",
                "number": 8,
                "title": "Hello World",
                "__typename": "Section"
              }
            ],
            "__typename": "Chapter"
          }
        ]
      }
    }

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        6.083s
Ran all test suites related to changed files.
```

✅

While we’re writing and debugging tests, we may find the `screen.debug()` function useful: it logs the current HTML, like this:

```js
describe('TableOfContents', () => {
  it('renders loading status and chapters', async () => {
    mockedRender(<TableOfContents />, {
      Chapter: () => ({
        title: () => 'Chapter-title',
      }),
    })

    screen.getByRole('status')
    screen.debug()
    await wait()
    screen.getAllByText('Chapter-title')
  })
})
```

```html
<body>
  <div>
    <nav
      class="TableOfContents"
    >
      <div>
        <div
          class="sr-only"
          role="status"
        >
          Loading
        </div>
        <h1>
          <span>
            <span
              class="react-loading-skeleton css-1vmnjpn-skeletonStyles-Skeleton"
            >
              ‌
            </span>
          </span>
        </h1>
        <span>
          <span
            class="react-loading-skeleton css-1vmnjpn-skeletonStyles-Skeleton"
          >
            ‌
          </span>
          <span
            class="react-loading-skeleton css-1vmnjpn-skeletonStyles-Skeleton"
          >
            ‌
          </span>
          <span
            class="react-loading-skeleton css-1vmnjpn-skeletonStyles-Skeleton"
          >
            ‌
          </span>
          <span
            class="react-loading-skeleton css-1vmnjpn-skeletonStyles-Skeleton"
          >
            ‌
          </span>
        </span>
      </div>
    </nav>
  </div>
</body>
```

Now that we’ve tested a component that calls `useQuery()`, let’s test a component that calls `useMutation()`. `<Review>` calls the `removeReview` mutation when the Delete menu item is selected (and the subsequent dialog’s "Sudo delete" button is pressed). In our test, we can wait until the `reviews` query data is rendered and then trigger the necessary clicks on the page. And we can mock an error response, which should result in `alert('👮‍♀️✋ You can only delete your own reviews!')` being called:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/blob/28_0.2.0/src/components/Reviews.js)

```js
  function deleteReview() {
    closeMenu()
    removeReview({
      variables: { id },
      optimisticResponse: {
        removeReview: true,
      },
    }).catch((e) => {
      if (find(e.graphQLErrors, { message: 'unauthorized' })) {
        alert('👮‍♀️✋ You can only delete your own reviews!')
      }
    })
  }
```

Here’s the test:

[`src/components/Reviews.test.js`](https://github.com/GraphQLGuide/guide/blob/28_0.2.0/src/components/Reviews.test.js)

```js
import React from 'react'
import { screen, fireEvent } from '@testing-library/react'

import Reviews from './Reviews'

describe('Reviews', () => {
  it('alerts when deleting', async () => {
    jest.spyOn(window, 'alert').mockImplementation(() => {})

    mockedRender(<Reviews />, {
      Mutation: () => ({
        removeReview: () => {
          throw new Error('unauthorized')
        },
      }),
    })

    await wait()
    fireEvent.click(screen.getAllByRole('button', { name: 'Open menu' })[0])
    await wait()
    fireEvent.click(screen.getAllByRole('menuitem', { name: 'Delete' })[0])
    await wait()
    fireEvent.click(screen.getAllByRole('button', { name: 'Sudo delete' })[0])
    await wait()
    expect(window.alert).toHaveBeenCalled()
  })
})
```

First we spy on `window.alert` so that we can test at the end whether it’s been called. We also mock it, because otherwise, we’d get this error:

```
console.error node_modules/jsdom/lib/jsdom/virtual-console.js:29
  Error: Not implemented: window.alert
    at module.exports (/Users/me/gh/guide/node_modules/jsdom/lib/jsdom/browser/not-implemented.js:9:17)
    at /Users/me/gh/guide/node_modules/jsdom/lib/jsdom/browser/Window.js:728:7  
```

`jsdom`, the library that Jest is using to render our React components, doesn’t support `window.alert`, so we need to implement it.

We call `mockedRender()` with the component we’re testing, `<Reviews />`, and a custom resolver for `Mutation.removeReview`. After that, we `await wait()` so we know that the list of reviews has been provided by `useQuery(REVIEWS_QUERY)` and the component has been re-rendered with data. Then, we click the menu button, wait for React to react to the click and re-render, click and wait a couple more times, and then check that `window.alert` was called.

The below line doesn’t work yet, as there is no button with a name of `Open menu`:

```js
fireEvent.click(screen.getAllByRole('button', { name: 'Open menu' })[0])
```

We can give it a name by setting the button’s `aria-label`:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/blob/28_0.2.0/src/components/Review.js)

```js
<IconButton aria-label="Open menu" onClick={openMenu}>
  <MoreVert />
</IconButton>
```

The other two clicks work, because `name` matches against the text node child:

```js
fireEvent.click(screen.getAllByRole('menuitem', { name: 'Delete' })[0])
fireEvent.click(screen.getAllByRole('button', { name: 'Sudo delete' })[0])
```

```js
<MenuItem
  onClick={() => {
    closeMenu()
    setDeleteConfirmationOpen(true)
  }}
>
  Delete
</MenuItem>
```

```js
<Button onClick={deleteReview} color="primary" autoFocus>
  Sudo delete
</Button>
```

We can run our test with:

```sh
$ npm test -- -t alerts
```

`--` tells npm to pass what follows to the test command, and `-t alerts` tells Jest to run tests with names that contain "alerts" (for more command-line options, run `npx jest -h`). 

We get this error:

```js
 FAIL  src/components/Reviews.test.js (7.098s)
  ● Console

    console.warn node_modules/react/cjs/react.development.js:315
      Warning: React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.
    console.log src/setupTests.js:18
      {
        "errors": [
          {
            "message": "No mock defined for type \"ObjID\"",
            "locations": [],
            "path": [
              "currentUser",
              "id"
            ]
          }
        ],
        "data": {
          "currentUser": null
        }
      }
```

The `React.createFactory()` warning we can ignore, but the `"No mock defined for type \"ObjID\""` error is a problem. That’s coming from `ApolloMockedProvider`, and it means we need to add a resolver for `ObjID`:

[`src/setupTests.js`](https://github.com/GraphQLGuide/guide/blob/28_0.2.0/src/setupTests.js)

```js
const MockedWrapper = ({ children }) => (
  <RouterWrapper>
    <ApolloMockedProvider
      customResolvers={{
        Section: () => ({
          id: id++,
          number: id++,
        }),
        ObjID: () => id++,
        ...customResolvers,
      }}
    >
      {children}
    </ApolloMockedProvider>
  </RouterWrapper>
)
```

Now our test passes:

```
$ npm test -- -t alerts

 PASS  src/components/Reviews.test.js (8.903s)
  ● Console

    console.log src/setupTests.js:18
      {
        "data": {
          "currentUser": {
            "id": 1,
            "firstName": "Hello World",
            "name": "Hello World",
            "username": "Hello World",
            "email": "Hello World",
            "photo": "Hello World",
            "hasPurchased": "TEAM",
            "favoriteReviews": [
              {
                "id": 2,
                "__typename": "Review"
              },
              {
                "id": 3,
                "__typename": "Review"
              }
            ],
            "__typename": "User"
          }
        }
      }
    console.log src/setupTests.js:18
      {
        "data": {
          "reviews": [
            {
              "id": 4,
              "text": "Hello World",
              "stars": 11,
              "createdAt": -50.81164015087056,
              "favorited": false,
              "author": {
                "id": 5,
                "name": "Hello World",
                "photo": "Hello World",
                "username": "Hello World",
                "__typename": "User"
              },
              "__typename": "Review"
            },
            {
              "id": 6,
              "text": "Hello World",
              "stars": -84,
              "createdAt": -38.71062432606376,
              "favorited": false,
              "author": {
                "id": 7,
                "name": "Hello World",
                "photo": "Hello World",
                "username": "Hello World",
                "__typename": "User"
              },
              "__typename": "Review"
            }
          ]
        }
      }
    console.log src/setupTests.js:18
      {
        "data": {
          "reviewCreated": {
            "id": 8,
            "text": "Hello World",
            "stars": 82,
            "createdAt": -69.828879356296,
            "favorited": false,
            "author": {
              "id": 9,
              "name": "Hello World",
              "photo": "Hello World",
              "username": "Hello World",
              "__typename": "User"
            },
            "__typename": "Review"
          }
        }
      }
    console.log src/setupTests.js:18
      {
        "data": {
          "reviewCreated": {
            "id": 10,
            "text": "Hello World",
            "stars": -27,
            "createdAt": -93.91597055206873,
            "favorited": true,
            "author": {
              "id": 11,
              "name": "Hello World",
              "photo": "Hello World",
              "username": "Hello World",
              "__typename": "User"
            },
            "__typename": "Review"
          }
        }
      }
    console.log src/setupTests.js:18
      {
        "errors": [
          {
            "message": "unauthorized",
            "locations": [],
            "path": [
              "removeReview"
            ]
          }
        ],
        "data": {
          "removeReview": null
        }
      }

Test Suites: 1 skipped, 1 passed, 1 of 2 total
Tests:       1 skipped, 1 passed, 2 total
Snapshots:   0 total
Time:        10.277s, estimated 11s
Ran all test suites with tests matching "alerts".

Active Filters: test name /alerts/
 › Press c to clear filters.
```

It passed! And it logs what data the mocked provider provides for all operations triggered during the test: `Query.currentUser`, `Query.reviews`, `Subscription.reviewCreated`, and `Mutation.removeReview`, which we can see contains the error we expect.

`apollo-mocked-provider` contains a convenience provider—the `ApolloErrorProvider` we have in `src/setupTests.js`. It returns an error for all operations, so we don’t need to write a resolver that throws. In our test, we could try using it with:

```js
render(
  <ApolloErrorProvider>
    <Reviews />
  </ApolloErrorProvider>
)
```

But then `Query.reviews` would return an error as well, and we wouldn’t have any reviews to click on during the test, so it would fail. Also, we’d want to set the specific error text to trigger our alert, so we’d do:

```js
render(
  <ApolloErrorProvider graphQLErrors={[{ message: 'unauthorized' }]>
    <Reviews />
  </ApolloErrorProvider>
)
```

Another provider we have from the library is `ApolloLoadingProvider`, which keeps Apollo in the loading state. We can use it like this:

[`src/components/Section.test.js`](https://github.com/GraphQLGuide/guide/blob/28_0.2.0/src/components/Section.test.js)

```js
import React from 'react'
import { screen } from '@testing-library/react'

import Section from './Section'

describe('Section', () => {
  it('should render loading status', async () => {
    render(
      <ApolloLoadingProvider>
        <Section />
      </ApolloLoadingProvider>
    )

    screen.getByRole('status')
  })
})
```

As before, we need to add a role to the skeleton that `<Section>` is using:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/28_0.2.0/src/components/Section.js)

```js
sectionContent = (
  <div role="status">
    <Skeleton count={7} />
  </div>
)
```

We can see that with `npm test -- -t Section`, it passes!

Also, note that our test would continue to pass if we waited, as `ApolloLoadingProvider` stays in the loading state:

```js
  it('should render loading status', async () => {
    render(
      <ApolloLoadingProvider>
        <Section />
      </ApolloLoadingProvider>
    )

    screen.getByRole('status')
    await wait()
    screen.getByRole('status')
  })
```

For our last test, let’s use [`<MockedProvider>`](https://www.apollographql.com/docs/react/development-testing/testing/#mockedprovider), the mocking provider included with Apollo Client. Instead of defining resolvers, we pass in a `mocks` parameter that lists `(request, result)` pairings. Then, during the test, whenever an operation is sent that matches a mock `request`, the corresponding `result` is returned. For `TableOfContents`, the `request` is `{ query: CHAPTER_QUERY }`, and we write out the result data to match the fields selected in the query:

[`src/components/TableOfContents.test.js`](https://github.com/GraphQLGuide/guide/blob/28_0.2.0/src/components/TableOfContents.test.js)

```js
import { MockedProvider } from '@apollo/client/testing'

import TableOfContents, { CHAPTER_QUERY } from './TableOfContents'

const mocks = [
  {
    request: { query: CHAPTER_QUERY },
    result: {
      data: {
        chapters: [
          {
            id: 1,
            number: 1,
            title: 'mocks-title',
            sections: [
              {
                id: '1',
                number: 1,
                title: 'Hello World',
              },
              {
                id: '2',
                number: 2,
                title: 'Hello World',
              },
            ],
          },
          {
            id: 2,
            number: 2,
            title: 'mocks-title',
            sections: [
              {
                id: '3',
                number: 3,
                title: 'Hello World',
              },
              {
                id: '4',
                number: 4,
                title: 'Hello World',
              },
            ],
          },
        ],
      },
    },
  },
]

describe('TableOfContents', () => {
  it('renders loading status and chapters', ...)

  it('works with MockedProvider', async () => {
    render(
      <MockedProvider mocks={mocks} addTypename={false}>
        <TableOfContents />
      </MockedProvider>
    )

    await wait()
    screen.getAllByText('mocks-title')
  })
})
```

For convenience, we’re omitting the `__typename` field in our mock response, so we tell Apollo to not add `__typename` to our request documents like it usually does (`addTypename={false}`).

Now we have all four tests passing across three test files. We’ve used `ApolloMockedProvider`, `ApolloLoadingProvider`, and `MockedProvider`, and seen how to use `ApolloErrorProvider`. We’ve tested queries and a mutation and seen `ApolloMockedProvider` working with a subscription. We’ve also seen the difference between testing `<TableOfContents>` with `ApolloMockedProvider` versus `MockedProvider` (the former was much shorter 😄).

One last thing is that while our tests are passing, our linting no longer is! 

```sh
$ npm run lint

> guide@1.0.0 lint /Users/me/gh/guide
> eslint src/


/Users/me/gh/guide/src/components/Reviews.test.js
  10:5   error  'mockedRender' is not defined  no-undef
  18:11  error  'wait' is not defined          no-undef
  20:11  error  'wait' is not defined          no-undef
  22:11  error  'wait' is not defined          no-undef
  24:11  error  'wait' is not defined          no-undef

/Users/me/gh/guide/src/components/Section.test.js
   8:5   error  'render' is not defined                 no-undef
   9:8   error  'ApolloLoadingProvider' is not defined  react/jsx-no-undef
  15:11  error  'wait' is not defined                   no-undef

/Users/me/gh/guide/src/components/TableOfContents.test.js
  55:5   error  'mockedRender' is not defined  no-undef
  62:11  error  'wait' is not defined          no-undef
  67:5   error  'render' is not defined        no-undef
  73:11  error  'wait' is not defined          no-undef

✖ 12 problems (12 errors, 0 warnings)
```

The global variables are not defined in the files in which we’re using them! The solution to this problem is:

- To say "John & Loren, y’all are silly. Global variables? What is this, jQuery?!" and fix `src/setupTests.js` by replacing all the `global.*` lines with export statements.
- Decide that the convenience is worth the overhead of new devs learning about them, and fix our linter!

To do the latter solution, we add a `globals` field to our config file:

[`.eslintrc.js`](https://github.com/GraphQLGuide/guide/blob/28_0.2.0/.eslintrc.js)

```js
module.exports = {
  extends: 'react-app',
  plugins: ['graphql'],
  parser: 'babel-eslint',
  globals: {
    wait: 'readonly',
    render: 'readonly',
    mockedRender: 'readonly',
    ApolloMockedProvider: 'readonly',
    ApolloErrorProvider: 'readonly',
    ApolloLoadingProvider: 'readonly',
  },
  rules: {
    'graphql/template-strings': [ ...  ],
    'react/jsx-no-undef': ['error', { allowGlobals: true }],
  },
}
```

`globals` takes care of the `no-undef` lint errors, but we still have the [`react/jsx-no-undef`](https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-undef.md) error, which we can fix with this rule: `'react/jsx-no-undef': ['error', { allowGlobals: true }],`.

And now `npm run lint` passes ✅😊.

