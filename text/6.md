# Chapter 6: React

Chapter contents:

* [Setting up](6.md#setting-up)
  * [Build options](6.md#build-options)
  * [App structure](6.md#app-structure)
  * [Set up Apollo](6.md#set-up-apollo)
* [Querying](6.md#querying)
  * [First query](6.md#first-query)
  * [Loading](6.md#loading)
  * [Polling](6.md#polling)
  * [Subscriptions](6.md#subscriptions)
  * [Lists](6.md#lists)
  * [Query variables](6.md#query-variables)
  * [Skipping queries](6.md#skipping-queries)
* [Authentication](6.md#authentication)
  * [Logging in](6.md#logging-in)
  * [Resetting](6.md#resetting)
* [Mutating](6.md#mutating)
  * [First mutation](6.md#first-mutation)
  * [Listing reviews](6.md#listing-reviews)
  * [Optimistic updates](6.md#optimistic-updates)
  * [Arbitrary updates](6.md#arbitrary-updates)
  * [Creating reviews](6.md#creating-reviews)
  * [Using fragments](6.md#using-fragments)
  * [Deleting](6.md#deleting)
  * [Error handling](6.md#error-handling)
  * [Editing reviews](6.md#editing-reviews)
* [Advanced querying](6.md#advanced-querying)
  * [Paginating](6.md#paginating)
    * [Offset-based](6.md#offset-based)
      * [page](6.md#page)
      * [skip & limit](6.md#skip-&-limit)
    * [Cursors](6.md#cursors)
      * [after](6.md#after)
      * [orderBy](6.md#orderby)
  * Updating multiple queries
  * Local state
  * withUser
  * Reviews subscription
  * Batching
  * Prefetching
  * Persisting
* Extended topics
  * SSR
  * Offline
  * Testing
  * Linting

---

Background: [single-page application](bg.md#spa), [HTTP](bg.md#http), [Node](bg.md#node-&-npm-&-nvm), [git](bg.md#git), [JSON](bg.md#json), [JavaScript](bg#javascript)

In this chapter, we’ll learn to use the [`react-apollo`](https://www.apollographql.com/docs/react/) library through building the Guide web app—the code behind the [https://graphql.guide](https://graphql.guide/Preface) site, where we can sign in, read the book, and write reviews. *[Beta note: the site isn’t yet complete, so you’ll see lorem ipsum in place of book content 😄.]* We’ll go through setup, simple queries, complex queries, auth, and mutations for creating, updating, and deleting. Then we’ll cover advanced topics like infinite scrolling, local state, SSR, working offline, and performance. Here’s what it will look like:

![Guide app](img/guide-app.png)

React was released by Facebook in 2013, and it has since steadily increased in
popularity, surpassing Angular in GitHub stars in 2016 to become the most
popular Javascript view library. It continues to be developed by a team at
Facebook, who have merged in contributions from over one thousand community
members.

# Setting up

Section contents:

* [Build options](6.md#build-options)
* [App structure](6.md#app-structure)
* [Set up Apollo](6.md#set-up-apollo)

## Build options

Background: [server-side rendering](bg.md#ssr)

In the early days, setting up a new React app was plagued by complex Webpack and
Babel configurations. There are now a number of tools for this, three of which
we recommend: Create React App, Next.js, and Meteor.

> [Babel](https://babeljs.io/) converts our modern JavaScript to old JavaScript so it will run in the browser or Node. [Webpack](https://webpack.js.org/) bundles our JavaScript and other files together into a website.

### Create React App

```sh
npm i -g create-react-app
create-react-app guide
cd guide/
npm start
```

[Create React App](https://github.com/facebookincubator/create-react-app) (CRA)
is a tool that configures Webpack and Babel to good, common defaults. For
deployment, running `npm run build` gives us an `index.html`, our Javascript
bundle (or multiple bundles if we’re code splitting), and imported static assets
like CSS, images, and fonts.

### Next.js

```sh
npm i -g create-next-app
create-next-app guide
cd guide/
npm run dev
```

[Next.js](https://github.com/zeit/next.js) is similar to CRA in that it takes
care of Webpack/Babel for us, but it also does [server-side rendering](bg.md#ssr)
(SSR), routing, automatic page-level code splitting, dynamic importing, and hot
code reloading. CRA is just a dev server and build tool, whereas Next, since it
also does SSR, is also a Node production server.

> Next does have an `export` command that outputs html and js that you can
> serve as static files (like CRA’s `build` command), and it will include
> server-rendered html for your pages, but they are rendered once at the time
> that you run the `export` command, instead of in real time whenever a client
> requests the site.

### Meteor
https://github.com/GraphQLGuide/guide.git
```sh
curl https://install.meteor.com/ | sh
git clone https://github.com/jamiter/meteor-starter-kit.git guide
cd guide/
npm install
meteor
```

[Meteor](https://www.meteor.com) is similar to Next in that it is not only the
build tool but also the production server. Unlike CRA and Next, it does not use
Webpack—it has its own advanced build system that is blissfully
configuration-free. It does not have built-in SSR like Next does, but it does
have dynamic imports, and all dynamically imported modules are fetched quickly
over a WebSocket and [cached on the client](https://blog.meteor.com/announcing-meteor-1-5-b82be66571bb) (in
[IndexedDB](https://en.wikipedia.org/wiki/Indexed_Database_API)). It also does [differential bundling](https://blog.meteor.com/meteor-1-7-and-the-evergreen-dream-a8c1270b0901), further reducing bundle size for modern browsers.

## App structure

For our Guide app, we’ll use CRA, because it’s the most widely used and the most
basic, straightforward option. Here’s our starter app:

```sh
git clone https://github.com/GraphQLGuide/guide.git
cd guide/
git checkout 0_0.1.0
npm install
```

Now we should be able to run CRA’s development server:

```sh
npm start
```

And see our app at [localhost:3000](http://localhost:3000/):

![Create React App starting site](/img/cra.png)

Our file structure is very similar to what we get when we run
`create-react-app`:

```
.
├── .eslintrc
├── .gitignore
├── package-lock.json
├── package.json
├── public
│   ├── favicon.ico
│   ├── index.html
│   └── manifest.json
└── src
    ├── App.test.js
    ├── components
    │   └── App.js
    ├── index.css
    ├── index.js
    ├── jsconfig.json
    ├── logo.svg
    └── registerServiceWorker.js
```

`.eslintrc` — The CRA dev server (`npm start`) outputs linter warnings ([background on ESLint](https://eslint.org/docs/about/), but it’s
nice to see the warnings directly in our text editor, so we have an `.eslintrc`
file that uses the same rules as the dev server. Most editors’ eslint plugins
will pick this up, including
[`eslint`](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)
for our recommended editor, [VS Code](https://code.visualstudio.com/).

`package.json`

```json
{
  "name": "guide",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^16.0.0",
    "react-dom": "^16.0.0",
    "react-scripts": "1.0.14",
    …
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject",
    …
  }
}
```

We have our normal react dependencies, `react` and `react-dom`, plus
`react-scripts`, which is what CRA lives inside, and which provides the
commands:

* `npm start` starts the dev server
* `npm run build` bundles app for deployment
* `npm test` runs all the tests found in `*.test.js` files
* `npm run eject` takes us out of CRA (replaces `react-scripts` with a long list
  of other packages, add a `scripts/` directory, and adds an 8-file `config/` directory
  with Webpack, Babel, and testing configuration)

In our `public/` directory, we have a
[favicon](https://en.wikipedia.org/wiki/Favicon), `manifest.json`, which is used
when our app is added to an Android homescreen, and our only HTML page:

`public/index.html` — our [SPA](bg.md#spa) shell, basically just:

```html
<!doctype html>
<html lang="en">
  <head>
    <title>The GraphQL Guide</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
```

We can add HTML, like meta tags to the head or the Google Analytics tracking
script to the bottom of the body. Our React Javascript code gets added to the
body, and when it runs, it puts the app inside the root tag `<div
id="root"></div>`:

[`src/index.js`](https://github.com/GraphQLGuide/guide/blob/0_0.1.0/src/index.js)

```js
import React from 'react'
import ReactDOM from 'react-dom'
import './index.css'
import App from './App'
import registerServiceWorker from './registerServiceWorker'

ReactDOM.render(<App />, document.getElementById('root'))

registerServiceWorker()

module.hot.accept()
```

`import './index.css'` — CRA supports importing CSS from Javascript. There are
many ways to do CSS with React, and we’ll be sticking with this single plain
`.css` file so that we can focus on the GraphQL parts of app-building.

`registerServiceWorker()` — CRA includes a service worker (set up by
`src/registerServiceWorker.js`) that caches our assets in the browser so that
our app loads faster
([more info](https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#making-a-progressive-web-app)).

`ReactDOM.render(<App />, document.getElementById('root'))`: Our only component,
`<App />`, gets rendered into the `#root` div.

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/blob/0_0.1.0/src/components/App.js):

```js
import React, { Component } from 'react'
import logo from './logo.svg'

class App extends Component {
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h1 className="App-title">The GraphQL Guide</h1>
        </header>
        <p className="App-intro">
          To get started, edit <code>src/App.js</code>, and save to reload.
        </p>
      </div>
    )
  }
}

export default App
```

`import logo from './logo.svg'` — CRA supports importing files, like images and
fonts. When you import a file, it gets included in the app bundle, and you get a
URL that you can use—for example, in a `src` attribute:

```html
<img src={logo} className="App-logo" alt="logo" />
```

We also have a test file:

[`src/App.test.js`](https://github.com/GraphQLGuide/guide/blob/0_0.1.0/src/App.test.js):

```js
import React from 'react'
import ReactDOM from 'react-dom'
import App from './App'

it('renders without crashing', () => {
  const div = document.createElement('div')
  ReactDOM.render(<App />, div)
})
```

This and any other files ending in `.test.js` get run when we do `npm test`.

The last thing in `src/` is our
[jsconfig.json](https://code.visualstudio.com/docs/languages/jsconfig) file,
which tells VS Code what type of Javascript we’re using (CRA includes, for
example, async/await from ES2017) and where it’s located.

## Set up Apollo

The best GraphQL library for React is
[`react-apollo`](https://www.apollographql.com/docs/react/). It has all the features we
talked about in the [Client Libraries](#client-libraries) section and more. Our `package.json` already has these packages, but normally we would install `react-apollo` and its associated packages with:

```sh
npm i -S react-apollo graphql graphql-tag apollo-client apollo-cache-inmemory apollo-link-http
```

Now we need to create an instance of `ApolloClient` and wrap our app JSX in a
component called `<ApolloProvider>`, which provides our client instance to all
descendants. So we go to `src/index.js` where our `<App />` component is
rendered, and replace the `ReactDOM.render` line with:

[`src/index.js`](https://github.com/GraphQLGuide/guide/blob/1_0.1.0/src/index.js)

```js
import { ApolloClient } from 'apollo-client'
import { ApolloProvider } from 'react-apollo'
import { InMemoryCache } from 'apollo-cache-inmemory'
import { createHttpLink } from 'apollo-link-http'

const link = createHttpLink({
  uri: 'https://api.graphql.guide/graphql'
})

const cache = new InMemoryCache()

const client = new ApolloClient({ link, cache })

ReactDOM.render(
  <ApolloProvider client={client}>
    <App />
  </ApolloProvider>,
  document.getElementById('root')
)
```

> We highly recommend typing out the code instead of copy/pasting—you’ll learn
> it better! 🤔😏👊

We tell `ApolloClient` where to send queries by giving it a network link pointed
at our GraphQL server—in this case `https://api.graphql.guide/graphql`.

# Querying

Section contents:

* [First query](6.md#first-query)
* [Loading](6.md#loading)
* [Polling](6.md#polling)
* [Subscriptions](6.md#subscriptions)
* [Lists](6.md#lists)
* [Query variables](6.md#query-variables)
* [Skipping queries](6.md#skipping-queries)

## First query

One of the fields we can query for is `githubStars`, the number of stars the
Guide’s [github repo](https://github.com/GraphQLGuide/guide) has. Let’s look at
how we can make that query and display the results—we’ll start out by adding a
component to display the star count:

[`src/components/StarCount.js`](https://github.com/GraphQLGuide/guide/blob/1_0.1.0/src/components/StarCount.js)

```js
import React from 'react'

const StarCount = ({ githubStars }) => {
  return (
    <a className="StarCount" href="https://github.com/GraphQLGuide/guide">
      {githubStars}
    </a>
  )
}
```

But how do we get `githubStars` as a prop? First we write the query, which is
pretty simple, since it’s a top-level
[scalar](3.md#scalar-types) query field:

```js
import gql from 'graphql-tag'

const STARS_QUERY = gql`
  query StarsQuery {
    githubStars
  }
`
```

We name it `STARS_QUERY` because convention is to use all caps for query
constants. We use an
[operation name](http://graphql.org/learn/queries/#operation-name)
(`StarsQuery`) so that it’s easier to find and debug. `gql` is a
[template literal tag](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals)
that parses our [query document](2.md#document) string, converting it into a structured object
that we can pass to Apollo—now we can give it to Apollo’s `<Query>` component:

```js
import PropTypes from 'prop-types'
import { Query } from 'react-apollo'

const StarCount = …

StarCount.propTypes = {
  githubStars: PropTypes.number,
  loading: PropTypes.bool.isRequired
}

export default () => (
  <Query query={STARS_QUERY}>
    {({ data: { githubStars }, loading }) => (
      <StarCount githubStars={githubStars} loading={loading} />
    )}
  </Query>
)
```

It follows the [render prop](https://reactjs.org/docs/render-props.html) pattern, in which `Query` calls `children` as a function, giving the function an object argument with information about the query. There are [many object attributes](https://www.apollographql.com/docs/react/essentials/queries.html#render-prop) we can choose from, but for now, we’ll just use `data` (the `"data"` attribute in the response from the server) and `loading`, a boolean that lets us know when we’re waiting
for the response to arrive from the server. In our `children` function (which is called the render prop), we pass those two arguments as props to `<StarCount>`.

When the page is loaded and the `<Query>` component is created, Apollo will send the query to the server and give the result to our render prop. Now we can add the component to our app:

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/compare/0_0.1.0...1_0.1.0)

```jsx
import StarCount from './StarCount'
…
<header className="App-header">
  <StarCount />
  <img src={logo} className="App-logo" alt="logo" />
  <h1 className="App-title">The GraphQL Guide</h1>
</header>
```

And we have a working GraphQL-backed app!

![GitHub stars in header](/img/stars.png)

🙌👊

`react-apollo` provides two APIs for making queries—the `<Query>` render prop API, and the HOC ([higher-order component](https://reactjs.org/docs/higher-order-components.html)) API. Which we use is mostly a matter of preference—the one thing the render prop API can do that the HOC API can’t is use a dynamic query. The aesthetic differences are whether we’re providing querying options and child component props in JSX (render prop) or JS objects (HOC), and whether we combine multiple queries by nesting JSX or composing HOCs. Since we’ll be writing components that use multiple queries and mutations, and we have limited horizontal width in our ebook readers, we’ll avoid highly nested JSX by mostly using HOCs. Note that it’s easy to translate between the two APIs, since they have the same props and provide us with the same information. So when we learn one API, we learn both. 

Here’s the same component using `react-apollo`’s [`graphql()`](https://www.apollographql.com/docs/react/api/react- apollo.html#graphql) HOC API:

```js
import { graphql } from 'react-apollo'

const StarCount = …

const withData = graphql(STARS_QUERY, {
  props: ({ data: { githubStars, loading } }) => ({
    githubStars,
    loading
  })
})

export default withData(StarCount)
```

`graphql()` creates an HOC, which we call `withData` and use to wrap `StarCount`. The first parameter to `graphql()` is the query (which is why with the HOC API, we can’t change the query), and the second is an optional config object—we’re using the `props` config function, which tells Apollo which props we want our component to be given. The function gets the query response, in the form:

```json
{
  data: {
    githubStars: 1,
    loading: false,
    other things…
  }
}
```

and returns which props we want—in this case `githubStars` and `loading`—instead of the default `data` prop with a [long list of things](https://www.apollographql.com/docs/react/api/react-apollo.html#graphql-query-options).

## Loading

> If you’re jumping in here, `git checkout 1_0.1.0` ([tag 1_0.1.0](https://github.com/GraphQLGuide/guide/tree/1_0.1.0), or compare [1...2](https://github.com/GraphQLGuide/guide/compare/1_0.1.0...2_0.1.0))

When we reload the app, we see a flash of `⭐️ stars` before the number appears,
pushing `stars` to the right. When `<StarCount>` is rendered the first time, it
doesn’t have the number of stars yet, but it tells Apollo to send the query.
Once the query response comes back from the server, <StarCount> is re-rendered,
this time with the number. Let’s log to see it happening:

[`src/components/StarCount.js`](https://github.com/GraphQLGuide/guide/blob/1_0.1.0/src/components/StarCount.js)

```js
const StarCount = ({ githubStars, loading }) => {
  console.log(
    'rendering StarCount',
    `githubStars: ${githubStars}, loading: ${loading}`
  )
```

```
rendering StarCount
githubStars: undefined, loading: true
rendering StarCount
githubStars: 8, loading: false
```

We see that it’s rendered twice—first `loading` is `true` and `githubStars` is
`undefined`, and then later, once the query has finished, `loading` is `false`
and `githubStars` has a value.

`⭐️ stars` without a number doesn’t make sense, and `stars` jumping to the
right when the number appears doesn’t look nice, so let’s hide
everything until the number has arrived by adding the modifier CSS class
`'loading'` when the `loading` prop is `true`:

```js
import classNames from 'classnames'

const StarCount = ({ githubStars, loading }) => {
  return (
    <a className={classNames('StarCount', { loading })}
```

> `classNames` takes strings or objects as arguments and combines them into a
> React `className` string. For objects, it includes the key if the value is
> true. For example, `classNames('a', { b: false, c: true }, 'd')` returns `'a c
> d'`.

When `loading` becomes `false`, the CSS class `'loading'` is removed, and the
component fades in.

## Polling

Right now our star count is static—once it’s fetched, the number remains on the
page until the page is refreshed. If the actual number of stars on the
repository changes, we won’t know until we refresh. If we want to keep the
number (and any other GraphQL data) up to date, we can do so in two different
ways: polling and [subscriptions](2.md#subscriptions). Polling is much easier to
implement, so let’s do that first. We can add a [`pollInterval`](https://www.apollographql.com/docs/react/essentials/queries.html#refetching) prop to our query in `StarCount.js`:

[`src/components/StarCount.js`](https://github.com/GraphQLGuide/guide/compare/1_0.1.0...2_0.1.0)

```js
<Query query={STARS_QUERY} pollInterval={5 * 1000}>
  {({ data: { githubStars }, loading }) => (
    <StarCount githubStars={githubStars} loading={loading} />
  )}
</Query>
```

Now every five seconds, Apollo
will resend our `STARS_QUERY`. If the response has a different value for
`githubStars`, Apollo will pass us the new prop, which will trigger a
component re-render, and the new count will be displayed on the page.

The equivalent [`pollInterval` option](https://www.apollographql.com/docs/react/basics/queries.html#graphql-config-options-pollInterval) with `graphql()` is:

```js
const withData = graphql(STARS_QUERY, {
  options: { pollInterval: 5 * 1000 },
  props: …
})
```

Depending on what type of data we’re keeping up to date, we may want to use some
kind of visual cue or animation when it changes. There are a few possible
motivations for this:

1. Calling attention to the change to make the user aware that it
   happened—a common example in this category is the brief yellow background glow.
   Another example is in Google Docs—the colored cursor labeled with a name that
   follows someone’s live edits. However, sometimes a user doesn’t need to know
   that a piece of data has changed, and calling attention to it would
   needlessly distract them from what they were paying attention to.
2. Making the change visually smoother. If a change in the data triggers some
   node on the page to change in size, and there are other nodes on the page
   around it, the other nodes might jump to a new location when the browser
   reflows—for example, if the data is a paragraph of text, and the updated
   paragraph is twice as long, everything below that paragraph will be pushed
   down. We can make this change look nicer by animating the data container to
   its new size and animating the displaced components to their new locations.
   This also gives time for the user to notice which part of the page changed,
   which is helpful for situations in which the user doesn’t realize why things on
   the page jumped around.
3. For fun 😄. Animations can be fun, and sometimes we add them just because we like how it feels.

The data change that happens in our app is a number that is usually just going
up by 1. This type of change is well-suited to an odometer animation, where each
digit is on a number wheel that rotates up or down to reveal the next number.
The benefit of this animation is #3, and the downside is #1—the odometer
changing draws more attention to the change than a non-animated change does, but
the user doesn’t need to know when the star count changes (they’re just trying
to read the book!). So we might not add this animation to a serious app, but
let’s add it to our app for fun 😊. It’s easy with the
[`react-odometerjs`](https://www.npmjs.com/package/react-odometerjs) component:

[`src/components/StarCount.js`](https://github.com/GraphQLGuide/guide/compare/1_0.1.0...2_0.1.0)

```js
import Odometer from 'react-odometerjs'

…

    <a
      className={classNames('StarCount', { loading })}
      href="https://github.com/GraphQLGuide/guide"
    >
      {githubStars && <Odometer value={githubStars} />}
    </a>
```

Now when the polling `STARS_QUERY` results in a new `githubStars` value, we pass
the new number to the `<Odometer>` component, which does the animation.

> We need the truth guard (`githubStars &&`) because `<Odometer>` throws an
> error when it’s given an `undefined` value (and as we found out
> [before](#loading) when logging, `githubStars` starts out `undefined`).

We can test it out by starring and un-starring
the [repository on GitHub](https://github.com/GraphQLGuide/guide) and watching the number
in our app update.

## Subscriptions

Background: [webhooks](bg.md#webhooks)

> If you’re jumping in here, `git checkout 2_0.1.0` ([tag 2_0.1.0](https://github.com/GraphQLGuide/guide/tree/2_0.1.0), or compare [2...3](https://github.com/GraphQLGuide/guide/compare/2_0.1.0...3_0.1.0))

When we poll for new data every 5 seconds, it takes 2.5 seconds on average (as
little as 0, and as much as 5) for a change to show up, plus a little time for
the server to talk to GitHub and get the response back to us. For certain types
of apps, like a chat app or multiplayer games, it’s important to receive updates
in less than 2.5 seconds. One thing we can do is reduce the poll interval—for
instance, a 500 ms interval would mean an average update speed of 250 ms (plus
server response time). This would be fast enough for a chat app but not fast
enough for some games. And it comes at a certain cost in server workload (it now
has to respond to 10 times as many requests) and browser workload (sending
requests takes up main-thread JavaScript time, perhaps during one of the
[10ms windows](https://developers.google.com/web/fundamentals/performance/rail)
in which the thread needs to quickly calculate a 60 fps animation). So
while polling is often the best choice given its simplicity to implement (we
just added that single [`pollInterval` option](#polling)), sometimes we want
something more efficient and real-time.

In these cases we can use GraphQL
[subscriptions](https://dev-blog.apollodata.com/graphql-subscriptions-in-apollo-client-9a2457f015fb),
in which our server will send us updates to our data as they occur. The main
drawback to subscriptions is that it takes extra work to implement on the
server. (In the next chapter we’ll learn how to
[add subscription support](#server-subscriptions).) Another possible drawback is
that if the subscription data changes frequently, it can hurt client performance
by taking up time receiving, updating the store, and re-rendering the page.

While GraphQL servers can support different methods of transporting subscription
updates to clients (the GraphQL spec is transport-agnostic), the usual method is
over WebSockets. 

> *WebSocket* is a format for sending messages over the internet (like [HTTP](bg.md#http)). It allows for very fast two-way communication by keeping a connection open and allowing the server to initiate messages to the client.

We could replace our HTTP link with a WebSocket
link in `index.js` using the
[`apollo-link-ws` package](https://www.npmjs.com/package/apollo-link-ws):

```js
import { WebSocketLink } from 'apollo-link-ws'

const link = new WebSocketLink({
  uri: `ws://localhost:5000/`,
  options: {
    reconnect: true
  }
})
```

This would establish a WebSocket connection that remains open for the duration of the client session, and all GraphQL communication
(queries, mutations, and subscriptions) would be sent over the connection. However, authentication over the WebSocket is a little involved, so we’ll go with a hybrid transport solution: we’ll send queries and mutations over an HTTP link (which we’ll add auth to later), and we’ll send subscriptions over the unauthenticated WebSocket link. We can do this because all of the data used in the Guide’s real-time features (for example `StarCount`, and later on, reviews) is public. 

[`src/index.js`](https://github.com/GraphQLGuide/guide/compare/2_0.1.0...3_0.1.0)

```js
import { split } from 'apollo-link'
import { WebSocketLink } from 'apollo-link-ws'
import { getMainDefinition } from 'apollo-utilities'

const httpLink = createHttpLink({
  uri: 'https://api.graphql.guide/graphql'
})

const wsLink = new WebSocketLink({
  uri: `wss://api.graphql.guide/subscriptions`,
  options: {
    reconnect: true
  }
})

const link = split(
  ({ query }) => {
    const { kind, operation } = getMainDefinition(query)
    return kind === 'OperationDefinition' && operation === 'subscription'
  },
  wsLink,
  httpLink
)
```

The `ApolloClient` constructor options object takes a single link, so we need to compose our two links together. We can use the [`split()` function](http://apollo-link-docs.netlify.com/docs/link/composition.html#directional), which takes a function and two links. The function is given the current query, and if it returns true, the first link is used for the query; otherwise, the second is used. In our `split()` function we look up the query operation and return true if it’s a subscription query, which directs the query to the WebSocket link `wsLink`.

Now we can subscribe to updates to the star count with this simple subscription:

[`src/components/StarCounts.js`](https://github.com/GraphQLGuide/guide/compare/2_0.1.0...3_0.1.0)

```js
const STARS_SUBSCRIPTION = gql`
  subscription StarsSubscription {
    githubStars
  }
`
```

To start the subscription, we use a function
[`subscribeToMore`](https://www.apollographql.com/docs/react/features/subscriptions.html#subscribe-to-more)
that `react-apollo` provides us:

[`src/components/StarCounts.js`](https://github.com/GraphQLGuide/guide/compare/2_0.1.0...3_0.1.0)

```js
StarCount.propTypes = {
  githubStars: PropTypes.number,
  loading: PropTypes.bool.isRequired,
  subscribeToMore: PropTypes.func.isRequired
}

…

<Query query={STARS_QUERY} pollInterval={5 * 1000}>
  {({ data: { githubStars }, loading, subscribeToMore }) => (
    <StarCount
      githubStars={githubStars}
      loading={loading}
      subscribeToMore={subscribeToMore}
    />
  )}
</Query>
```

And then we can use it in our component. We want to start the subscription once
when the component is initialized (in `componentDidMount`), so we need to
convert `StarCounts` from a functional component to a class that can have
[lifecycle methods](https://reactjs.org/docs/react-component.html#the-component-lifecycle):

[`src/components/StarCounts.js`](https://github.com/GraphQLGuide/guide/compare/2_0.1.0...3_0.1.0)

```js
class StarCount extends React.Component {
  constructor(props) {
    super(props)
    this.state = {}
  }

  componentDidMount() {
    this.props.subscribeToMore({
      document: STARS_SUBSCRIPTION,
      updateQuery: (
        previousResult,
        { subscriptionData: { data: { githubStars } } }
      ) => ({ githubStars })
    })
  }

  render() {
    const { githubStars, loading } = this.props
    …
  }
}
```

`subscribeToMore` takes the GraphQL document specifying our subscription and an
`updateQuery` function. `updateQuery` is called each time the client receives
new subscription data from the server. It’s given the result of the previous
query (`STARS_QUERY` in our case) and the subscription data, and it returns an
updated query result, which is used to provide new props to the component. In
our case, we’re just replacing the old result with the GitHub star count received
in the `subscriptionData`. But if GitHub never lets us un-star repos, and the
star count only ever increased, then we might use a `justGotStarred`
subscription that published `{ newStar: true }` to the client. Then our
`updateQuery` would look like:

```js
this.props.subscribeToMore({
  document: JUST_GOT_STARRED_SUBSCRIPTION,
  updateQuery: (previousResult, update) {
    return {
      githubStars: previousResult.githubStars + 1
    }
  }
})
```

The last thing we need to do to test whether our `STARS_SUBSCRIPTION` is working
is to stop polling by removing the `pollInterval` prop from our `<Query>` in
`StarCount.js`:

```js
<Query query={STARS_QUERY} pollInterval={5 * 1000}>
```

Now we can star and unstar the
[Guide repo](https://github.com/GraphQLGuide/guide) and see the count quickly
change in our app. We might notice a slight delay sometimes, and that’s because
the server is polling the GitHub API once a second for updates, so the
subscription data reaching the client could be as old as 1 second plus network
time. We could improve this by reducing the polling interval on the server or by
setting up a [webhook](bg.md#webhook)—the most efficient and lowest latency solution,
in which the only delay would be network time: GitHub would immediately notify
our server of the change, and the server would immediately send the subscription
update over the WebSocket to the client.

The equivalent query using `graphql()` is:

```js
const withData = graphql(STARS_QUERY, {
  props: ({ data: { githubStars, loading, subscribeToMore } }) => ({
    githubStars,
    loading,
    subscribeToMore
  })
})
```

## Lists

> If you’re jumping in here, `git checkout 3_0.1.0` ([tag 3_0.1.0](https://github.com/GraphQLGuide/guide/tree/3_0.1.0), or compare [3...4](https://github.com/GraphQLGuide/guide/compare/3_0.1.0...4_0.1.0))

> See the [Listing reviews](#listing-reviews) section for another example of querying a list of data.

Next let’s get to the heart of our app—the stuff below the header! We’ll want to
reserve most of the space for the book content, since there’s a lot of it, and
reading it is the purpose of the app 😜. But let’s put a thin sidebar on the left
for the table of contents so that readers can easily navigate between sections.

To begin, we replace the `<p>` in `<App>` with the two new sections of the page:

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/compare/3_0.1.0...4_0.1.0)

```js
import TableOfContents from './TableOfContents'
import Section from './Section'

…

<div className="App">
  <header className="App-header">
    <StarCount />
    <img src={logo} className="App-logo" alt="logo" />
    <h1 className="App-title">The GraphQL Guide</h1>
  </header>
  <TableOfContents />
  <Section />
</div>
```

We call the second component `Section` because it will display a single section
of a chapter at a time. Let’s think about the loading state first—we’ll be
fetching the table of contents and the section content from the API. We could do
a loading spinner, but a nicer alternative when we’re waiting for text to load
is a loading skeleton—an animated gray bar placed where the text will appear.
Let’s put a few bars in both components:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/blob/4_0.1.0/src/components/Section.js)

```js
import React from 'react'
import Skeleton from 'react-loading-skeleton'

const Section = ({ loading = true }) => (
  <section className="Section">
    <div className="Section-header-wrapper">
      <header className="Section-header">
        <h1>Title</h1>
        <h2>Subtitle</h2>
      </header>
    </div>
    <div className="Section-content">
      {loading ? <Skeleton count={7} /> : null}
    </div>
  </section>
)

export default Section
```

`<Section>` isn’t being passed a `loading` prop yet, since we haven’t used the
`graphql()` function to attach a query to the component yet, but we can give
`loading` a default value of `true` for now so that we can work with it.
`count={7}` will give us 7 gray bars, representing 7 lines of text. Now for the
sidebar:

[`src/components/TableOfContents.js`](https://github.com/GraphQLGuide/guide/blob/4_0.1.0/src/components/TableOfContents.js)

```js
import React from 'react'
import Skeleton from 'react-loading-skeleton'

const TableOfContents = ({ loading = true }) => {
  return (
    <nav className="TableOfContents">
      {loading ? (
        <div>
          <h1>
            <Skeleton />
          </h1>
          <Skeleton count={4} />
        </div>
      ) : null}
    </nav>
  )
}

export default TableOfContents
```

`<Skeleton>` picks up the surrounding font size, so we’ll see a larger gray line
(in place of a chapter title) and then 4 smaller lines (in place of section
titles):

![Loading skeleton](/img/loading-skeleton.png)

Now let’s construct the query for the data we need to display in
`TableOfContents`. We can explore the Guide API’s schema in GraphQL Playground, an IDE for writing GraphQL queries. For instance, here we’re querying for `{ githubStars }`:

[Playground: `query { githubStars }`](https://graphqlbin.com/VO1qTg)

On the left side we have the GraphQL document, and when we click the play button (or `command-return`), we see the response on the right:

![Playground with githubStars query](/img/play-githubStars.png)

Now let’s delete `githubStars`, and with our cursor in between the `query` braces, we hit `control-space` to bring up query suggestions:

![Playground with query suggestions](/img/play-suggestions.png)

The one we want is `chapters`. Now we can add an inner set of braces (the
[selection set](https://dev-blog.apollodata.com/the-anatomy-of-a-graphql-query-6dffa9e9e747)
on `chapters`), move our cursor inside, and hit `control-space` again to see the
available fields of a `Chapter` (which is the type that `chapters` returns):

```gql
query {
  chapters {

  }
}
```

We’ll want to display the `title` and the `sections`, and we do the same to see
which fields of a `Section` we want.

```gql
query {
  chapters {
    title
    sections {

    }
  }
}
```

And we see `title`, which we will want for each section. 

![Playground Section field suggestions](/img/play-section-suggestions.png)

We will also want to display the chapter and section numbers, so let’s add those as well. Our whole query is:

```gql
query {
  chapters {
    number
    title
    sections {
      number
      title
    }
  }
}
```

We can see what the data looks like by hitting the play button or
`command-return`. 

![Playground chapters query response](/img/play-chapters.png)

To attach the query to our component, we give it a name,
`ChapterQuery`, put it inside a `gql` template string, and use `graphql()` to
specify what props our HOC will give to `TableOfContents`:

[`src/components/TableOfContents.js`](https://github.com/GraphQLGuide/guide/blob/4_0.1.0/src/components/TableOfContents.js)

```js
import { graphql } from 'react-apollo'
import gql from 'graphql-tag'

const CHAPTER_QUERY = gql`
  query ChapterQuery {
    chapters {
      id
      number
      title
      sections {
        id
        number
        title
      }
    }
  }
`

const withData = graphql(CHAPTER_QUERY, {
  props: ({ data: { chapters, loading } }) => ({
    chapters,
    loading
  })
})

export default withData(TableOfContents)
```

And now that our component will be getting props, we add prop types:

[`src/components/TableOfContents.js`](https://github.com/GraphQLGuide/guide/blob/4_0.1.0/src/components/TableOfContents.js)

```js
import PropTypes from 'prop-types'

TableOfContents.propTypes = {
  chapters: PropTypes.arrayOf(
    PropTypes.shape({
      id: PropTypes.number.isRequired,
      number: PropTypes.number,
      title: PropTypes.string.isRequired,
      sections: PropTypes.arrayOf(
        PropTypes.shape({
          id: PropTypes.number.isRequired,
          number: PropTypes.number.isRequired,
          title: PropTypes.string
        }).isRequired
      ).isRequired
    }).isRequired
  ),
  loading: PropTypes.bool.isRequired
}
```

We know that we can add `.isRequired` to the fields of `chapters` and `sections`
because we can see in the Guide schema that they’re non-null—in Playground, we
click "SCHEMA" on the right to open up the schema tab, click on `chapters`, and
see that, for example `title: String!` has an exclamation mark, so it will
always have a value. 

![Schema: chapters](/img/schema-chapters.png)

This means that when our component is provided `chapters`,
the `title` field will always be present.

[Playground: `query { chapters { number title sections { number
title } } }`](https://graphqlbin.com/lOR8i2)

> Note that `chapters: PropTypes.arrayOf(…)` doesn’t have an `.isRequired`,
> because initially, while `loading` is `true`, `chapters` is `undefined`.

Next let’s use the new props our component gets. We can remove the default
`true` value for `loading` and add `chapters`. For each chapter we display a
list of links to each section:

[`src/components/TableOfContents.js`](https://github.com/GraphQLGuide/guide/blob/4_0.1.0/src/components/TableOfContents.js)

```js
import { NavLink } from 'react-router-dom'
import classNames from 'classnames'

import { slugify, withHyphens } from '../lib/helpers'

const LoadingSkeleton = () => (
  <div>
    <h1>
      <Skeleton />
    </h1>
    <Skeleton count={4} />
  </div>
)

const TableOfContents = ({ chapters, loading }) => (
  <nav className="TableOfContents">
    {loading ? (
      <LoadingSkeleton />
    ) : (
      <ul className="TableOfContents-chapters">
        {chapters.map(chapter => {
          const chapterIsNumbered = chapter.number !== null
          return (
            <li
              className={classNames({ numbered: chapterIsNumbered })}
              key={chapter.id}
            >
              <NavLink
                to={{
                  pathname: slugify(chapter),
                  state: { chapter, section: chapter.sections[0] }
                }}
                className="TableOfContents-chapter-link"
                activeClassName="active"
                isActive={(match, location) => {
                  const rootPath = location.pathname.split('/')[1]
                  return rootPath.includes(withHyphens(chapter.title))
                }}
              >
                {chapterIsNumbered && (
                  <span className="TableOfContents-chapter-number">
                    {chapter.number}
                  </span>
                )}
                {chapter.title}
              </NavLink>
              {chapterIsNumbered && (
                <ul className="TableOfContents-sections">
                  {chapter.sections.map(section => (
                    <li key={section.number}>
                      <NavLink
                        to={{
                          pathname: slugify(chapter, section),
                          state: { chapter, section }
                        }}
                        className="TableOfContents-section-link"
                        activeClassName="active"
                      >
                        {section.title}
                      </NavLink>
                    </li>
                  ))}
                </ul>
              )}
            </li>
          )
        })}
      </ul>
    )}
  </nav>
)
```

Okay, so that was a lot of code 😁. We’ve got an outer list of chapters, and for each chapter we have an inner list of sections. We’ve got React Router `<NavLink>`s that add an `"active"` class when the URL matches the link path. And we use the `slugify()` helper to generate paths.

[`src/lib/helpers.js`](https://github.com/GraphQLGuide/guide/blob/4_0.1.0/src/lib/helpers.js)

```js
export const withHyphens = string => string.replace(/ /g, '-')

// generate paths of the form:
// `/Forward`
// `/Preface`
// `/1-Understanding-GraphQL-through-REST/1-Introduction`
export const slugify = (chapter, section) => {
  if (!section) {
    if (chapter.sections.length) {
      // default to the first section
      section = chapter.sections[0]
    } else {
      return '/' + withHyphens(chapter.title)
    }
  }

  const chapterSlug = chapter.number + '-' + withHyphens(chapter.title)
  const sectionSlug = section.number + '-' + withHyphens(section.title)
  return `/${chapterSlug}/${sectionSlug}`
}
```

Also, to get React Router working, we need to wrap our app in `<BrowserRouter>`:

[`src/index.js`](https://github.com/GraphQLGuide/guide/compare/3_0.1.0...4_0.1.0)

```js
import { BrowserRouter } from 'react-router-dom'

ReactDOM.render(
  <BrowserRouter>
    <ApolloProvider client={client}>
      <App />
    </ApolloProvider>
  </BrowserRouter>,
  document.getElementById('root')
)
```

With all this JSX code, we’re starting to feel the best thing about GraphQL on the client side—that most of the coding is in the view instead of in data fetching. We don’t have a bunch of REST endpoint fetching and parsing and caching and passing code; instead, we attach simple query strings to the components that need them, and we get the data in the props.

Now we should see the table of contents on the left side of the page, and we can click between sections and see the active links and path changing:

![Table of contents](/img/table-of-contents.png)

## Query variables

> If you’re jumping in here, `git checkout 4_0.1.0` ([tag 4_0.1.0](https://github.com/GraphQLGuide/guide/tree/4_0.1.0), or compare [4...5](https://github.com/GraphQLGuide/guide/compare/4_0.1.0...5_0.1.0))

Let’s fill in the book content next! Say we have a section id, like `'intro'`—how do we get the content? Let’s look in Playground to find the right query to make:

[Playground: `query { }`](https://www.graphqlbin.com/qj7PuX)

There’s a `section(id: String!)` query that returns a `Section` object, which has a `content` field. So let’s try it out:

[Playground: `query { section(id: "intro") { content }}`](https://graphqlbin.com/pg8rsQ)

Next we add the query to our component:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/compare/4_0.1.0...5_0.1.0)

```js
import PropTypes from 'prop-types'
import { graphql } from 'react-apollo'
import gql from 'graphql-tag'

Section.propTypes = {
  section: PropTypes.shape({
    content: PropTypes.string.isRequired
  }),
  loading: PropTypes.bool.isRequired
}

const SECTION_QUERY = gql`
  query SectionContent {
    section(id: "intro") {
      content
    }
  }
`

const withData = graphql(SECTION_QUERY, {
  props: ({ data: { section } }) => ({ section })
})

export default withData(Section)
```

Now our component should get a `section` prop that will have the same `content` string that we saw returned in Playground, and we can use it.

[src/components/Section.js`](https://github.com/GraphQLGuide/guide/compare/4_0.1.0...5_0.1.0)

```js
const Section = ({ loading, section }) => (
  <section className="Section">
    <div className="Section-header-wrapper">
      <header className="Section-header">
        <h1>Title</h1>
        <h2>Subtitle</h2>
      </header>
    </div>
    <div className="Section-content">
      {loading ? <Skeleton count={7} /> : section.content}
    </div>
  </section>
)
```

We can read the book! 📖 But we’ve got a hard-coded section id—let’s turn our `section(id)` argument into a variable:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/compare/4_0.1.0...5_0.1.0)

```js
const SECTION_QUERY = gql`
  query SectionContent($id: String!) {
    section(id: $id) {
      content
    }
  }
`

const withData = graphql(SECTION_QUERY, {
  options: { variables: { id: '1-1' } },
  props: ({ data: { section } }) => ({ section })
})
```

- `query SectionContent($id: String!) {`: We declare at the top that the `SectionContent` query takes a variable `$id`, a required `String`.
- `section(id: $id) {`: We replace our string literal `"1-1"` with the variable `$id`.
- `options: { variables: { id: '1-1' } }`: We tell `graphql()` to pass an `id` variable to the query.

Now passing the variable to the query is working, but we still have `'1-1'` hard-coded. Where do we get the section id from? Back in `TableOfContents`, we gave a `to` prop to our `NavLinks`:

```js
<NavLink
  to={{
    pathname: slugify(chapter, section),
    state: { chapter, section }
  }}
```

The `pathname` is the equivalent of an anchor tag’s `href` attribute, but `state` is part of the HTML5 [session history management](https://developer.mozilla.org/en-US/docs/Web/API/History_API#The_pushState()_method). We can access it at `window.location.state`, but we also want our components to react to changes, so we want it as a prop. The best way to use browser history state with `react-router` is with the `withRouter` HOC, which provides our component with a `location` prop, which has a `.state` property. `graphql()`’s `options` can have a function value instead of our current `variables` object literal—the function takes the props and returns the variables:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/compare/4_0.1.0...5_0.1.0)

```js
import { withRouter } from 'react-router'

const withData = graphql(SECTION_QUERY, {
  options: ({ location: { state: { section: { id } } } }) => ({
    variables: { id }
  }),
  props: ({ data: { section, loading } }) => ({
    sectionContent: section && section.content,
    loading
  })
})

export default withRouter(withData(Section))
```

> If you get `TypeError: Cannot read property 'section' of undefined`, skip ahead to the next section to see the solution.

Our options function gets the section id from the `location` prop and returns it as the query variable. In our `props` function, we change from passing `section` to just passing a `sectionContent` string (so that the name doesn’t conflict with also getting the `section` from `location.state`). Also, our HOC order matters—we have to put `withRouter()` outside of `withData()` so that `graphql()` gets the `location` prop to give to the options function.  

Let’s fill in our component with our newly available data:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/compare/4_0.1.0...5_0.1.0)

```js
const Section = ({
  loading,
  sectionContent,
  location: { state: { chapter, section } }
}) => (
  <section className="Section">
    <div className="Section-header-wrapper">
      <header className="Section-header">
        {chapter.number !== null ? (
          <div>
            <h1>{section.title}</h1>
            <h2>
              {'Chapter ' + chapter.number}
              <span className="Section-number-divider" />
              {'Section ' + section.number}
            </h2>
          </div>
        ) : (
          <h1>{chapter.title}</h1>
        )}
      </header>
    </div>
    <div className="Section-content">
      {loading ? <Skeleton count={7} /> : sectionContent}
    </div>
  </section>
)

Section.PropTypes = {
  sectionContent: PropTypes.string,
  location: PropTypes.object.isRequired,
  loading: PropTypes.bool.isRequired
}
```

We can see this working by clicking a different section in the table of contents. The path will change and a new `state` will be set, which `withRouter` will provide to `Section`, triggering a re-render, and the book content on the right will update. 

![Section content](/img/section-content.png)

## Skipping queries

> If you’re jumping in here, `git checkout 5_0.1.0` ([tag 5_0.1.0](https://github.com/GraphQLGuide/guide/tree/5_0.1.0), or compare [5...6](https://github.com/GraphQLGuide/guide/compare/5_0.1.0...6_0.1.0))

If you’ve kept your development browser tab open during this section, then everything has worked smoothly for you. But when we open a [new tab](http://localhost:3000/introduction), we find a bug:

`TypeError: Cannot read property 'section' of undefined`
```js
const withData = graphql(SECTION_QUERY, {
  options: ({ location: { state: { section: { id } } } }) => ({
```

It looks like `location.state` is undefined! 🐞 Which makes sense, because in a new tab, we haven’t yet clicked a `<NavLink>`, so the state hasn’t been set. If we don’t have the state, how do we get the section id so that we can query for the right content? The only information we have on first page load is the path, so we have to parse it. [`location.pathname`](https://reacttraining.com/react-router/web/api/location) will always be defined, so we can `deslugify()` it:

[`src/lib/helpers.js`](https://github.com/GraphQLGuide/guide/compare/5_0.1.0...6_0.1.0)

```js
// parse a path:
// /Introduction
// -> { chapterTitle: 'Introduction' }
//
// /1-Understanding-GraphQL-through-REST/1-Introduction
// -> { chapterNumber: 1, sectionNumber: 1 }
export const deslugify = path => {
  const [, chapterSlug, sectionSlug] = path.split('/')
  const chapterIsNumbered = !!sectionSlug

  return chapterIsNumbered
    ? {
        chapterNumber: parseInt(chapterSlug.split('-')[0], 10),
        sectionNumber: parseInt(sectionSlug.split('-')[0], 10)
      }
    : { chapterTitle: chapterSlug }
}
```

Now let’s look at Playground to figure out which two queries we can use, given either the chapter title or the chapter and section numbers:

[Playground: `query { }`](https://www.graphqlbin.com/qj7PuX)

We can use the `chapterByTitle` and `chapterByNumber` root query fields along with a `Chapter`’s `section` field with a `number: Int!` argument. (Any field, not just root fields, can have arguments.)

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/compare/5_0.1.0...6_0.1.0)

```js
const SECTION_BY_ID_QUERY = gql`
  query SectionContent($id: String!) {
    section(id: $id) {
      content
    }
  }
`

const SECTION_BY_CHAPTER_TITLE_QUERY = gql`
  query SectionByChapterTitle($title: String!) {
    chapterByTitle(title: $title) {
      title
      section(number: 1) {
        content
      }
    }
  }
`

const SECTION_BY_NUMBER_QUERY = gql`
  query SectionByChapterTitle($chapterNumber: Int!, $sectionNumber: Int!) {
    chapterByNumber(number: $chapterNumber) {
      number
      section(number: $sectionNumber) {
        number
        title
        content
      }
    }
  }
`
```

For `chapterByTitle`, all the non-numbered chapters only have single section, numbered `0` and title-less. For the `chapterByNumber`, we need the section title in addition to the contents, because we display it at the top of the component, and we no longer get it from `location.state`. 

### Section HOCs

Now we need to figure out which query to use! We could make our own HOC that took in `location` from `withRouter` and chose which query to use, like this:

```js
export default withRouter(withCorrectQuery(Section))
```

But let’s instead try out the [`skip`](https://www.apollographql.com/docs/react/basics/queries.html#graphql-skip) feature of `graphql()`. It allows you to provide a function that calculates from the props whether to perform the query. For instance, we don’t want to use the `SECTION_BY_ID_QUERY` when there’s no state:

```js
const withSectionById = graphql(SECTION_BY_ID_QUERY, {
  skip: ({ location }) => !location.state,
```

Let’s also standardize the props so that `Section` always gets a `section` and a `chapter`, with `section.content`:

`src/components/Section.js`

```js
const SECTION_BY_ID_QUERY = gql`
  query SectionContent($id: String!) {
    section(id: $id) {
      content
    }
  }
`

const withSectionById = graphql(SECTION_BY_ID_QUERY, {
  skip: ({ location }) => !location.state,
  options: ({ location: { state } }) => ({
    variables: { id: state && state.section.id }
  }),
  props: ({
    ownProps: { location: { state } },
    data: { section, loading }
  }) => ({
    section: {
      ...state.section,
      content: section && section.content
    },
    chapter: state.chapter,
    loading
  })
})
```

In our `props` function, we have access to `withRouter()`’s props under the `ownProps` argument. We add the section content we get from the query result to `ownProps.locations.state.section`. We need to guard against `data.section` being `undefined` (`section && section.content`) because it will be when `loading` is true.

Let’s make an HOC for the next query:

`src/components/Section.js`

```js
import { deslugify } from '../lib/helpers'

const SECTION_BY_CHAPTER_TITLE_QUERY = gql`
  query SectionByChapterTitle($title: String!) {
    chapterByTitle(title: $title) {
      title
      section(number: 1) {
        content
      }
    }
  }
`

const withSectionByChapterTitle = graphql(SECTION_BY_CHAPTER_TITLE_QUERY, {
  skip: ({ location }) =>
    location.state || !deslugify(location.pathname).chapterTitle,
  options: ({ location: { pathname } }) => ({
    variables: { title: deslugify(pathname).chapterTitle }
  }),
  props: ({ data: { chapterByTitle, loading } }) => ({
    section: chapterByTitle && chapterByTitle.section,
    chapter: {
      ...chapterByTitle,
      number: null
    },
    loading
  })
})
```

We want to skip over this query if we either have state (in which case we used `SECTION_BY_ID_QUERY`) or if the path doesn’t have a `chapterTitle` (in which case we’ll pass on to the next HOC/query). We get the `title` query variable from the path, and for props, `section` comes from the query results. We didn’t need the `number` field in our query because we know that these chapters aren’t numbered.

On to the next query 🏃‍♀️:

`src/components/Section.js`

```js
const SECTION_BY_NUMBER_QUERY = gql`
  query SectionByNumber($chapterNumber: Int!, $sectionNumber: Int!) {
    chapterByNumber(number: $chapterNumber) {
      number
      section(number: $sectionNumber) {
        number
        title
        content
      }
    }
  }
`

const withSectionByNumber = graphql(SECTION_BY_NUMBER_QUERY, {
  skip: ({ location }) =>
    location.state || !deslugify(location.pathname).chapterNumber,
  options: ({ location: { pathname } }) => ({ variables: deslugify(pathname) }),
  props: ({ data: { chapterByNumber, loading } }) => ({
    section: chapterByNumber && chapterByNumber.section,
    chapter: chapterByNumber,
    loading
  })
})
```

- `options`: What we get from deslugify in this case matches our query variable format (`{ chapterNumber: 1, sectionNumber: 1}`).
- `props`: We get all the props we need from the query results.

We can combine all of our HOCs with:

```js
export default withRouter(
  withSectionById(withSectionByChapterTitle(withSectionByNumber(Section)))
)
```

😵 but that’s hard to read! We can do the same with `react-apollo`’s `compose()` (equivalent to `compose()` from recompose or redux):

```js
import { graphql, compose } from 'react-apollo'

export default compose(
  withRouter,
  withSectionById,
  withSectionByChapterTitle,
  withSectionByNumber
)(Section)
```

All four HOCs get composed together to a single HOC, which is applied to `Section`. Here’s the more verbose version:

```js
const withRouterAndData = compose(
  withRouter,
  withSectionById,
  withSectionByChapterTitle,
  withSectionByNumber
)

export default withRouterAndData(Section)
```

And we set our `PropTypes`:

```js
Section.propTypes = {
  section: PropTypes.shape({
    title: PropTypes.string,
    number: PropTypes.number,
    content: PropTypes.string
  }),
  chapter: PropTypes.shape({
    title: PropTypes.string,
    number: PropTypes.number
  }).isRequired,
  loading: PropTypes.bool.isRequired
}
```

Now when we open [/introduction](http://localhost:3000/introduction) or [/1-Understanding-GraphQL-through-REST/1-Introduction](http://localhost:3000/1-Understanding-GraphQL-through-REST/1-Introduction) in new tabs, we get the right section content instead of an error! 🐞👊 In [Apollo devtools](5.md#devtools), we can look at the active queries on the page, which will let us see which of our three `graphql()` HOCs is being used:

![SectionContent](/img/SectionContent.png)

![SectionByNumber](/img/SectionByNumber.png)

The first image is from a tab in which we’ve been navigating with the table of contents, and it uses the `SectionContent` query. The second image is from a newly opened tab, and it uses `SectionByNumber`.

### Section Query

As we learned in `StarCount.js`, a benefit to the `<Query>` component is being able to dynamically decide on a query to use. That’s a perfect fit for `Section.js`, where we’re deciding on one of three queries to use. Here’s our three HOCs replaced with a `<Query>`:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/compare/5_0.1.0...6_0.1.0)

```js
import { Query } from 'react-apollo'


const SectionWithData = ({ location: { state, pathname } }) => {
  const page = deslugify(pathname)

  let query, variables

  if (state) {
    query = SECTION_BY_ID_QUERY
    variables = { id: state.section.id }
  } else if (page.chapterTitle) {
    query = SECTION_BY_CHAPTER_TITLE_QUERY
    variables = { title: page.chapterTitle }
  } else if (page.chapterNumber) {
    query = SECTION_BY_NUMBER_QUERY
    variables = page
  }

  return (
    <Query query={query} variables={variables}>
      {({ data, loading }) => {
        let props

        if (data.section) {
          props = {
            section: {
              ...state.section,
              content: data.section.content
            },
            chapter: state.chapter,
            loading
          }
        } else if (data.chapterByTitle) {
          props = {
            section: data.chapterByTitle.section,
            chapter: {
              ...data.chapterByTitle,
              number: null
            },
            loading
          }
        } else if (data.chapterByNumber) {
          props = {
            section: data.chapterByNumber.section,
            chapter: data.chapterByNumber,
            loading
          }
        } else {
          props = { loading }
        }

        return <Section {...props} />
      }}
    </Query>
  )
}

export default withRouter(SectionWithData)
```

First we decide, based on the `location` prop, which `query` and `variables` to use. Then inside the render prop, `data` will have either a `section`, `chapterByTitle`, or `chapterByNumber` attribute, depending on which query was used. Based on which data is returned, we can construct the right props for `<Section>`. Let’s compare to the HOC solution:

```js
const withSectionById = graphql(SECTION_BY_ID_QUERY, {
  skip: ({ location }) => !location.state,
  options: ({ location: { state } }) => ({
    variables: { id: state && state.section.id }
  }),
  props: ({
    ownProps: { location: { state } },
    data: { section, loading }
  }) => ({
    section: {
      ...state.section,
      content: section && section.content
    },
    chapter: state.chapter,
    loading
  })
})

const withSectionByChapterTitle = graphql(SECTION_BY_CHAPTER_TITLE_QUERY, {
  skip: ({ location }) =>
    location.state || !deslugify(location.pathname).chapterTitle,
  options: ({ location: { pathname } }) => ({
    variables: { title: deslugify(pathname).chapterTitle }
  }),
  props: ({ data: { chapterByTitle, loading } }) => ({
    section: chapterByTitle && chapterByTitle.section,
    chapter: {
      ...chapterByTitle,
      number: null
    },
    loading
  })
})

const withSectionByNumber = graphql(SECTION_BY_NUMBER_QUERY, {
  skip: ({ location }) =>
    location.state || !deslugify(location.pathname).chapterNumber,
  options: ({ location: { pathname } }) => ({ variables: deslugify(pathname) }),
  props: ({ data: { chapterByNumber, loading } }) => ({
    section: chapterByNumber && chapterByNumber.section,
    chapter: chapterByNumber,
    loading
  })
})

export default compose(
  withRouter,
  withSectionById,
  withSectionByChapterTitle,
  withSectionByNumber
)(Section)
```

Instead of an if-else statement, the HOC solution uses `skip`. It also has to call `deslugify` and deconstruct arguments more often. A downside of our `<Query>` implementation is that the query and variables are separated from the prop creation, but we can fix that by using a function:

```js
import get from 'lodash/get'

const SectionWithData = ({ location: { state, pathname } }) => {
  const page = deslugify(pathname)

  let query, variables, createProps

  if (state) {
    query = SECTION_BY_ID_QUERY
    variables = { id: state.section.id }
    createProps = ({ data, loading }) => ({
      section: {
        ...state.section,
        content: get(data, 'section.content')
      },
      chapter: state.chapter,
      loading
    })
  } else if (page.chapterTitle) {
    query = SECTION_BY_CHAPTER_TITLE_QUERY
    variables = { title: page.chapterTitle }
    createProps = ({ data, loading }) => ({
      section: get(data, 'chapterByTitle.section'),
      chapter: {
        ...data.chapterByTitle,
        number: null
      },
      loading
    })
  } else if (page.chapterNumber) {
    query = SECTION_BY_NUMBER_QUERY
    variables = page
    createProps = ({ data, loading }) => ({
      section: get(data, 'chapterByNumber.section'),
      chapter: data.chapterByNumber,
      loading
    })
  }

  return (
    <Query query={query} variables={variables}>
      {queryInfo => <Section {...createProps(queryInfo)} />}
    </Query>
  )
}

export default withRouter(SectionWithData)
```

Since, for example, `data.section` might be undefined, we have to either go back to guarding (`data.section && data.section.content`) or use `lodash/get`.

Let’s go with the `<Query>` version, since the logic of which query should be used is more clear, and being able to easily understand what’s happening (from the point of view of a teammate reading for the first time, or—let’s be honest—ourselves looking back at it a month later 😆) is one of the most important factors of code quality.

### More routing

Before we move on to the authentication section, we’ve got another bug! You may very well have already noticed this one—we can’t visit the root URL [localhost:3000/](http://localhost:3000/) 😜. `TypeError: Cannot read property 'number' of undefined` is coming from our `chapter.number !== null` check in `Section`, and `chapter` is undefined because *none* of our HOCs was able to fetch the chapter. That’s because on the root, there’s neither history state nor a path to `deslugify()`. While it would be nice to 
redirect from the root to whichever section the user was last reading, for now let’s just redirect to the first chapter. 

So far, we haven’t defined any routes—`Section` just changes what data it shows based on the path. We can create a root route that redirects to `/Preface`.

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/compare/5_0.1.0...6_0.1.0)

```js
import { Switch, Route, Redirect } from 'react-router'

const Book = () => (
  <div>
    <TableOfContents />
    <Section />
  </div>
)

class App extends Component {
  render() {
    return (
      <div className="App">
        <header className="App-header">
          <StarCount />
          <img src={logo} className="App-logo" alt="logo" />
          <h1 className="App-title">The GraphQL Guide</h1>
        </header>
        <Switch>
          <Route exact path="/" render={() => <Redirect to="/Preface" />} />
          <Route component={Book} />
        </Switch>
      </div>
    )
  }
}
```

Assuming we always want to keep our header on the page regardless of which route we’re on, we put the `<Route>`s below the header in lieu of `<TableOfContents />` and `<Section />`, which we move to a new `Book` component. `<Switch>` renders the first `<Route>` that matches. The first route matches only `/` and redirects, and the second route matches everything else and displays `Book`. 

This begs the question, "What happens when the second route matches `/aMistypedChapterTitle`"? We get another error! This time it’s `TypeError: Cannot read property 'content' of null` from `Section` trying to display `section.content`, because we failed at fetching `section`. Let’s have `Section` display a 404 message, and let’s refactor, since the double ternary operator is already hard to read.

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/compare/5_0.1.0...6_0.1.0)

```js
const Section = ({ loading, section, chapter }) => {
  let headerContent = null,
    sectionContent = null

  if (loading) {
    headerContent = (
      <h1>
        <Skeleton />
      </h1>
    )
    sectionContent = <Skeleton count={7} />
  } else if (!section) {
    headerContent = <h1>🔍 404 page not found</h1>
  } else {
    if (chapter.number !== null) {
      headerContent = (
        <div>
          <h1>{section.title}</h1>
          <h2>
            {'Chapter ' + chapter.number}
            <span className="Section-number-divider" />
            {'Section ' + section.number}
          </h2>
        </div>
      )
    } else {
      headerContent = <h1>{chapter.title}</h1>
    }

    sectionContent = section.content
  }

  return (
    <section className="Section">
      <div className="Section-header-wrapper">
        <header className="Section-header">{headerContent}</header>
      </div>
      <div className="Section-content">{sectionContent}</div>
    </section>
  )
}
```

First we check if we’re loading (in which case we don’t know whether we’ve failed to find `section` yet), then we check if we didn’t find section. If neither of those cases applied, then we would render the title and content.

Now we should be able to both:
- go to the root [localhost:3000/](http://localhost:3000/) and get redirected
- go to [/notachapter](http://localhost:3000/notachapter) and see the 404 message:

![404 page not found](/img/404.png)

# Authentication

Section contents:

* [Logging in](6.md#logging-in)
* [Resetting](6.md#resetting)

## Logging in

Background: [Authentication](bg.md#authentication)

> If you’re jumping in here, `git checkout 6_0.1.0` ([tag 6_0.1.0](https://github.com/GraphQLGuide/guide/tree/6_0.1.0), or compare [6...7](https://github.com/GraphQLGuide/guide/compare/6_0.1.0...7_0.1.0))

You’ll have noticed by now that you’re not getting the entire section content from the Guide API, and that’s because you’re not logged in. When you bought the book, you created a user account that was associated with your purchase. In order to see the full content, you need to login with that account.

Authentication is important and complex enough that we rarely want to code it ourselves—we probably should use a library or service. For node backends, the most common library is [passport](http://www.passportjs.org/). We’ll instead use a service—[Auth0](https://auth0.com/)—for ease of integration. There are pros and cons to [signed tokens vs. sessions](bg.md#tokens-vs-sessions) and [localStorage vs. cookies](bg.md#localstorage-vs-cookies), but we’ll go with the most straightforward option for Auth0 integration: tokens stored in localStorage. They have a number of authentication methods (called "Connections" in Auth0 or "strategies" in Passport), including email/password, [passwordless](https://auth0.com/passwordless) (SMS one-time codes, email magic login links, and/or TouchID), and Social OAuth providers. While Auth0 makes it easy to provide multiple options, for simplicity’s sake, we’ll just provide GitHub OAuth—all of our users are developers, and they’re likely already logged into their GitHub account on most of their browsers, so the login process should be really easy. If we were building for a different market, we might prefer passwordless instead.

A common login sequence is this: the user clicks a login button, which redirects them to the GitHub OAuth page, and after they do GitHub login (if needed), they authorize our app and are redirected back to our site. One UX drawback of this sequence is that at the end, the user has to wait for our site to load, and without some work, they won’t be taken to the exact page and scroll position they were at before. A good alternative is to open a popup (or a new tab on mobile) where the user can do the GitHub steps. When they’re done authorizing, the popup closes and returns the signed token to the app. Then we’ll include that token in our requests to the server so the server will know who the user is.

Let’s think about what UI elements we want related to the login and the user. We can put a login link on the right side of the header, which will open the GitHub popup. Once the user is logged in, we can show their GitHub profile photo and name in place of the login link, and if they click their name, we can take them to a new `/me` route that shows them their profile. For all of this, we’ll need some data and functions—the user data, whether the user data is loading, and login and logout functions. We need it in a couple of different places in the app—in the header and in a route. There are a few different ways to get information to any place in the app—one is to render an `AppContainer` instead of `App` in `index.js`:

```js
ReactDOM.render(
  <BrowserRouter>
    <ApolloProvider client={client}>
      <AppContainer />
    </ApolloProvider>
  </BrowserRouter>,
  document.getElementById('root')
)
```

And then the `AppContainer`’s render function gives `App` any props it needs:

```js
render() {
  return (
    <App
      user={user}
      login={this.login}
      logout={this.logout}
      …
    />
  )
}
```

Another option is creating an HOC that adds the right props. Similar to how we’ve been using `withData()` to add data props to components, we can wrap `App` in a new HOC:

```js
import withAuth from '../lib/withAuth'

…

export default withAuth(App)
```

And `withAuth()` provides props like `login` and `logout`. `withAuth()` will only be used once, and usually we make HOCs when we’ll be using them more than once, but it’s semantically nice and a good opportunity to see what writing our own data HOC looks like, so we’ll go with this method. Let’s imagine how we want our new `<App>` to look—what props it gets and where it passes them:

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/compare/6_0.1.0...7_0.1.0)

```js
import PropTypes from 'prop-types'

import CurrentUser from './CurrentUser'
import Profile from './Profile'
import withAuth from '../lib/withAuth'

class App extends Component {
  render() {
    const { logout, ...authProps } = this.props

    return (
      <div className="App">
        <header className="App-header">
          <StarCount />
          <Link className="App-home-link" to="/">
            <img src={logo} className="App-logo" alt="logo" />
            <h1 className="App-title">The GraphQL Guide</h1>
          </Link>
          <CurrentUser {...authProps} />
        </header>
        <Switch>
          <Route exact path="/" render={() => <Redirect to="/Preface" />} />
          <Route
            exact
            path="/me"
            render={() => <Profile logout={logout} {...authProps} />}
          />
          <Route component={Book} />
        </Switch>
      </div>
    )
  }
}

App.propTypes = {
  user: PropTypes.object,
  login: PropTypes.func.isRequired,
  logout: PropTypes.func.isRequired,
  loading: PropTypes.bool.isRequired
}

export default withAuth(App)
```

Let’s say that `withAuth()` will give us the following props: the `user` object, the `login()` and `logout()` functions, and a `loading` status boolean. 

> We can be vague here with `user: PropTypes.object` since we’re not using `user` in this component—in the components that do use it, we’ll list out the fields used in a `PropTypes.shape`. 

We call the header component `<CurrentUser>` because usually it’s just displaying the name and photo, but let’s also give it `loading` so it can show a spinner when loading. For `<Profile>`, we need to add a new route, and we’ll give it all of the props. Since we now have a second route, we need a way for the user to navigate to the rest of the app, so we can wrap the header image and title in a `<Link>` to the root `/`. Next let’s write `<CurrentUser>`:

[`src/components/CurrentUser.js`](https://github.com/GraphQLGuide/guide/blob/7_0.1.0/src/components/CurrentUser.js)

```js
import React from 'react'
import PropTypes from 'prop-types'
import { Link } from 'react-router-dom'

const CurrentUser = ({ user, login, loading }) => {
  const User = () => (
    <Link to="/me" className="User">
      <img src={user.photo} alt={user.firstName} />
      {user.firstName}
    </Link>
  )

  let child

  if (user) {
    child = <User />
  } else if (loading) {
    child = <div className="Spinner" />
  } else {
    child = <button onClick={login}>Sign in</button>
  }

  return <div className="CurrentUser">{child}</div>
}

CurrentUser.propTypes = {
  user: PropTypes.shape({
    firstName: PropTypes.string.isRequired,
    photo: PropTypes.string.isRequired
  }),
  login: PropTypes.func.isRequired,
  loading: PropTypes.bool.isRequired
}

export default CurrentUser
```

This one is straightforward to read. If there’s no user and the user isn’t being loaded, then we have a "Sign in" button that calls `login()` (passed down from `App`, which got it from `withAuth()`).

Similarly, in `<Profile>`, we might show a loading spinner or a login button. Otherwise, we show the user’s details:

[`src/components/Profile.js`](https://github.com/GraphQLGuide/guide/blob/7_0.1.0/src/components/Profile.js)

```js
import React from 'react'
import PropTypes from 'prop-types'

const Profile = ({ user, login, logout, loading }) => {
  if (loading) {
    return (
      <main className="Profile">
        <div className="Spinner" />
      </main>
    )
  } else if (!user) {
    return (
      <main className="Profile">
        <button onClick={login} className="Profile-login">
          Sign in
        </button>
      </main>
    )
  } else {
    return (
      <main className="Profile">
        <div className="Profile-header-wrapper">
          <header className="Profile-header">
            <h1>{user.name}</h1>
          </header>
        </div>
        <div className="Profile-content">
          <dl>
            <dt>Email</dt>
            <dd>
              <code>{user.email}</code>
            </dd>

            <dt>Membership level</dt>
            <dd>
              <code>{user.hasPurchased || 'GUEST'}</code>
            </dd>

            <dt>OAuth Github account</dt>
            <dd>
              <a
                href="https://github.com/settings/applications"
                target="_blank"
                rel="noopener noreferrer"
              >
                <code>{user.username}</code>
              </a>
            </dd>
          </dl>

          <button className="Profile-logout" onClick={logout}>
            Sign out
          </button>
        </div>
      </main>
    )
  }
}

Profile.propTypes = {
  user: PropTypes.shape({
    name: PropTypes.string.isRequired,
    email: PropTypes.string.isRequired,
    hasPurchased: PropTypes.string
  }),
  login: PropTypes.func.isRequired,
  logout: PropTypes.func.isRequired,
  loading: PropTypes.bool.isRequired
}

export default Profile
```

And now to write the `withAuth()` HOC! Here’s the structure we’ll be working in:

[`src/lib/withAuth.js`](https://github.com/GraphQLGuide/guide/blob/7_0.1.0/src/lib/withAuth.js)

```js
import React from 'react'
import wrapDisplayName from 'recompose/wrapDisplayName'

…

function withAuth(BaseComponent) {
  class WithAuthWrapper extends React.Component {
    …

    render() {
      return (
        <BaseComponent
          user={…}
          loading={…}
          login={this.login}
          logout={this.logout}
        />
      )
    }
  }

  WithAuthWrapper.displayName = wrapDisplayName(BaseComponent, 'withAuth')
  return WithAuthWrapper
}

export default withAuth
```

An HOC is a function that returns a component. Ours is taking in a `BaseComponent` (in our case, `App`) and creating a new component `WithAuthWrapper` that renders `App` with the props we need. 

> When writing general-purpose HOCs, you also want to [copy static methods](https://reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over) to the wrapper, but in this case we’re not using static methods.

To get our authentication functions working, we need to set up the Auth0 client:

[`src/lib/withAuth.js`](https://github.com/GraphQLGuide/guide/blob/7_0.1.0/src/lib/withAuth.js)

```js
import auth0 from 'auth0-js'
import { initAuthHelpers, login, logout } from 'auth0-helpers'

const client = new auth0.WebAuth({
  domain: 'graphql.auth0.com',
  clientID: '8fErnZoF3hbzQ2AbMYu5xcS0aVNzQ0PC',
  responseType: 'token',
  audience: 'https://api.graphql.guide',
  scope: 'openid profile guide'
})

initAuthHelpers({
  client,
  usePopup: true,
  authOptions: {
    connection: 'github',
    owp: true,
    popupOptions: { height: 623 } // make tall enough for content
  },
  checkSessionOptions: {
    redirect_uri: window.location.origin
  },
  onError: e => console.error(e)
})
```

Here we’re just following the docs for [`auth0-js`](https://www.npmjs.com/package/auth0-js) and [`auth0-helpers`](https://www.npmjs.com/package/auth0-helpers). Now `login()` and `logout()` should be configured to work with the Guide’s Auth0 account system, and we can use them inside `WithAuthWrapper`:

[`src/lib/withAuth.js`](https://github.com/GraphQLGuide/guide/blob/7_0.1.0/src/lib/withAuth.js)

```js
  class WithAuthWrapper extends React.Component {
    constructor(props) {
      super(props)

      this.state = {
        loggingIn: false
      }
    }

    login = () => {
      this.setState({ loggingIn: true })
      login({
        onCompleted: (e, t) => {
          this.setState({ loggingIn: false })
        }
      })
    }

    logout = () => {
      logout()
    }

    render() {
      return (
        <BaseComponent
          user={…}
          loading={this.state.loggingIn}
          login={this.login}
          logout={this.logout}
        />
      )
    }
  }
```

The component has one piece of state, whether a login is in process. To this we need to add the user, which we’ll fetch from the server with our normal `gql` query and `graphql()` HOC. 

[`src/lib/withAuth.js`](https://github.com/GraphQLGuide/guide/blob/7_0.1.0/src/lib/withAuth.js)

```js
import { graphql } from 'react-apollo'
import gql from 'graphql-tag'

const USER_QUERY = gql`
  query UserQuery {
    currentUser {
      firstName
      name
      username
      email
      photo
      hasPurchased
    }
  }
`

const withUser = graphql(USER_QUERY, {
  props: ({ ownProps, data: { currentUser, loading, refetch } }) => ({
    currentUser,
    loading,
    refetch,
    ownProps
  })
})

function withAuth(BaseComponent) {
  class WithAuthWrapper extends React.Component {
    constructor(props) {
      super(props)

      this.state = {
        loggingIn: false
      }
    }

    login = () => {
      this.setState({ loggingIn: true })
      login({
        onCompleted: (e, t) => {
          this.props.refetch()
          this.setState({ loggingIn: false })
        }
      })
    }

    logout = () => {
      logout()
      this.props.refetch()
    }

    render() {
      const { currentUser, loading, ownProps } = this.props

      return (
        <BaseComponent
          user={currentUser}
          loading={loading || this.state.loggingIn}
          login={this.login}
          logout={this.logout}
          {...ownProps}
        />
      )
    }
  }

  WithAuthWrapper.propTypes = {
    currentUser: PropTypes.shape({
      firstName: PropTypes.string.isRequired,
      name: PropTypes.string.isRequired,
      username: PropTypes.string.isRequired,
      email: PropTypes.string.isRequired,
      photo: PropTypes.string.isRequired,
      hasPurchased: PropTypes.string
    }),
    loading: PropTypes.bool.isRequired
  }

  WithAuthWrapper.displayName = wrapDisplayName(BaseComponent, 'withAuth')
  return withUser(WithAuthWrapper)
}

export default withAuth
```

For `loading`, we combine the query’s `loading` with our `loggingIn` state. In general, it’s good practice to pass on whatever props are passed from the wrapper’s parent (although in this case `<App>` isn’t given any props in `src/index.js`). Usually that would mean spreading `...this.props`, but since we wrapped `WithAuthWrapper` in `withUser()`, we spread `...ownProps`. 

The new part of this code is the `data.refetch` property we get from Apollo’s `graphql()`. It’s always an attribute on the `data` prop—we just haven’t used it before. When the user logs in or logs out, we want `currentUser` to update, so we resend the `USER_QUERY` to the server by calling `refetch()`, and when the browser receives the response, our `currentUser` prop is updated.

You might be wondering, "But what do the login and logout functions actually do?" The `login()` function opens the GitHub auth popup, and saves the resulting token in localStorage. The `logout()` function removes the token from localStorage and ends our session with the Auth0 server. The last step is actually using the token—whenever we communicate with the server, we need to provide it. There’s an Apollo Link called [`setContext`](https://www.npmjs.com/package/apollo-link-context) that lets us set headers on HTTP requests, and we’ll use it to add an `authorization` header with the token:

[`src/index.js`](https://github.com/GraphQLGuide/guide/compare/6_0.1.0...7_0.1.0)

```js
import { setContext } from 'apollo-link-context'
import { getAuthToken } from 'auth0-helpers'

const httpLink = createHttpLink({
  uri: 'https://api.graphql.guide/graphql'
})

const authLink = setContext(async (_, { headers }) => {
  const token = await getAuthToken({
    doLoginIfTokenExpired: true
  })

  if (token) {
    return {
      headers: {
        ...headers,
        authorization: `Bearer ${token}`
      }
    }
  } else {
    return { headers }
  }
})

const authedHttpLink = authLink.concat(httpLink)

const link = split(
  ({ query }) => {
    const { kind, operation } = getMainDefinition(query)
    return kind === 'OperationDefinition' && operation === 'subscription'
  },
  wsLink,
  authedHttpLink
)
```

We get the token from `auth0-helpers` using `getAuthToken()`, which either looks it up in localStorage, or if it’s expired, opens the GitHub auth popup again. We use [`concat()`](https://www.apollographql.com/docs/link/composition.html#additive) to combine our new `authLink` with the `httpLink`—now when our Apollo client sends out a new query or mutation, it will first go through `authLink`, which will set the header, and then through `httpLink`, which will put it in an HTTP request and send it to the server.

Now we should have everything working together:

![User profile](/img/user-profile.png)
[*gif: login process*](http://res.cloudinary.com/graphql/guide/login.gif)

The `USER_QUERY` starts out returning `null`, because the server doesn’t know who the client is. When we log in, the query is resent—this time with the new auth token. Now the server knows who we are and is able to return our profile info. 

## Resetting

> If you’re jumping in here, `git checkout 7_0.1.0` ([tag 7_0.1.0](https://github.com/GraphQLGuide/guide/tree/7_0.1.0), or compare [7...8](https://github.com/GraphQLGuide/guide/compare/7_0.1.0...8_0.1.0))

Because the auth token is included in every request, the server will know who we are for any other queries and mutations we send, like the ones for the section content. So our server should recognize that we have purchased a Guide package and return the full content to the sections that are included in our package. But after we log in, the section content is still cut off like it was before. Why is that? Because the section content queries haven’t been refetched! We’re still showing the old data fetched when we were logged out. Now what do we do?

It would be a pain to call `refetch()` on those queries because: A) there are 3 of them, and B) we’d have to figure out how to call the `refetch` functions (which would be inside `Section.js`) from `withAuth.js`. So let’s take a different path—telling Apollo to refetch all the queries in the app. When we’re in an app with large queries that return the same data regardless of whether the user is logged in, this approach would be doing a lot of extra work, but it’s easy, and works fine in this app. `react-apollo` has another HOC, [`withApollo()`](https://www.apollographql.com/docs/react/basics/setup.html#withApollo), which provides your component with a `client` prop—the Apollo client instance. Once we have that, we can call `reFetchObservableQueries()`, which refetches all active queries (and all queries attached to mounted components are active):

[`src/lib/withAuth.js`](https://github.com/GraphQLGuide/guide/blob/8_0.1.0/src/lib/withAuth.js)

```js
import { withApollo } from 'react-apollo'
import { ApolloClient } from 'apollo-client'

class WithAuthWrapper extends React.Component {
  login = () => {
    this.setState({ loggingIn: true })
    login({
      onCompleted: (e, t) => {
        e && console.log(e)
        this.props.client.reFetchObservableQueries()
        this.setState({ loggingIn: false })
      }
    })
  }

  logout = () => {
    logout()
    this.props.client.reFetchObservableQueries()
  }

  …
}

WithAuthWrapper.propTypes = {
  …
  client: PropTypes.instanceOf(ApolloClient).isRequired
}

return withApollo(withUser(WithAuthWrapper))
```

> We also removed all mention of the `USER_QUERY`’s `refetch` function.

The only issue with this is that there may be some personal data left in the Apollo client store after a logout. We should delete that data, in case our user is on a shared computer. We can do that with [`resetStore()`](https://www.apollographql.com/docs/react/api/apollo-client.html#ApolloClient\.resetStore), which both clears the store and refetches active queries:

[`src/lib/withAuth.js`](https://github.com/GraphQLGuide/guide/blob/8_0.1.0/src/lib/withAuth.js)

```js
  logout = () => {
    logout()
    this.props.client.resetStore()
  }
```

Now when we log in and out, the full section content should appear and disappear. 

# Mutating

Section contents:

* [First mutation](6.md#first-mutation)
* [Listing reviews](6.md#listing-reviews)
* [Optimistic updates](6.md#optimistic-updates)
* [Arbitrary updates](6.md#arbitrary-updates)
* [Creating reviews](6.md#creating-reviews)
* [Using fragments](6.md#using-fragments)
* [Deleting](6.md#deleting)
* [Error handling](6.md#error-handling)
* [Editing reviews](6.md#editing-reviews)

## First mutation

> If you’re jumping in here, `git checkout 8_0.1.0` ([tag 8_0.1.0](https://github.com/GraphQLGuide/guide/tree/8_0.1.0), or compare [8...9](https://github.com/GraphQLGuide/guide/compare/8_0.1.0...9_0.1.0))

We haven’t yet changed any of the data in the Guide’s database (just the star count in GitHub’s database). When we want to change data (or more broadly, trigger side effects), we need to send a mutation to the server. Let’s start with something simple—at the bottom of a `<Section>`, let’s add the count of how many times the current section has been viewed. Then we can increment the count whenever it’s viewed.

First we add the `views` field to each of our three section queries. Here’s the first one:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/compare/8_0.1.0...9_0.1.0)

```js
const SECTION_BY_ID_QUERY = gql`
  query SectionContent($id: String!) {
    section(id: $id) {
      id
      content
      views
    }
  }
`

const SectionWithData = ({ location: { state, pathname } }) => {
  const page = deslugify(pathname)

  let query, variables, createProps

  if (state) {
    query = SECTION_BY_ID_QUERY
    variables = { id: state.section.id }
    createProps = ({ data, loading }) => ({
      section: {
        ...state.section,
        content: get(data, 'section.content'),
        views: get(data, 'section.views')
      },
      chapter: state.chapter,
      loading
    })
  } …
```

In addition to `views`, we have to add `id` to the query’s selection set so that the `Section` gets [normalized](5.md#caching) correctly. Also, for this query, we need to add `get(data, 'section.views')` to `createProps()`. We don’t have to modify the other `createProps()` functions, as they include the whole section instead of putting it together from different places.

Next we display the new data:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/compare/8_0.1.0...9_0.1.0)

```js
  let headerContent = null,
    sectionContent = null,
    footerContent = null

  if (loading) {
    …
  } else if (!section) {
    …
  } else {
    …

    sectionContent = section.content
    footerContent = `Viewed ${section.views.toLocaleString()} times`
  }

  return (
    <section className="Section">
      …
      <footer>{footerContent}</footer>
    </section>
  )
```

![Section views](/img/section-views.png)

Now look for the mutation we need in Playground—we need the name, arguments, and return type.

[Playground: `mutation { }`](https://graphqlbin.com/JZ8QCy)

And we write out the mutation string just like we write queries:

`src/components/Section.js`

```js
const VIEWED_SECTION_MUTATION = gql`
  mutation ViewedSection($id: String!) {
    viewedSection(id: $id) {
      id
      views
    }
  }
`
```

Like in the queries, we need the `id` field so that Apollo knows which `Section` is being returned in the mutation response. Now the response’s `views` field will update the normalized `Section` object in the Apollo store, which will update any component queries that select that field. Those queries will pass the updated info to the render prop—in this case, `withSectionById()` will pass a new `data.section` argument to the render prop. We’ll be able to see this in action in a bit.

The mutation HOC is simpler than our query HOCs, since we don’t have props to pass down:

`src/components/Section.js`

```js
import { graphql } from 'react-apollo'

const SectionWithMutation = graphql(VIEWED_SECTION_MUTATION, {
  name: 'viewedSection'
})(Section)

…

    <Query query={query} variables={variables}>
      {queryInfo => <SectionWithMutation {...createProps(queryInfo)} />}
    </Query>
```

For mutations, `graphql()` creates an HOC that provides a single prop function, which we’re naming `viewedSection`. We want to call it whenever a section is viewed, so inside [`componentWillReceiveProps()`](https://reactjs.org/docs/react-component.html#componentwillreceiveprops). In order to get lifecycle methods, we need to convert our functional component to a class:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/compare/8_0.1.0...9_0.1.0)

```js
class Section extends Component {
  lastSectionId = null

  componentWillReceiveProps(props) {
    if (!props.section) {
      return
    }

    const sectionChanged = props.section.id !== this.lastSectionId

    if (sectionChanged) {
      setTimeout(() => {
        props.viewedSection({
          variables: { id: props.section.id }
        })
      }, 2000)
      this.lastSectionId = props.section.id
    }
  }

  render() { … }
}

Section.propTypes = {
  …
  viewedSection: PropTypes.func.isRequired
}
```

We give `props.viewedSection` the section id mutation variable. We put it in a timeout so that we have time to scroll down to the bottom of the section to see the count change (End key or Cmd-⬇️ on Mac). 

We also need to remember the last section ID viewed so that we can only trigger the mutation when the section changed. When the mutation result arrives and updates the Apollo store, `<Section>` is going to be given the updated `section` prop, so `componentWillReceiveProps` will be called again. And if it always called `props.viewedSection()`, we’d be in an infinite loop. (Read: Author Loren was stuck in an infinite loop 😆.)

![Infinite prop-updating loop](/img/infinite-loop.gif)
[*gif: Infinite prop-updating loop*](http://res.cloudinary.com/graphql/guide/infinite-loop.gif)

We should now be able to see the count change at the bottom of the page when we switch between sections.

There is also a render prop API for mutations. Let’s see what that looks like:

[`src/components/Section.js`](https://github.com/GraphQLGuide/guide/compare/8_0.1.0...9_0.1.0)

```js
import { Mutation } from 'react-apollo'

…

    <Query query={query} variables={variables}>
      {queryInfo => (
        <Mutation mutation={VIEWED_SECTION_MUTATION}>
          {viewedSection => (
            <Section
              {...createProps(queryInfo)}
              viewedSection={viewedSection}
            />
          )}
        </Mutation>
      )}
    </Query>
```

The render prop is given the mutation function, and we pass it to `<Section>`. We begin to see here how the indentation level can balloon when a component needs multiple queries and mutations—we add 2+ levels per operation (only 2 if we use implicit-return arrow functions, 3+ for functions with [blocks](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block)).

## Listing reviews

> If you’re jumping in here, `git checkout 9_0.1.0` ([tag 9_0.1.0](https://github.com/GraphQLGuide/guide/tree/9_0.1.0), or compare [9...10](https://github.com/GraphQLGuide/guide/compare/9_0.1.0...10_0.1.0))

Before we get to more advanced mutations, we need more stuff to work with! Let’s make a new page that lists book reviews, and then in the [next section](#optimistic-updates), we can implement features that require mutations: favoriting reviews, creating new reviews, and editing and deleting our own reviews.

Let’s start out by adding a link to the bottom of the table of contents:

[`src/components/TableOfContents.js`](https://github.com/GraphQLGuide/guide/compare/9_0.1.0...10_0.1.0)

```js
const TableOfContents = ({ chapters, loading }) => (
  <nav className="TableOfContents">         
    …
        <li>
          <NavLink className="TableOfContents-reviews-link" to="/reviews">
            Reviews
          </NavLink>
        </li>
      </ul>
    )}
  </nav>
)
```

And we can add the new route with another `<Switch>`:

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/compare/9_0.1.0...10_0.1.0)

```js
const Book = () => (
  <div>
    <TableOfContents />
    <Switch>
      <Route exact path="/reviews" component={Reviews} />
      <Route component={Section} />
    </Switch>
  </div>
)
```

Our `<Reviews>` component is going to need some data! We know how to do that now. Let’s search through the schema for the right query:

[Playground: `query { }`](https://www.graphqlbin.com/qj7PuX)

We find the `reviews` root query field, and since fetching them all might be a lot of data, let’s use the `limit` argument. 

![Schema: reviews](/img/schema-reviews.png)

And for each review, we want to display the author’s name, photo, and a link to their GitHub, so we need:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/blob/10_0.1.0/src/components/Reviews.js)

```js
const REVIEWS_QUERY = gql`
  query ReviewsQuery {
    reviews(limit: 20) {
      id
      text
      stars
      createdAt
      author {
        id
        name
        photo
        username
      }
    }
  }
`
```

As before, we will use `graphql()` to get `reviews` and `loading` passed as props, and it should have a similar structure to `<Section>`:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/blob/10_0.1.0/src/components/Reviews.js)

```js
import React from 'react'
import PropTypes from 'prop-types'
import { graphql } from 'react-apollo'
import gql from 'graphql-tag'

import Review from './Review'

const Reviews = ({ reviews, loading }) => (
  <main className="Reviews mui-fixed">
    <div className="Reviews-header-wrapper">
      <header className="Reviews-header">
        <h1>Reviews</h1>
      </header>
    </div>
    <div className="Reviews-content">
      {loading ? (
        <div className="Spinner" />
      ) : (
        reviews.map(review => <Review key={review.id} review={review} />)
      )}
    </div>
  </main>
)

Reviews.propTypes = {
  reviews: PropTypes.arrayOf(PropTypes.object),
  loading: PropTypes.bool.isRequired
}

const withReviews = graphql(REVIEWS_QUERY, {
  props: ({ data: { reviews, loading } }) => ({ reviews, loading })
})

export default withReviews(Reviews)
```

Next up is the `<Review>` component. So far we’ve mostly been using plain HTML tags and CSS classes for styling. For many components of an app, it’s easier to use a library instead of building and styling them ourselves. The most popular React component library right now is [Material-UI](http://www.material-ui-next.com/), based on Google’s [design system](https://material.io/guidelines/material-design/introduction.html). 

> Here are some of the other [major React component libraries](https://blog.bitsrc.io/11-react-component-libraries-you-should-know-178eb1dd6aa4).

We can explore their component demos to find components we want to use to make up a `<Review>`, and we can browse the [material icons listing](https://material.io/icons/). Let’s put each review on a [Card](https://material-ui-next.com/demos/cards/), with an [Avatar](https://material-ui-next.com/demos/avatars/) for the author’s photo, a [MoreVertIcon](https://material.io/icons/#ic_more_vert) and [Menu](https://material-ui-next.com/demos/menus/) for editing and deleting, and a more prominent [FavoriteBorderIcon](https://material.io/icons/#ic_favorite_border) as a bottom action:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/blob/10_0.1.0/src/components/Reviews.js)

```js
import React, { Component } from 'react'
import PropTypes from 'prop-types'
import Card, { CardHeader, CardContent, CardActions } from 'material-ui/Card'
import IconButton from 'material-ui/IconButton'
import Typography from 'material-ui/Typography'
import Avatar from 'material-ui/Avatar'
import Menu, { MenuItem } from 'material-ui/Menu'
import MoreVertIcon from 'material-ui-icons/MoreVert'
import FavoriteBorderIcon from 'material-ui-icons/FavoriteBorder'
import StarIcon from 'material-ui-icons/Star'
import StarBorderIcon from 'material-ui-icons/StarBorder'
import distanceInWordsToNow from 'date-fns/distance_in_words_to_now'
import times from 'lodash/times'

const StarRating = ({ rating }) => (
  <div>
    {times(rating, i => <StarIcon key={i} />)}
    {times(5 - rating, i => <StarBorderIcon key={i} />)}
  </div>
)

class Review extends Component {
  state = {
    menuAnchor: null
  }

  openMenu = event => {
    this.setState({ menuAnchor: event.currentTarget })
  }

  closeMenu = () => {
    this.setState({ menuAnchor: null })
  }

  edit = () => {
    this.closeMenu()
  }

  delete = () => {
    this.closeMenu()
  }

  toggleFavorite = () => {}

  render() {
    const { review: { text, stars, createdAt, author } } = this.props

    const linkToProfile = child => (
      <a
        href={`https://github.com/${author.username}`}
        target="_blank"
        rel="noopener noreferrer"
      >
        {child}
      </a>
    )

    return (
      <div>
        <Card className="Review">
          <CardHeader
            avatar={linkToProfile(
              <Avatar alt={author.name} src={author.photo} />
            )}
            action={
              <IconButton onClick={this.openMenu}>
                <MoreVertIcon />
              </IconButton>
            }
            title={linkToProfile(author.name)}
            subheader={stars && <StarRating rating={stars} />}
          />
          <CardContent>
            <Typography component="p">{text}</Typography>
          </CardContent>
          <CardActions>
            <Typography className="Review-created">
              {distanceInWordsToNow(createdAt)} ago
            </Typography>
            <div className="Review-spacer" />
            <IconButton onClick={this.toggleFavorite}>
              <FavoriteBorderIcon />
            </IconButton>
          </CardActions>
        </Card>
        <Menu
          anchorEl={this.state.menuAnchor}
          open={Boolean(this.state.menuAnchor)}
          onClose={this.closeMenu}
        >
          <MenuItem onClick={this.edit}>Edit</MenuItem>
          <MenuItem onClick={this.delete}>Delete</MenuItem>
        </Menu>
      </div>
    )
  }
}

Review.propTypes = {
  review: PropTypes.shape({
    id: PropTypes.string.isRequired,
    text: PropTypes.string.isRequired,
    stars: PropTypes.number,
    createdAt: PropTypes.number.isRequired,
    author: PropTypes.shape({
      name: PropTypes.string.isRequired,
      photo: PropTypes.string.isRequired,
      username: PropTypes.string.isRequired
    })
  }).isRequired
}

export default Review
```

The `MoreVertIcon` button controls whether the `Menu` is open and where it is placed (or "anchored"). Also, in the `propTypes`, we list out all the fields of `review` that we use in `<Review>`.

We should now see a list of the 20 most recent reviews! 💃

## Optimistic updates

> If you’re jumping in here, `git checkout 10_0.1.0` ([tag 10_0.1.0](https://github.com/GraphQLGuide/guide/tree/10_0.1.0), or compare [10...11](https://github.com/GraphQLGuide/guide/compare/10_0.1.0...11_0.1.0))

Optimistic UI is when the client acts as if a user action has immediate effect instead of waiting for a response from the server. For example, normally if the user adds a comment to a blog post, the client sends the mutation to the server, and when the server responds with the new comment, the client adds it to the store, which updates the comment query results, which re-renders the page. Optimistic UI is when the client sends the mutation to the server and updates the store at the same time, not waiting for a response—*optimistically* assuming that the comment will be successfully saved to the database.

Let’s write a simple example of an optimistic update for favoriting or unfavoriting a review. We can find in the [Playground](https://api.graphql.guide/play) a mutation called `favoriteReview` which takes the review ID and whether the user is favoriting or unfavoriting. First we write the mutation and wrap `<Review>` with it:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/compare/10_0.1.0...11_0.1.0)

```js
import gql from 'graphql-tag'
import { graphql } from 'react-apollo'

Review.propTypes = {
  review: …
  favorite: PropTypes.func.isRequired
}

const FAVORITE_REVIEW_MUTATION = gql`
  mutation FavoriteReview($id: ObjID!, $favorite: Boolean!) {
    favoriteReview(id: $id, favorite: $favorite) {
      favorited
    }
  }
`

export default graphql(FAVORITE_REVIEW_MUTATION, { name: 'favorite' })(Review)
```

Then we have access to a `favorite` prop, which we use in the button click handler:

```js
  toggleFavorite = () => {
    const { review: { id, favorited } } = this.props
    this.props.favorite({
      variables: {
        id,
        favorite: !favorited
      }
    })
  }
```

Now when we click a review’s heart outline icon, it should change to the filled-in icon… right? 😁 But nothing’s happening. Let’s investigate with [Apollo devtools](5.md#devtools). We can open it on our page to the Mutations section. Then when we click a favorite button, `FavoriteReview` shows up in the Mutation log. So we know the mutation is getting called. And when we click on the log entry, we can see that the argument variables are given correctly:

![Favorite mutation in the log](/img/favorite-mutation.png)

So maybe the issue is with the server’s response? Let’s look at that in the Network tab. In the Name section on the left, scroll down to the bottom, and when we click the favorite button again, a new entry should appear. When we click on that, we should see the Headers tab, which at the top says it was an HTTP POST to `https://api.graphql.guide/graphql` (which all of our GraphQL queries and mutations are). It also says the response status code was "200 OK", so we know the server responded without an error. If we scroll to the bottom, we’ll see the Request Payload, which has `operationName: FavoriteReview` and the correct mutation string and variables. Now if we switch to the Response tab, we see:

`{"data":{"favoriteReview":{"favorited":true,"__typename":"Review"}}}`

The server is giving us the correct response, so it looks like the mutation did succeed. Let’s try reloading the page. Now we see that the review did get favorited. Why was the UI not updating? We forgot to include `id` in the response selection set, so Apollo didn’t know which part of the store to update with `favorited: true`. When we add `id`, it works:

```js
const FAVORITE_REVIEW_MUTATION = gql`
  mutation FavoriteReview($id: ObjID!, $favorite: Boolean!) {
    favoriteReview(id: $id, favorite: $favorite) {
      id
      favorited
    }
  }
`
```

[*gif: Delayed favoriting*](http://res.cloudinary.com/graphql/guide/delayed-favoriting.gif)

While it works now, we can probably notice a delay between when we click the heart and when it changes. If we don’t, we can switch from "Online" to "Fast 3G" in the dropdown on the far right top of the Network tab in Chrome devtools (which simulates the higher latency of mobile networks), and we’ll notice a two-second delay before the icon changes. Some users of our app will probably either be on mobile or on computers far away from our servers, and will notice the delay. Let’s improve their experience by updating the icon immediately (in reality, it will take some milliseconds to run the Apollo and React code and paint a new screen, but the delay should be imperceptible).

We can provide an [`optimisticResponse`](https://www.apollographql.com/docs/react/basics/mutations.html#graphql-mutation-options-optimisticResponse) to our `favorite()` mutation:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/compare/10_0.1.0...11_0.1.0)

```js
  toggleFavorite = () => {
    const { review: { id, favorited } } = this.props
    this.props.favorite({
      variables: {
        id,
        favorite: !favorited
      },
      optimisticResponse: {
        favoriteReview: {
          __typename: 'Review',
          id,
          favorited: !favorited
        }
      }
    })
  }
```

`__typename` is an automatically provided field for the type being returned. We’re mimicking the response from the server, which we saw had `"__typename":"Review"`:

``{"data":{"favoriteReview":{"favorited":true,"__typename":"Review"}}}``

The type name, along with the `id`, will allow Apollo to figure out which review object in the store to update with the new `favorited` value. Now we see that the icon updates right away, even when we set the network speed to fast or slow 3G.

[*gif: Optimistic favoriting*](http://res.cloudinary.com/graphql/guide/optimistic-favoriting.gif)

We may find it helpful to decouple our presentational components from our data-fetching logic. Right now `<Review>` needs to know how to construct an `optimisticResponse` in order to call a mutation. We can make the separation cleaner by taking care of it outside the component:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/compare/10_0.1.0...11_0.1.0)

```js
const withFavoriteMutation = graphql(FAVORITE_REVIEW_MUTATION, {
  props: ({ mutate }) => ({
    favorite: (id, favorite) =>
      mutate({
        variables: { id, favorite },
        optimisticResponse: {
          favoriteReview: {
            __typename: 'Review',
            id,
            favorited: favorite
          }
        }
      })
  })
})

export default withFavoriteMutation(Review)
```

As we did with our queries, we can use `props` to control what props are given to `<Review>`. Here we’re giving a `favorite` function that just takes the two pieces of data we need from the component, and then calls the mutation with the `variables` and `optimisticResponse` objects. Now we can simplify `toggleFavorite`:

```js
class Review extends Component {

  toggleFavorite = () => {
    const { review: { id, favorited } } = this.props
    this.props.favorite(id, !favorited)
  }

  …
}
```

`Review` no longer needs to know a special argument format for a mutation—it just gets a simple `favorite()` function to call.

In the next section, we’ll implement a more flexible and complex form of optimistic updating.

## Arbitrary updates

> If you’re jumping in here, `git checkout 11_0.1.0` ([tag 11_0.1.0](https://github.com/GraphQLGuide/guide/tree/11_0.1.0), or compare [11...12](https://github.com/GraphQLGuide/guide/compare/11_0.1.0...12_0.1.0))

In the previous section ([Optimistic updating](#optimistic-updating)), we changed the Apollo data store using `mutate()`’s `optimisticResponse` option. But that method only let us set the mutation response—an object of type `Review`. Sometimes we need to update different parts of the store. For our next piece of UI, we’ll need to update the `User` object, and we’ll do so with some new functions—[store.readQuery()](https://www.apollographql.com/docs/react/basics/caching.html#readquery) and [store.writeQuery()](https://www.apollographql.com/docs/react/basics/caching.html#writequery-and-writefragment).

In the header of the Reviews page, let’s add the total count of favorited reviews:

![Review count](/img/review-count.png)

First we need to think about how to get the count. We can’t just count how many reviews in the store have `favorited: true`, because we only have the most recent 20. And fetching all the reviews from the server would be a lot of data on the wire, a lot of memory taken up on the client, and a long list to count through. Instead let’s fetch the current user’s `favoriteReviews` field. When we want to know more about the current user, we need to go back to our `withAuth()` HOC and add the field to our `USER_QUERY`:

[`src/lib/withAuth.js`](https://github.com/GraphQLGuide/guide/compare/10_0.1.0...11_0.1.0)

```js
const USER_QUERY = gql`
  query UserQuery {
    currentUser {
      …
      favoriteReviews {
        id
      }
    }
  }
```

Since we’re just counting the length, we don’t need many `Review` fields—just the `id`. Now we need to pass the user object down the component tree—first to `<Book>`:

[`src/components/App.js`](https://github.com/GraphQLGuide/guide/compare/10_0.1.0...11_0.1.0)

```js          
<Route render={() => <Book user={this.props.user} />} />
```

And then to `<Reviews>`:

```js
const Book = ({ user }) => (
  <div>
    <TableOfContents />
    <Switch>
      <Route exact path="/reviews" render={() => <Reviews user={user} />} />
      <Route component={Section} />
    </Switch>
  </div>
)        
```

And now the `<Reviews>` component can receive the prop, get the length of the `user.favoriteReviews` array, and display it on the page:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/compare/10_0.1.0...11_0.1.0)

```js
import get from 'lodash/get'
import FavoriteIcon from 'material-ui-icons/Favorite'


const Reviews = ({ reviews, loading, user }) => {
  const favoriteCount = get(user, 'favoriteReviews.length')

  return (
    <main className="Reviews mui-fixed">
      <div className="Reviews-header-wrapper">
        <header className="Reviews-header">
          {favoriteCount ? (
            <div className="Reviews-favorite-count">
              <FavoriteIcon />
              {favoriteCount}
            </div>
          ) : null}
          <h1>Reviews</h1>
        </header>
    …
  )
}

Reviews.propTypes = {
  …
  user: PropTypes.shape({
    favoriteReviews: PropTypes.arrayOf(
      PropTypes.shape({
        id: PropTypes.string.isRequired
      })
    )
  })
}
```

Now if we have a non-zero favorite count, we should see it in the Reviews header. When we favorite reviews, the count doesn’t go up as it should. We have to reload the page in order to get the count displayed accurately again—the user’s `favoriteReviews` list is getting updated on the server, but not on the client. In order to update it on the client, we add another option to our mutation: [`update`](https://www.apollographql.com/docs/react/basics/mutations.html#graphql-mutation-options-update).

```js
import remove from 'lodash/remove'

const READ_USER_FAVORITES = gql`
  query ReadUserFavorites {
    currentUser {
      id
      favoriteReviews {
        id
      }
    }
  }
`

const withFavoriteMutation = graphql(FAVORITE_REVIEW_MUTATION, {
  props: ({ mutate }) => ({
    favorite: (id, favorite) =>
      mutate({
        variables: { id, favorite },
        optimisticResponse: {
          favoriteReview: {
            __typename: 'Review',
            id,
            favorited: favorite
          }
        },
        update: store => {
          const data = store.readQuery({ query: READ_USER_FAVORITES })

          if (favorite) {
            data.currentUser.favoriteReviews.push({ id, __typename: 'Review' })
          } else {
            remove(data.currentUser.favoriteReviews, { id })
          }

          store.writeQuery({ query: READ_USER_FAVORITES, data })
        }
      })
  })
})
```

`update` is given a [`DataProxy`](https://www.apollographql.com/docs/react/basics/caching.html#direct) object, which allows us to read and write data from and to the store. To read data, we write a query for the data we want to change (in this case `currentUser.favoriteReviews`). To differentiate between queries we send to the server and queries we write just for reading from the store, we start the name with "Read": `ReadUserFavorites`. We give the query to [`store.readQuery()`](https://www.apollographql.com/docs/react/basics/caching.html#readquery), and we get back the data. Then we modify the data (either adding or removing a bare-bones `Review` object with an `id` and `__typename`). Finally, we write the modified data back to the store with [`store.writeQuery()`](https://www.apollographql.com/docs/react/basics/caching.html#writequery-and-writefragment). 

For example, if we started out with:

```js
data = {
  currentUser: {
    __typename: 'User',
    favoriteReviews: [{
      __typename: 'Review',
      id: 'foo'
    }]
  }
}
```

and we favorited a review with id `'bar'`, then we would write this data object back to the store:

```js
{
  currentUser: {
    __typename: 'User',
    favoriteReviews: [{
      __typename: 'Review',
      id: 'foo'
    }, {
      __typename: 'Review',
      id: 'bar'
    }]
  }
}
```

Then Apollo would update `USER_QUERY`’s user prop, which would be passed down to `<Reviews>`, which would find a new `user.favoriteReviews.length` value and re-render the component. We can see that this process works in our app:

[*gif: Updating favorite count*](http://res.cloudinary.com/graphql/guide/updating-favorite-count.gif) 

In the [next section](#creating-reviews), we’ll write an `update()` function that adds an item to a list. We can also use `readQuery()` and `writeQuery()` outside of a mutation—we can wrap any component in `withApollo()`, and then inside the component call, for instance: `this.props.client.writeQuery()`.

There are two more functions we can use—[`readFragment()`](https://www.apollographql.com/docs/react/basics/caching.html#readfragment) and [`writeFragment()`](https://www.apollographql.com/docs/react/basics/caching.html#writequery-and-writefragment). `readQuery` can only read data from a root query type like `currentUser{ … }` or `reviews(limit: 20){ … }`. `readFragment` can read from any normalized object in our store by its store ID. 

A *store ID* is the identifier Apollo uses to [normalize](5.md#caching) objects. [By default](https://www.apollographql.com/docs/react/basics/caching.html#normalization), it is `[__typename]:[id]`, for instance: `Review:5a6676ec094bf236e215f488`. We can see these IDs on the left of the Store section in Apollo devtools:

![View of the store in devtools](/img/devtools-cache.png)

On the left is the store IDs of all objects in the store. There are reviews with their random IDs, as well as sections with store IDs like `Section:1-1`. We can read a section by its store ID like this:

```js
this.props.client.readFragment({
  id: 'Section:introduction',
  fragment: gql`
    fragment exampleSection on Section {
      id
      views
      content
    }
  `
})
```

The `readFragment()` arguments are the store ID and a [fragment](2.md#fragments). It returns just that section:

```js
{
  content: "…"
  id: "introduction"
  views: 67
  __typename: "Section"
  Symbol(id): "Section:intro"
}
```

Similarly, `writeFragment()` allows us to write to an object with a specific store ID:

```js
this.props.client.writeFragment({
  id: 'Section:intro,
  fragment: gql`
    fragment sectionContent on Section {
      content
      __typename
    }
  `,
  data: {
    content: 'overwritten', 
    __typename: 'Section'
  }
})
```

If we ran this and then navigated to `/Introduction`, the section text would have changed to just the word "overwritten" 😅. Not to worry—it’s just changing the local client-side store; when we reload, the actual Introduction text gets refetched from the server. We can try it out in the console, but first we have to (temporarily) add this line in any of our js files that imports `gql`:

```js
window.gql = gql
```

And then we replace `this.props.client` with `__APOLLO_CLIENT__`, which is a global variable available in development.

[*gif: Writing a fragment to the store*](http://res.cloudinary.com/graphql/guide/write-fragment.gif)

## Creating reviews

> If you’re jumping in here, `git checkout 12_0.1.0` ([tag 12_0.1.0](https://github.com/GraphQLGuide/guide/tree/12_0.1.0), or compare [12...13](https://github.com/GraphQLGuide/guide/compare/12_0.1.0...13_0.1.0))

Adding the ability to create reviews will give us the opportunity to look at a more complex mutation and a different kind of `update()` function—we’ll be updating our list of reviews with a new review so that it shows up at the top of the Reviews page.

Let’s start out by adding a FAB ([floating action button](https://material-ui-next.com/demos/buttons/#floating-action-buttons)) that appears on the Reviews page when the user is logged in. The FAB will open a modal that has the form for a new review. Whether the modal is open is a state variable, so we need to convert `<Reviews>` from a function to to a stateful component:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/compare/12_0.1.0...13_0.1.0)

```js
import React, { Component } from 'react'
import Button from 'material-ui/Button'
import AddIcon from 'material-ui-icons/Add'
import Modal from 'material-ui/Modal'

import AddReview from './AddReview'

class Reviews extends Component {
  state = {
    addingReview: false
  }

  addReview = () => {
    this.setState({ addingReview: true })
  }

  doneAddingReview = () => {
    this.setState({ addingReview: false })
  }

  render() {
    const { reviews, loading, user } = this.props

    …

          {user && (
            <div>
              <Button
                onClick={this.addReview}
                variant="fab"
                color="primary"
                className="Reviews-add"
              >
                <AddIcon />
              </Button>
              
              <Modal
                open={this.state.addingReview}
                onClose={this.doneAddingReview}
              >
                <AddReview done={this.doneAddingReview} user={user} />
              </Modal>
            </div>
          )}
        </div>
      </main>
    )
  }
}
```

`<AddReview>` will need a way to let us know it’s done (so we can close the modal) and will need to know who the user is (the creator of the review). To set a primary color for the FAB that matches the rest of the site, we need a Material UI [theme](https://material-ui-next.com/customization/themes/). We can see from the [default theme](https://material-ui-next.com/customization/theme-default/) that `palette.primary.main` is the name of the value to change:

[`src/index.js`](https://github.com/GraphQLGuide/guide/compare/12_0.1.0...13_0.1.0)

```js
import { MuiThemeProvider, createMuiTheme } from 'material-ui/styles'

const GRAPHQL_PINK = '#e10098'

const theme = createMuiTheme({
  palette: { primary: { main: GRAPHQL_PINK } }  
})

ReactDOM.render(
  <BrowserRouter>
    <ApolloProvider client={client}>
      <MuiThemeProvider theme={theme}>
        <App />
      </MuiThemeProvider>
    </ApolloProvider>
  </BrowserRouter>,
  document.getElementById('root')
)
```

Next up is the `<AddReview>` form:

[`src/components/AddReview.js`](https://github.com/GraphQLGuide/guide/blob/13_0.1.0/src/components/AddReview.js)

```js
import React, { Component } from 'react'
import PropTypes from 'prop-types'
import StarInput from 'react-star-rating-component'
import Button from 'material-ui/Button'
import TextField from 'material-ui/TextField'
import StarIcon from 'material-ui-icons/Star'
import StarBorderIcon from 'material-ui-icons/StarBorder'

import { validateReview } from '../lib/validators'

const GREY = "#0000008a"

class AddReview extends Component {
  state = {
    text: '',
    stars: null,
    errorText: null
  }

  updateText = event => {
    this.setState({ text: event.target.value })
  }

  updateStars = stars => {
    this.setState({ stars })
  }

  handleSubmit = event => {
    event.preventDefault()
    const { text, stars } = this.state

    const errors = validateReview({ text, stars })
    if (errors.text) {
      this.setState({ errorText: errors.text })
      return
    }

    // mutate

    this.props.done()
  }

  render() {
    return (
      <form
        className="AddReview"
        autoComplete="off"
        onSubmit={this.handleSubmit}
      >
        <TextField
          className="AddReview-text"
          label="Review text"
          value={this.state.text}
          onChange={this.updateText}
          helperText={this.state.errorText}
          error={!!this.state.errorText}
          multiline
          rowsMax="10"
          margin="normal"
          autoFocus={true}
        />

        <StarInput
          className="AddReview-stars"
          starCount={5}
          editing={true}
          value={this.state.stars}
          onStarClick={this.updateStars}
          renderStarIcon={(currentStar, rating) =>
            currentStar > rating ? <StarBorderIcon /> : <StarIcon />
          }
          starColor={GREY}
          emptyStarColor={GREY}
          name="stars"
        />

        <div className="AddReview-actions">
          <Button className="AddReview-cancel" onClick={this.props.done}>
            Cancel
          </Button>

          <Button type="submit" color="primary" className="AddReview-submit">
            Add review
          </Button>
        </div>
      </form>
    )
  }
}

AddReview.propTypes = {
  done: PropTypes.func.isRequired,
  user: PropTypes.shape({
    name: PropTypes.string.isRequired,
    photo: PropTypes.string.isRequired,
    username: PropTypes.string.isRequired
  }).isRequired
}

export default AddReview
```

Before we mutate, we need to validate the form input and show the error message, if any. We’ll use the [revalidate](http://revalidate.jeremyfairbank.com/) library:

[`src/lib/validators.js`](https://github.com/GraphQLGuide/guide/blob/13_0.1.0/src/lib/validators.js)

```js
import {
  createValidator,
  composeValidators,
  combineValidators,
  isRequired,
  hasLengthLessThan
} from 'revalidate'

const isString = createValidator(
  message => value => {
    if (!(typeof value === 'string')) {
      return message
    }
  },
  field => `${field} must be a String`
)

export const validateReview = combineValidators({
  text: composeValidators(isRequired, isString, hasLengthLessThan(500))(
    'Review text'
  ),
  stars: createValidator(
    message => value => {
      if (![null, 1, 2, 3, 4, 5].includes(value)) {
        return message
      }
    },
    field => `${field} must be a number 1–5`
  )('Stars')
})
```

We use [`createValidator`](http://revalidate.jeremyfairbank.com/usage/createValidator.html) to create custom validator functions, [`composeValidator`](http://revalidate.jeremyfairbank.com/usage/composeValidators.html) to compose multiple validator functions together, and [`combineValidators`](http://revalidate.jeremyfairbank.com/usage/combineValidators.html) to combine our validators in an object matching our data format, with `text` and `stars` fields. Here are some example outputs:

```js
validateReview({
  text: 1,
  stars: 5
})

// => {text: "Review text must be a String"}

validateReview({
  text: 'my review',
  stars: 'a string'
})

// => {stars: Stars must be a number 1–5`}
```

We don’t need to check for a `stars` error because our `<StarInput>` doesn’t produce an invalid value. But we include it in the validator because we’ll also use it on the server.

Next we add the mutation! In the [Playground](https://api.graphql.guide/play) we find the `createReview` mutation (convention is, if you have a data type `Foo`, that the basic [CUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) mutations are called `createFoo`, `updateFoo`, and `deleteFoo`). Now we’re used to `gql` and the `graphql` and `props` functions, but this time we’ll have a larger `optimisticResponse` and a different kind of `update()`:

[`src/components/AddReview.js`](https://github.com/GraphQLGuide/guide/blob/13_0.1.0/src/components/AddReview.js)

```js
import gql from 'graphql-tag'
import { graphql } from 'react-apollo'

class AddReview extends Component {
  …

  handleSubmit = event => {
    event.preventDefault()
    const { text, stars } = this.state

    const errors = validateReview({ text, stars })
    if (errors.text) {
      this.setState({ errorText: errors.text })
      return
    }

    this.props.addReview(text, stars)

    this.props.done()
  }

  …
}

AddReview.propTypes = {
  …
  addReview: PropTypes.func.isRequired
}

const ADD_REVIEW_MUTATION = gql`
  mutation AddReview($input: CreateReviewInput!) {
    createReview(input: $input) {
      id
      text
      stars
      createdAt
      favorited
      author {
        name
        photo
        username
      }
    }
  }
`

const withMutation = graphql(ADD_REVIEW_MUTATION, {
  props: ({ ownProps: { user }, mutate }) => ({
    addReview: (text, stars) => {
      mutate({
        variables: {
          input: { text, stars }
        },
        optimisticResponse: {
          createReview: {
            __typename: 'Review',
            id: null,
            text,
            stars,
            createdAt: new Date(),
            favorited: false,
            author: {
              __typename: 'User',
              id: null,
              name: user.name,
              photo: user.photo,
              username: user.username
            }
          }
        },
        update: (store, { data: { createReview: newReview } }) => {
          const data = store.readQuery({
            query: TODO
          })
          data.reviews.unshift(newReview)
          store.writeQuery({ query: TODO, data })
        }
      })
    }
  })
})

export default withMutation(AddReview)
```

We don’t know what the server-side `id` will be, so we set it to `null`, and it will be updated by Apollo when the server response arrives. Similarly, `createdAt` will be a little different on the server, but not enough to make a difference for optimistic display. We know that `favorited` is `false` because the user hasn’t had a chance to favorite the new review, and the `author` is the current user. 

So far our mutations have updated an existing object in the store (the one with the same `id`), and that object, since it was part of a query result, triggers a component re-render. But this time there is no existing object: we’re adding a new object to the store. And the new object isn’t part of a query result. Apollo will add an object of type `Review` with `id: null` to the store, but it won’t update the `<Reviews>` component’s `reviews` prop because Apollo doesn’t know the new review object should be part of the `REVIEWS_QUERY` results. So we have to change the `REVIEWS_QUERY` results ourselves in the `update` function. 

But first we need access to `REVIEWS_QUERY`, a variable inside `Reviews.js`. We’d run into trouble setting it as a static property on `Reviews` and doing `import Reviews from './Reviews` because we’d have an import cycle—`Reviews.js` imports `AddReview` (`Reviews` would wind up being `null`). So let’s create a new folder for GraphQL documents, `src/graphql/`, and make a new file:

[`src/graphql/Review.js`](https://github.com/GraphQLGuide/guide/blob/13_0.1.0/src/graphql/Review.js)

```js
import gql from 'graphql-tag'

export const REVIEWS_QUERY = gql`
  query ReviewsQuery {
    reviews(limit: 20) {
      id
      text
      stars
      createdAt
      favorited
      author {
        id
        name
        photo
        username
      }
    }
  }
`
```

And in `Reviews.js` and `AddReview.js`, we import it:

[`src/components/AddReview.js`](https://github.com/GraphQLGuide/guide/blob/13_0.1.0/src/components/AddReview.js)

```js
import { REVIEWS_QUERY } from '../graphql/Review'

…

        update: (store, { data: { createReview: newReview } }) => {
          const data = store.readQuery({
            query: REVIEWS_QUERY
          })
          data.reviews.unshift(newReview)
          store.writeQuery({ query: REVIEWS_QUERY, data })
        }
```

The second parameter to [`update`](https://www.apollographql.com/docs/react/basics/mutations.html#graphql-mutation-options-update) has the mutation response—it’s first called with the optimistic response, and then with the server response. So initially, `data.createReview` is the `optimisticResponse.createReview` object we just created. First we call `readQuery`, reading the current results from the store. Then we modify the data, `unshift`ing the `newReview` onto the beginning of the array, so that it shows up first, at the top of the page. 

[*gif: Optimistically adding review*](http://res.cloudinary.com/graphql/guide/adding-review.gif)

## Using fragments

[Fragments](2.md#fragments) are good for more than just [reading from and writing to the store](#arbitrary-updates): they also can [DRY](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) up our queries and mutations. The selection set on `reviews` in the query we just relocated was the same as the selection set on `createReview` we used in our mutation. Let’s put that selection set in a fragment:

[`src/graphql/Review.js`](https://github.com/GraphQLGuide/guide/compare/12_0.1.0...13_0.1.0)

```js
import gql from 'graphql-tag'

export const REVIEW_ENTRY = gql`
  fragment ReviewEntry on Review {
    id
    text
    stars
    createdAt
    favorited
    author {
      id
      name
      photo
      username
    }
  }
`

export const REVIEWS_QUERY = gql`
  query ReviewsQuery {
    reviews(limit: 20) {
      ...ReviewEntry
    }
  }
  ${REVIEW_ENTRY}
`
```

We can’t name the fragment `Review` because that’s a type name, so the convention is `ReviewEntry`. We can greatly simplify our `Review.propTypes` with the `propType()` function from [`graphql-anywhere`](https://github.com/apollographql/apollo-client/tree/master/packages/graphql-anywhere):

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/compare/12_0.1.0...13_0.1.0)

```js
import { propType } from 'graphql-anywhere'
import { REVIEWS_QUERY, REVIEW_ENTRY } from '../graphql/Review'

Review.propTypes = {
  review: propType(REVIEW_ENTRY).isRequired,
  favorite: PropTypes.func.isRequired
}
```

`propType()` generates a React `propTypes`-compatible type-checking function for the `review` object from our `ReviewEntry` fragment. 

Let’s also use the fragment in `<Reviews>` and `<AddReview>`:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/compare/12_0.1.0...13_0.1.0)

```js
import { propType } from 'graphql-anywhere'
import { REVIEWS_QUERY, REVIEW_ENTRY } from '../graphql/Review'

Reviews.propTypes = {
  reviews: PropTypes.arrayOf(propType(REVIEW_ENTRY)),
```

[`src/components/AddReview.js`](https://github.com/GraphQLGuide/guide/compare/12_0.1.0...13_0.1.0)

```js
import { propType } from 'graphql-anywhere'
import { REVIEWS_QUERY, REVIEW_ENTRY } from '../graphql/Review'

const ADD_REVIEW_MUTATION = gql`
  mutation AddReview($input: CreateReviewInput!) {
    createReview(input: $input) {
      ...ReviewEntry
    }
  }
  ${REVIEW_ENTRY}
`
```

## Deleting

> If you’re jumping in here, `git checkout 13_0.1.0` ([tag 13_0.1.0](https://github.com/GraphQLGuide/guide/tree/13_0.1.0), or compare [13...14](https://github.com/GraphQLGuide/guide/compare/13_0.1.0...14_0.1.0))

Next let’s see how deleting an item works. We can add a dialog box confirming deletion, and when it’s confirmed, we’ll send the `removeReview(id)` mutation:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/compare/13_0.1.0...14_0.1.0)

```js
import { graphql, compose } from 'react-apollo'
import Dialog, {
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle
} from 'material-ui/Dialog'
import Button from 'material-ui/Button'

class Review extends Component {
  state = {
    anchorEl: null,
    deleteConfirmationOpen: false
  }

  openDeleteConfirmation = () => {
    this.closeMenu()
    this.setState({ deleteConfirmationOpen: true })
  }

  closeDeleteConfirmation = () => {
    this.setState({ deleteConfirmationOpen: false })
  }

  delete = () => {
    this.closeDeleteConfirmation()
    this.props.delete(this.props.review.id)
  }

  …

        <Dialog
          open={this.state.deleteConfirmationOpen}
          onClose={this.closeDeleteConfirmation}
        >
          <DialogTitle>{'Delete review?'}</DialogTitle>
          <DialogContent>
            <DialogContentText>
              A better UX is probably just letting you single-click delete with
              an undo toast, but that’s harder to code right{' '}
              <span role="img" aria-label="grinning face">
                😄
              </span>
            </DialogContentText>
          </DialogContent>
          <DialogActions>
            <Button onClick={this.closeDeleteConfirmation}>Cancel</Button>
            <Button onClick={this.delete} color="primary" autoFocus>
              Sudo delete
            </Button>
          </DialogActions>
        </Dialog>

  …


const DELETE_REVIEW_MUTATION = gql`
  mutation DeleteReview($id: ObjID!) {
    removeReview(id: $id)
  }
`

const withDeleteMutation = graphql(DELETE_REVIEW_MUTATION, {
  props: ({ mutate }) => ({ delete: id => mutate({ variables: { id } }) })
})

export default compose(withFavoriteMutation, withDeleteMutation)(Review)
```

We see in the [Playground schema](https://api.graphql.guide/play) that `removeReview` resolves to a scalar type (`Boolean`), so unlike our previous mutations, it doesn’t have a selection set:

![Schema: removeReview](/img/schema-removeReview.png)

When we try it out the new delete dialog, we notice that the review remains on the page. Did it work? We can check on the devtools Network tab, selecting the last `graphql` request, and switching to the Response tab: 

```json
{"data":{"removeReview":true}}
```

[*gif: Server response to removeReview*](http://res.cloudinary.com/graphql/guide/remove-review-response.gif)

So the deletion was successful (when we refresh the page, the review is gone), but Apollo client didn’t know it should remove the review object from the store. We can tell it to do so with `update()`:

```js
const withDeleteMutation = graphql(DELETE_REVIEW_MUTATION, {
  props: ({ mutate }) => ({
    delete: id =>
      mutate({
        variables: { id },
        update: store => {
          let data = store.readQuery({ query: Review.queries.REVIEWS })
          remove(data.reviews, { id })
          store.writeQuery({ query: Review.queries.REVIEWS, data })

          data = store.readQuery({ query: READ_USER_FAVORITES })
          remove(data.currentUser.favoriteReviews, { id })
          store.writeQuery({ query: READ_USER_FAVORITES, data })
        }
      })
  })
})
```

We not only need to remove the review from the `REVIEWS` query, but also from `currentUser.favoriteReviews`—otherwise when we delete a favorited review, the count in the header of the reviews page will be inaccurate. 

We’re using `update()` without an `optimisticResponse`, which means it will only be called once, when the server response arrives. We’ll notice a delay between clicking `SUDO DELETE` and the review being removed from the page. If we want it to be removed immediately, we need an `optimisticResponse`, even if we’re not using the optimistic data:

```js
      mutate({
        variables: { id },
        optimisticResponse: {
          removeReview: true
        },
        update: …
```

[*gif: Removing a review*](http://res.cloudinary.com/graphql/guide/remove-review.gif)

## Error handling

Background: [GraphQL errors](1.md#security-&-error-handling)

> If you’re jumping in here, `git checkout 14_0.1.0` ([tag 14_0.1.0](https://github.com/GraphQLGuide/guide/tree/14_0.1.0), or compare [14...15](https://github.com/GraphQLGuide/guide/compare/14_0.1.0...15_0.1.0))

When we try to delete a review that isn’t ours, nothing happens. In the console, we see:

```
ApolloError.js:34 Uncaught (in promise) Error: GraphQL error: unauthorized
    at new ApolloError (ApolloError.js:34)
    at Object.next (QueryManager.js:98)
    at SubscriptionObserver.next (zen-observable.js:154)
    at SubscriptionObserver.next (zen-observable.js:154)
    at httpLink.js:140
    at <anonymous>
```

Let’s break that down:

- `ApolloError.js:34 Uncaught (in promise) Error:`—Apollo is saying that there was a promise that threw an error, and our code didn’t catch it.
- `GraphQL error:`—It was a GraphQL error: an error returned to us from the GraphQL server, not an error in the Apollo library.
- `unauthorized`—This is the error message from the GraphQL server

So the Guide server is saying that we’re not authorized to execute that `removeReview` mutation. This makes sense, because it’s not our review. We should have the app tell the user that, though. A call to `mutate()`—or, in our case, `this.props.delete`—returns a promise. This promise will throw GraphQL errors, which we can catch like this:

```js
this.props
  .delete(this.props.review.id)
  .catch(e => console.log(e.graphQLErrors))
```

`e.graphQLErrors` is an array of all the errors returned from the server. In this case, we just have one:

```js
[
  {
    message: "unauthorized",
    locations: [{"line":2,"column":3}],
    path: ["removeReview"]
  }
]
```

We can now alert the user of the error, depending on whether we find an "unauthorized" message:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/compare/14_0.1.0...15_0.1.0)

```js
  delete = () => {
    this.closeDeleteConfirmation()
    this.props.delete(this.props.review.id).catch(e => {
      if (find(e.graphQLErrors, { message: 'unauthorized' })) {
        alert('👮‍♀️✋ You can only delete your own reviews!')
      }
    })
  }
```

But what about other errors? We could get errors about anything bad happening on the server, from dividing by zero to a database query failing. We could add an `else` statement:

```js
} else {
  alert('Unexpected error occurred')
}
```      

But that wouldn’t cover unexpected errors occurring in all of our other queries and mutations. We can avoid peppering these unexpected-error alerts all over our code by checking errors globally as they arrive from the network. Whenever we want to do some logic that all requests or responses go through, we use a link. At the end of the [Logging in](#logging-in) section, we used an `apollo-link-context` to set an authentication header on all outgoing HTTP requests. Here we can use an [`apollo-link-error`](https://github.com/apollographql/apollo-link/tree/master/packages/apollo-link-error). In `index.js`, we rename our `link` to be `networkLink`, then:

[`src/index.js`](https://github.com/GraphQLGuide/guide/compare/14_0.1.0...15_0.1.0)

```js
import { errorLink } from './lib/errorLink'

const link = errorLink.concat(networkLink)
```

In a chain of links from left to right (where `leftLink.concat(rightLink)`), off the left side of the chain is our code, and off the right side is the network. We put `errorLink` to the left of `networkLink` because we need the GraphQL response coming from the network (off right side) to first go through the `networkLink` (the right end), and then to the `errorLink` (left end), before reaching our code (off left side). We create a new file for `errorLink`:

[`src/lib/errorLink.js`](https://github.com/GraphQLGuide/guide/blob/15_0.1.0/src/lib/errorLink.js)

```js
import { onError } from 'apollo-link-error'

const KNOWN_ERRORS = ['unauthorized']

export const errorLink = onError(({ graphQLErrors, networkError }) => {
  if (networkError) {
    console.log(`[Network error]: ${networkError}`)
    return
  }

  if (graphQLErrors) {
    const unknownErrors = graphQLErrors.filter(
      error => !KNOWN_ERRORS.includes(error.message)
    )

    if (unknownErrors.length) {
      alert('😳 An unexpected error occurred on the server')
      unknownErrors.map(({ message, locations, path }) =>
        console.log(`[GraphQL error]: Message: ${message}, Path: ${path}`)
      )
    }
  }
})
```

If there’s a known error, like `'unauthorized'`, let’s leave it to the originating component to alert the user, since that component knows the context of the error. For example, in `<Review>`, we can be specific, saying “You can only delete your own reviews!” Whereas if we made the alert in `errorLink`, it would be less helpful: “You are not authorized to view this data or perform this action.”

By default, when a GraphQL error is returned from the server, Apollo treats it as a fatal error in the query or mutation. In the case of an unauthorized deletion, the error is thrown from the mutation function, and `update()` isn’t called. This is why the review remains on the page. If we were sending a mutation for which we didn’t care about server errors, and we wanted the `update()` function to always run regardless, we could change the mutation’s default [error policy](https://www.apollographql.com/docs/react/features/error-handling.html#policies):

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/compare/14_0.1.0...15_0.1.0)

```js
const withDeleteMutation = graphql(DELETE_REVIEW_MUTATION, {
  options: { errorPolicy: 'ignore' },
  props: ({ mutate }) => …
})
```

Then the call to `this.props.delete()` would resolve without error, and the review would be removed from the store and page.

Changing the error policy is more often useful when querying. Let’s see how the default error policy works when querying. We can change the `limit` argument on our `reviews` query to a special value of `-1` that will return demo reviews, some of which have a private `text` field.

[`src/graphql/Review.js`](https://github.com/GraphQLGuide/guide/compare/14_0.1.0...15_0.1.0)

```js
export const REVIEWS_QUERY = gql`
  query ReviewsQuery {
    reviews(limit: -1) {
```

When we do this query in [Playground](https://api.graphql.guide/play):

```js
{
  reviews(limit: -1) {
    stars
    text
  }
}
```

here’s the response we get back:

```
{
  "data": {
    "reviews": [
      {
        "stars": 5,
        "text": null
      },
      {
        "stars": 4,
        "text": "GraphQL is awesome, but React is soooo 2016. Write me a Vue chapter!"
      },
      {
        "stars": 3,
        "text": null
      }
    ]
  },
  "errors": [
    {
      "message": "unauthorized",
      "locations": [
        {
          "line": 4,
          "column": 5
        }
      ],
      "path": [
        "reviews",
        0,
        "text"
      ]
    },
    {
      "message": "unauthorized",
      "locations": [
        {
          "line": 4,
          "column": 5
        }
      ],
      "path": [
        "reviews",
        2,
        "text"
      ]
    }
  ]
}
```

[Playground: `query { reviews(limit: -1) { stars text } }`](https://graphqlbin.com/r02EC1)

The first and third reviews have private `text` fields, so we see `text: null` in `data.reviews` and the `errors` array has entries for each one with `"unauthorized"` messages. The first error `path` is `reviews.0.text`, corresponding to the 0th review in the `data.reviews` array, and the second error is at `review.2.text`. So the errors match up with the reviews that have `text: null`.

> The Review schema says that `text` is nullable. If `text` had been non-nullable (`text: String!`), then an error in the `text` resolver would have made the entire object `null`—`data` would have been `{ "reviews": null }`.

Let’s see how our app is handling this partially-null data response with an `errors` attribute. We’re getting an error:

```
Uncaught TypeError: Cannot read property 'map' of undefined
    at Reviews.render (Reviews.js:46)
    …
```

Which corresponds to this line:

```js
reviews.map(review => <Review key={review.id} review={review} />)
```

So it looks like `reviews` is undefined. Let’s also look at `data.error`:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/compare/14_0.1.0...15_0.1.0)

```js
class Reviews extends Component
  render() {
    console.log(this.props.error)
    …
  }
}

const withReviews = graphql(Review.queries.REVIEWS, {
  props: ({ data: { reviews, loading, error } }) => ({
    reviews,
    loading,
    error
  })
})
```

It has these fields:

```json
["stack", "graphQLErrors", "networkError", "message", "extraInfo"]
```

and `this.props.error.graphQLErrors` looks like this:

```js
[
  {
    message: "unauthorized",
    locations: [{ line: 10, column: 3 }],
    path: [ "reviews", 0, "text" ]
  },
  {
    message: "unauthorized",
    locations: [{ line: 10, column: 3 }],
    path: [ "reviews", 2, "text" ]
  }
]
```

If we want `reviews` to be defined, we can set `errorPolicy` to [`'all'`](https://www.apollographql.com/docs/react/features/error-handling.html#policies):

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/compare/14_0.1.0...15_0.1.0)

```js
const withReviews = graphql(Review.queries.REVIEWS, {
  options: { errorPolicy: 'all' },
```

We can handle `text` sometimes being `null` in `<Review>`:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/compare/14_0.1.0...15_0.1.0)

```js
<CardContent>
  {text ? (
    <Typography component="p">{text}</Typography>
  ) : (
    <Typography component="i">Text private</Typography>
  )}
</CardContent>
```

If there were other errors that we thought might result in a null `text` field, we could take different actions based on `this.props.error` in `<Reviews>`. If we wanted to ignore all errors (reviews would be defined, and `this.props.error` would be undefined), we could set `errorPolicy: 'ignore'`.

![Private reviews](/img/private-reviews.png)

Let’s see what happens when we trigger a different error: first let’s sign out, and then let’s interact with a review. We notice that when we favorite, edit, or delete, the "unexpected error" alert appears:

![Unexpected error alert](/img/unexpected-error.png)

To figure out what it is, we could look at the GraphQL response in the Network panel, or we can just look in the console, since the `errorLink` we made logs unknown errors. There, we find that the error message is `must sign in`, for instance:

```
[GraphQL error]: Message: must sign in, Path: favoriteReview
```

Having a user see this alert isn’t good UX. One way to avoid it is by adding `must sign in` to `KNOWN_ERRORS` in `src/lib/errorLink.js`, and then handling the error in `<Review>` with a message like, “Sign in to favorite a review.” Another way to avoid the error is to just remove the UI controls when the user isn’t signed in 😄. Let’s go with the latter solution, but before we do, note what happens to the review on the page right after we take the action, before we dismiss the alert: when we favorite, the heart stays filled in; when we delete, the review disappears, and when we edit, the review changes. In each case, when we dismiss the alert, the review changes back to its previous state. This is a great demonstration of optimistic updates—Apollo applies the optimistic change, then it receives an error back from the server, which goes through our `errorLink`, which puts up an alert, which halts JS execution until it is dismissed. Once it’s dismissed, Apollo is able to finish handling the response—it realizes that the mutation was unsuccessful, so it rolls back the optimistic update, restoring our store to its previous state, which triggers new props being provided to our components, which triggers React to re-render them. 

To remove the UI elements, we need to first get the user info down to `<Review>`:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/compare/14_0.1.0...15_0.1.0)

```js
reviews.map(review => (
  <Review key={review.id} review={review} user={user} />
))
```

And then check if `user` is defined:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/compare/14_0.1.0...15_0.1.0)

```js
  render() {
    const {
      review: { text, stars, createdAt, favorited, author },
      user
    } = this.props
    
    …

          <CardHeader
            action={
              user && (
                <IconButton onClick={this.openMenu}>
                  <MoreVertIcon />
                </IconButton>
              )
            }

            …

            {user && (
              <IconButton onClick={this.toggleFavorite}>
                {favorited ? <FavoriteIcon /> : <FavoriteBorderIcon />}
              </IconButton>
            )}
            
            …

Review.propTypes = {
  …
  user: PropTypes.object
}
```

![Hidden review icons](/img/hidden-review-icons.png)

## Editing reviews

> If you’re jumping in here, `git checkout 15_0.1.0` ([tag 15_0.1.0](https://github.com/GraphQLGuide/guide/tree/15_0.1.0), or compare [15...16](https://github.com/GraphQLGuide/guide/compare/15_0.1.0...16_0.1.0))

The last piece of reviews we haven’t implemented yet is editing! Let’s see how much of our `<AddReview>` component we can reuse by renaming it to `<ReviewForm>` and deciding which mutation to call based on the props. We’ll need to add a `<Modal>` with the form to `<Review>` and pass in the review object as a prop:

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/compare/15_0.1.0...16_0.1.0)

```js
import Modal from 'material-ui/Modal'

import ReviewForm from './ReviewForm'

class Review extends Component {
  state = {
    anchorEl: null,
    deleteConfirmationOpen: false,
    editing: false
  }

  edit = () => {
    this.closeMenu()
    this.setState({ editing: true })
  }

  doneEditing = () => {
    this.setState({ editing: false })
  }

  render() {
    …
        <Modal open={this.state.editing} onClose={this.doneEditing}>
          <ReviewForm done={this.doneEditing} review={this.props.review} />
        </Modal>
      </div>
    )
  }
}
```

The mutation takes the review’s `id` and the new `text` and `stars` fields:

```gql
input UpdateReviewInput {
  text: String!
  stars: Int
}

type Mutation {
  updateReview(id: ObjID!, input: UpdateReviewInput!): Review
}
```

We know whether we’re editing based on the presence of the `review` prop, and we also use it to set initial values for the `text` and `stars` inputs:

[`src/components/ReviewForm.js`](https://github.com/GraphQLGuide/guide/compare/15_0.1.0...16_0.1.0)

```js
import { graphql, compose } from 'react-apollo'
import classNames from 'classnames'

class ReviewForm extends Component {
  constructor(props) {
    super(props)

    const { review } = props

    this.isEditing = !!review

    this.state = {
      text: review ? review.text : '',
      stars: review ? review.stars : null,
      errorText: null
    }
  }

  …

  handleSubmit = event => {
    event.preventDefault()
    const { text, stars } = this.state

    const errors = validateReview({ text, stars })
    if (errors.text) {
      this.setState({ errorText: errors.text })
      return
    }

    const { review } = this.props

    if (this.isEditing) {
      this.props.editReview(review.id, text, stars)
    } else {
      this.props.addReview(text, stars)
    }

    this.props.done()
  }

  render() {
    return (
      <form
        className={classNames('ReviewForm', { editing: this.isEditing })}

        …

          <Button type="submit" color="primary" className="AddReview-submit">
            {this.isEditing ? 'Save' : 'Add review'}
          </Button>
        </div>
      </form>
    )
  }
}

ReviewForm.propTypes = {
  …
  editReview: PropTypes.func.isRequired,
  review: PropTypes.shape({
    id: PropTypes.string.isRequired,
    text: PropTypes.string,
    stars: PropTypes.number
  })
}

…

const EDIT_REVIEW_MUTATION = gql`
  mutation EditReview($id: ObjID!, $input: UpdateReviewInput!) {
    updateReview(id: $id, input: $input) {
      id
      text
      stars
    }
  }
`

const withEditReview = graphql(EDIT_REVIEW_MUTATION, {
  props: ({ mutate }) => ({
    editReview: (id, text, stars) => {
      mutate({
        variables: {
          id,
          input: { text, stars }
        },
        optimisticResponse: {
          updateReview: {
            __typename: 'Review',
            id,
            text,
            stars
          }
        }
      })
    }
  })
})

export default compose(withAddReview, withEditReview)(ReviewForm)
```

When editing an object, we only need to select the `id` and fields that are changing. When the response arrives (and when the `optimisticResponse` is handled), just those fields are updated in the store (the other fields like `author` and `favorited` will remain). 

[*gif: Editing a review*](http://res.cloudinary.com/graphql/guide/edit-review.gif)

# Advanced querying

Section contents:

* [Paginating](6.md#paginating)
  * [Offset-based](6.md#offset-based)
    * [page](6.md#page)
    * [skip & limit](6.md#skip-&-limit)
  * [Cursors](6.md#cursors)
    * [after](6.md#after)
    * [orderBy](6.md#orderby)
* [Updating multiple queries]()
* [Local state]()
* [withUser]()
* [Reviews subscription]()
* [Batching]()
* [Prefetching]()
* [Persisting]()

## Paginating

Our `ReviewsQuery` currently has `limit: 20` because loading all the reviews would be unwise 😄. We don’t know how many reviews there will be in the database, and receiving thousands of them over the network would take a long time on mobile. They’d take a lot of memory in the Apollo store, they’d take a long time to render onto the page, and we’d have the problems that come along with a high DOM (and VDOM) node count: interacting with the DOM takes longer, and the amount of memory the browser uses grows—in the worst case, it exceeds the available memory on the device. On mobile, the OS kills the browser process, and on a computer, the OS starts using the hard drive for memory, which is very slow.

😅 So! In any app where the user might want to see a potentially long list of data, we paginate: we request and display a set amount of data, and when the user wants more (either by scrolling down—in the case of infinite scroll—or by clicking a "next page" link or "page 3" link), we request and display more. There are two main methods of pagination: offset-based, which we’ll talk about first, and [cursors](#cursors). 

We can display the data however we want. The two most common methods are pages (with next/previous links and/or numbered page links like Google search results) and infinite scroll. We can use either data-fetching method with either display method.

### Offset-based

Offset-based pagination is the easier of the two methods to implement—both on the client and on the server. In its simplest form, we request a `page` number, and each page has a set number of items. The Guide server sends 10 items per page, so page 1 has the first 10, page 2 has items 11-20, etc. A more flexible form is using two parameters: `offset` (or `skip`) and `limit`. The client decides how large each page is by setting the `limit` of how many items the server should return. For instance, we can have 20-item pages by first requesting `skip: 0, limit: 20`, then requesting `skip: 20, limit: 20` ("give me 20 items starting with #20", so items 20-39), then `skip: 40, limit: 20`, etc.

The downside of offset-based pagination is that if the list is modified between requests, we might miss items or see them twice. Take, for example, this scenario:

1. We fetch page 1 with the first 10 items. 
2. Some other user deletes the 4th and 5th items.
3. If we were to fetch page 1 again, we would get the new first 10 items, which would now be items 1–3 and 6–12. But we don’t refetch page 1—we fetch page 2. 
4. Page 2 returns items 13–22. Which means now we’re showing the user items 1-10 and 13-22, and we’re missing items 11 and 12, which are now part of page 1.

On the other hand, if things are added to the list, we’ll see things twice:

1. We fetch page 1 with the first 10 items.
2. Some other user submits two new items.
3. If we were to fetch page 1 again, we would get the 2 new items and then items 1–8. But instead we fetch page 2.
4. Page 2 returns items 9-18, which means our list has items 9 and 10 twice—once from page 1 and once from page 2. 

Depending on our application, these issues might never happen, or if they do, it might not be a big deal. If it is a big deal, switching to [cursor-based](#cursors) pagination will fix it. Another possible solution, depending on how often items are added/deleted, is requesting extra pages (to make sure not to miss items) and de-duplicating (to make sure not to display the same item twice). For example, first we could request just page 1, and then when we want page 2, we request both pages 1 and 2. Now if we were in the first scenario above, and the 4th and 5th items were deleted, re-requesting page 1 would get items 11 and 12, which we previously missed. We’ll get items 1–3 and 6–10 a second time, but we can match their ids to objects already in the store and discard them.

Let’s see this in action. Normally an API will support a single pagination method, but as we can see from this schema comment, the `reviews` query supports three different methods:

![reviews Query in the schema](/img/reviews-schema.png)

#### page

> If you’re jumping in here, `git checkout 16_0.1.0` ([tag 16_0.1.0](https://github.com/GraphQLGuide/guide/tree/16_0.1.0), or compare [16...17](https://github.com/GraphQLGuide/guide/compare/16_0.1.0...17_0.1.0))

Let’s try `page` first. We switch our `ReviewQuery` from using the `limit` parameter to using the `page` parameter, and we use a variable so that `<Reviews>` can say which page it wants.

`src/graphql/Review.js`

```js
export const REVIEWS_QUERY = gql`
  query ReviewsQuery($page: Int) {
    reviews(page: $page) {
      ...ReviewEntry
    }
  }
  ${REVIEW_ENTRY}
`
```

`src/components/Reviews.js`

```js
const withReviews = graphql(REVIEWS_QUERY, {
  options: { errorPolicy: 'all', variables: { page: 1 } },
```

Now the page displays the first 10 reviews. If we change it to `{ page: 2 }`, we see the second 10 reviews. We could make the page number dynamic, but let’s wait to do that with the next method, skip and limit.

#### skip & limit

To use the `skip` and `limit` parameters, we replace `page` with them in the query:

[`src/graphql/Review.js`](https://github.com/GraphQLGuide/guide/compare/16_0.1.0...17_0.1.0)

```js
export const REVIEWS_QUERY = gql`
  query ReviewsQuery($skip: Int, $limit: Int) {
    reviews(skip: $skip, limit: $limit) {
      ...ReviewEntry
    }
  }
  ${REVIEW_ENTRY}
`
```

and update our component:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/compare/16_0.1.0...17_0.1.0)

```js
const withReviews = graphql(REVIEWS_QUERY, {
  options: { errorPolicy: 'all', variables: { skip: 0, limit: 10 } },
```

And we see the first 10 reviews. To see the next 10, we can skip the first 10 with `{ skip: 10, limit: 10 }`. 

Let’s implement infinite scroll, during which the component will provide new values for `skip` when the user scrolls to the bottom of the page. First let’s simplify what we’re working with by extracting out the list of reviews to `<ReviewList>`. `<Reviews>` will be left with the header and the add button. Here’s our new `<ReviewList>`:

```js
import React, { Component } from 'react'
import PropTypes from 'prop-types'
import { graphql } from 'react-apollo'
import { propType } from 'graphql-anywhere'

import Review from './Review'

import { REVIEWS_QUERY, REVIEW_ENTRY } from '../graphql/Review'

class ReviewList extends Component {
  render() {
    const { reviews, loading, user } = this.props

    return (
      <div className="Reviews-content">
        {loading
          ? <div className="Spinner" />
          : reviews.map(review => (
            <Review key={review.id} review={review} user={user} />
          ))
        }
      </div>
    )
  }
}

ReviewList.propTypes = {
  reviews: PropTypes.arrayOf(propType(REVIEW_ENTRY)),
  loading: PropTypes.bool.isRequired,
  user: PropTypes.object
}

const withReviews = graphql(REVIEWS_QUERY, {
  options: { errorPolicy: 'all', variables: { skip: 0, limit: 10 } },
  props: ({ data: { reviews, loading } }) => ({
    reviews,
    loading
  })
})

export default withReviews(ReviewList)
```

We’re going to want a spinner at the bottom of the list of reviews to indicate that we’re loading more. When the list is really long—as it is in the case of reviews—we don’t need to code hiding the spinner, since it’s unlikely users will reach the end 😄. Since we’ll always have a spinner, we no longer need `loading`:

[`src/components/ReviewList.js`](https://github.com/GraphQLGuide/guide/compare/16_0.1.0...17_0.1.0)

```js
class ReviewList extends Component {
  render() {
    const { reviews, user } = this.props

    return (
      <div className="Reviews-list">
        <div className="Reviews-content">
          {reviews && reviews.map(review => (
            <Review key={review.id} review={review} user={user} />
          ))}
        </div>
        <div className="Spinner" />
      </div>
    )
  }
}

ReviewList.propTypes = {
  reviews: PropTypes.arrayOf(propType(REVIEW_ENTRY)),
  user: PropTypes.object
}

const withReviews = graphql(REVIEWS_QUERY, {
  options: { errorPolicy: 'all', variables: { skip: 0, limit: 10 } },
  props: ({ data: { reviews } }) => ({
    reviews
  })
})
```

Note that now we need to guard with `reviews && reviews.map`, since `reviews` is `undefined` during loading.

`graphql()` gives a prop named [`data.fetchMore`](https://www.apollographql.com/docs/react/basics/queries.html#graphql-query-data-fetchMore) that we can use to fetch more data using the same query but different variables. Let’s use it to create a `loadMoreReviews()` for `ReviewList` to call:

[`src/components/ReviewList.js`](https://github.com/GraphQLGuide/guide/compare/16_0.1.0...17_0.1.0)

```js
const withReviews = graphql(REVIEWS_QUERY, {
  options: { errorPolicy: 'all', variables: { skip: 0, limit: 10 } },
  props: ({ data: { reviews, fetchMore } }) => ({
    reviews,
    loadMoreReviews: () => {
      return fetchMore({
        variables: { skip: reviews.length },
        updateQuery: (previousResult, { fetchMoreResult }) => {
          if (!fetchMoreResult.reviews) {
            return previousResult
          }

          return {
            ...previousResult,
            reviews: [
              ...previousResult.reviews,
              ...fetchMoreResult.reviews
            ]
          }
        }
      })
    }
  })
})
```

`variables: { skip: reviews.length }`: we can keep the same `limit` by not including it here. And we know how many to skip for the next query—the amount we currently have, `data.reviews.length`. [`updateQuery`](https://www.apollographql.com/docs/react/basics/queries.html#graphql-query-data-fetchMore) is how we tell Apollo to combine the current data with the newly arrived data, which for us is simply putting the new reviews on the end of the `reviews` array. Now we call `loadMoreReviews()` when the user approaches the bottom of the page:

[`src/components/ReviewList.js`](https://github.com/GraphQLGuide/guide/compare/16_0.1.0...17_0.1.0)

```js
class ReviewList extends Component {
  componentDidMount() {
    window.addEventListener('scroll', this.handleScroll)
  }

  componentWillUnmount() {
    window.removeEventListener('scroll', this.handleScroll)
  }

  handleScroll = (event) => {
    const currentScrollHeight = window.scrollY + window.innerHeight
    const pixelsFromBottom = document.documentElement.scrollHeight - currentScrollHeight
    if (pixelsFromBottom < 250) {
      this.props.loadMoreReviews()
    }
  }
```

This works! One issue is that scroll events fire often, so once the user passes the threshold, we’re calling `loadMoreReviews()` a **lot** 😜. We only need to once, so we want to stop ourselves from calling it again if we just called it. We can tell whether we just called it by looking at `graphql()`’s [`data.networkStatus`](https://www.apollographql.com/docs/react/basics/queries.html#graphql-query-data-networkStatus), which has a numerical value corresponding with different statuses—loading, ready, polling, refetching, etc. It’s `3` while Apollo is fetching more data, and then goes back to `7` (ready) when the data has arrived. So we can add in a guard:

```js
const FETCH_MORE = 3

class ReviewList extends Component {
  …

  handleScroll = (event) => {
    if (this.props.networkStatus === FETCH_MORE) {
      return
    }

    const currentScrollHeight = window.scrollY + window.innerHeight
    const pixelsFromBottom = document.documentElement.scrollHeight - currentScrollHeight
    if (pixelsFromBottom < 250) {
      this.props.loadMoreReviews()
    }
  }

…

const withReviews = graphql(REVIEWS_QUERY, {
  options: {
    errorPolicy: 'all',
    variables: { skip: 0, limit: 10 },
    notifyOnNetworkStatusChange: true
  },
  props: ({ data: { reviews, fetchMore, networkStatus } }) => ({
    reviews,
    networkStatus,
    loadMoreReviews: () => {
      …
```

We need to add `networkStatus` to our `props` function to provide it to our component. We also need to set [`options.notifyOnNetworkStatusChange`](https://www.apollographql.com/docs/react/basics/queries.html#graphql-config-options-notifyOnNetworkStatusChange) to `true`, which allows `networkStatus` to change to `3`.

Another issue we’ve got is what happens when someone else adds a review during the time between when the user loads the page and when they scroll to the bottom: `loadMoreReviews()` will query for `reviews(skip: 10, limit: 10)`, which will return items 11-20. However, the 11th item now is the same as the 10th item before, and we already have the 10th item in `previousResult`. When we combine `previousResult` with `fetchMoreResult`, we get a `reviews` array with a duplicated item:

```js
updateQuery: (previousResult, { fetchMoreResult }) => {
  if (!fetchMoreResult.reviews) {
    return previousResult
  }

  return {
    ...previousResult,
    reviews: [
      ...previousResult.reviews,
      ...fetchMoreResult.reviews
    ]
  }
}
```          

Since we use the review’s `id` for the `key`, React gives us this error in the console:

```
Warning: Encountered two children with the same key
```

We can prevent duplicated objects from being saved in the store by changing `updateQuery`:

```js
import find from 'lodash/find'

…

loadMoreReviews: () => {
  return fetchMore({
    variables: { skip: reviews.length },
    updateQuery: (previousResult, { fetchMoreResult }) => {
      if (!fetchMoreResult.reviews) {
        return previousResult
      }

      const newReviews = fetchMoreResult.reviews.filter(
        ({ id }) => !find(previousResult.reviews, { id })
      )

      return {
        ...previousResult,
        reviews: [...previousResult.reviews, ...newReviews]
      }
    }
  })
}
```

We filter out all of the reviews that are already present in `previousResult.reviews`. We can test it out by setting a `skip` that’s too low, for instance:

```js
variables: { skip: reviews.length - 5 },
```

Now when we scroll down, we should have 15 total reviews on the page instead of 20 and a React duplicate `key` error. 

It seems strange at first, but subtracting some number from the length is a good idea to leave in the code! It makes sure—in the case in which some of the first 10 items are deleted—that we don’t miss any items. If we still want 10 new items to (usually) show up when we scroll down, then we can also change `limit` to 15:

```js
variables: { skip: reviews.length - 5, limit: 15 },
```

The *final* issue is that we get an error when we try to add or delete a review:

```
Error: Can't find field reviews({}) on object (ROOT_QUERY) {
"chapters": [
    {
      "type": "id",
      "id": "Chapter:-3",
      "generated": false
    },
    …
  ],
  "currentUser": {
    "type": "id",
    "id": "$ROOT_QUERY.currentUser",
    "generated": true
  },
  "reviews({\"skip\":0,\"limit\":10})": [
    {
      "type": "id",
      "id": "Review:5aa04e9ec3e315449011604c",
      "generated": false
    },
    …
```

In our `withAddReview` and `withDeleteMutation` HOCs’ `update` functions, we’re trying to read `REVIEWS_QUERY` from the store. Since we’re not specifying variables there, it looks in the store for the root query field `reviews({})`, with no arguments. And we don’t have that in our store, because we’ve never done a `REVIEWS_QUERY` without arguments—we’ve only done it with a `skip` and `limit`. The error message prints out the current Apollo store’s state, and we can see that our `reviews` query has both arguments:

```
"reviews({\"skip\":0,\"limit\":10})": [
```

We need to provide the same arguments to `store.readQuery` so that Apollo knows which field on `ROOT_QUERY` to read from:

[`src/components/ReviewForm.js`](https://github.com/GraphQLGuide/guide/compare/16_0.1.0...17_0.1.0)

```js
const withAddReview = graphql(ADD_REVIEW_MUTATION, {
  props: ({ ownProps: { user }, mutate }) => ({
    addReview: (text, stars) => {
      mutate({
        …
        update: (store, { data: { createReview: newReview } }) => {
          const query = {
            query: REVIEWS_QUERY,
            variables: { skip: 0, limit: 10 }
          }

          const data = store.readQuery(query)
          data.reviews.unshift(newReview)
          store.writeQuery({ ...query, data })
        }
      })
    }
  })
})
```

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/compare/16_0.1.0...17_0.1.0)

```js
const withDeleteMutation = graphql(DELETE_REVIEW_MUTATION, {
  props: ({ mutate }) => ({
    delete: id =>
      mutate({
        …
        update: store => {
          const query = {
            query: REVIEWS_QUERY,
            variables: { skip: 0, limit: 10 }
          }

          let data = store.readQuery(query)
          remove(data.reviews, { id })
          store.writeQuery({ ...query, data })

          …
        }
      })
  })
})
```

Now Apollo can successfully read and write to the store, and our optimistic updates will work again. 

What happens when `skip` changes to 10 or 20? Do we need to also update our calls to `readQuery`? It turns out that we don’t need to—when we call `fetchMore`, the additional results get added to the store under the original root query field. We can see this is the case by scrolling down, opening Apollo devtools -> Cache, and looking at `ROOT_QUERY`:

![fetchMore reviews in Cache](img/fetchMore-reviews-cache.png)

### Cursors

> If you’re jumping in here, `git checkout 17_0.1.0` ([tag 17_0.1.0](https://github.com/GraphQLGuide/guide/tree/17_0.1.0), or compare [17...18](https://github.com/GraphQLGuide/guide/compare/17_0.1.0...18_0.1.0))

Cursor-based pagination uses a **cursor**—a pointer to where we are in a list. With cursors, the schema looks different from the Guide schema we’ve been working with. Our queries would look something like:

```gql
{
  listReviews (cursor: $cursor, limit: $limit) {
    cursor
    reviews {
      ...ReviewEntry
    }
  }
}
```

Each query comes back with a cursor, which we then include as an argument in our next query. A cursor usually encodes both the ID of the last item and the list’s sort order, so that the server knows what to return next. For instance, if the first 10 reviews ended with a review that had an ID of `100`, and the list was ordered by most recently created, the cursor could be `100:createdAt_DESC`, and the query could be:

```gql
{
  listReviews (cursor: "100:createdAt_DESC", limit: 10) {
    cursor
    reviews {
      ...ReviewEntry
    }
  }
}
```

It would return:

```json
{
  "data": {
    "listReviews": {
      "cursor": "90:createdAt_DESC",
      "reviews": [{
        "id": "99"
        …
      },
      …
      {
        "id": "90"
        …
      }]
    }
  }
}
```

And then our next query would be `listReviews (cursor: "90:createdAt_DESC", limit: 10)`. 

This is a simple version of cursors. If we’re working with a server that follows the [Relay Cursor Connections spec](https://facebook.github.io/relay/graphql/connections.htm) (with `edges` and `node`s and `pageInfo`s), we can follow [this example](https://www.apollographql.com/docs/react/recipes/pagination.html#cursor-pages) for querying it.

#### after

Let’s implement a version of pagination that has the same information—last ID and sort order—but works within the Guide schema. We can see in [Playground](https://api.graphql.guide/play) that there are a couple of arguments we haven’t used yet—`after` and `orderBy`:

```gql
enum ReviewOrderBy {
  createdAt_ASC 
  createdAt_DESC
}

# To paginate, use page, skip & limit, or after & limit
reviews(limit: Int, page: Int, skip: Int, after: ObjID, orderBy: ReviewOrderBy): [Review!]
```

First, let’s use the last review’s ID for `after`, and remove `skip`:

[`src/components/ReviewList.js`](https://github.com/GraphQLGuide/guide/compare/17_0.1.0...18_0.1.0)

```js
const withReviews = graphql(REVIEWS_QUERY, {
  options: {
    errorPolicy: 'all',
    variables: { limit: 10 },
    notifyOnNetworkStatusChange: true
  },
  props: ({ data: { reviews, fetchMore, networkStatus } }) => ({
    reviews,
    networkStatus,
    loadMoreReviews: () => {
      if (!reviews) {
        return
      }

      const lastId = reviews[reviews.length - 1].id
      return fetchMore({
        variables: { after: lastId },
```

It’s possible that our scroll handler (which calls `loadMoreReviews`) will fire before the results from the initial reviews query has completed, in which case `reviews` will be `undefined`, and we do nothing.

We also have to remove `skip` from `withAddReview` and `withDeleteMutation`, and update the query:

[`src/graphql/Review.js`](https://github.com/GraphQLGuide/guide/compare/17_0.1.0...18_0.1.0)

```js
query ReviewsQuery($after: ObjID, $limit: Int) {
  reviews(after: $after, limit: $limit) {
```

It works! And it’s so precise that we don’t have to worry about things getting added or deleted between `fetchMore`s. We can even take out that filtering code in `updateQuery`! (What was the runtime of that thing anyway? It was so big that author Loren was tempted to prematurely optimize with a hash 😆.) One might be concerned about the possibility of the review we’re using as a cursor being deleted, but some server implementations cover this case—the Guide API is backed by MongoDB, which has IDs that are comparable based on order of creation, so the server can still find IDs that were created before or after the deleted ID.

Next let’s figure out how to get sort order working as well. The two possible values are `createdAt_DESC` (newest reviews first, the default) and `createdAt_ASC`. If we put a "Newest/Oldest" select box in `<Reviews>`, then we can pass the value down to `<ReviewList>` to use in the query’s `variables`:

[`src/components/Reviews.js`](https://github.com/GraphQLGuide/guide/compare/17_0.1.0...18_0.1.0)

```js
import { MenuItem } from 'material-ui/Menu'
import { FormControl } from 'material-ui/Form'
import Select from 'material-ui/Select'

class Reviews extends Component {
  state = {
    addingReview: false,
    orderBy: 'createdAt_DESC'
  }

  handleOrderByChange = event => {
    this.setState({ orderBy: event.target.value })
  }

  render() {
    …
          <header className="Reviews-header">
            …

            <FormControl>
              <Select
                value={this.state.orderBy}
                onChange={this.handleOrderByChange}
                displayEmpty
              >
                <MenuItem value="createdAt_DESC">Newest</MenuItem>
                <MenuItem value="createdAt_ASC">Oldest</MenuItem>
              </Select>
            </FormControl>
          </header>
        </div>

        <ReviewList user={user} orderBy={this.state.orderBy} />
```          

In `<ReviewList>`, we need our `withReviews` HOC to have access to the props. We can use the function form of `options` that we used back in `<Section>`. The function gets the props, from which we take `orderBy`:

[`src/components/ReviewList.js`](https://github.com/GraphQLGuide/guide/compare/17_0.1.0...18_0.1.0)

```js
ReviewList.propTypes = {
  reviews: PropTypes.arrayOf(propType(REVIEW_ENTRY)),
  user: PropTypes.object,
  orderBy: PropTypes.string.isRequired
}

const withReviews = graphql(REVIEWS_QUERY, {
  options: ({ orderBy }) => ({
    errorPolicy: 'all',
    variables: { limit: 10, orderBy },
    notifyOnNetworkStatusChange: true
  }),
```

The select input now works—when we change it to "Oldest", the query variable updates, and a different list of reviews loads. When we go back to "Newest", the original list immediately appears, because Apollo has that list cached under the original set of variables. We can see in devtools that both lists are indeed cached:

![Cache with orderBy](img/cache-with-orderBy.png)

But we’ve got the below issue again!

```
Error: Can’t find field reviews({"limit":10}) on object (ROOT_QUERY)
```

Whenever we change the variables we’re using with `REVIEWS_QUERY`, we have to change our calls to `readQuery` in our mutation HOCs. We might be inclined to pass `this.state.orderBy` to the HOCs, but let’s think about what we want to happen. First `withAddReview`: we don’t want a new review to appear at the top of an "Oldest" list—we always want it to appear at the top of the "Newest" list. So we can always use `createdAt_DESC`:

[`src/components/ReviewForm.js`](https://github.com/GraphQLGuide/guide/compare/17_0.1.0...18_0.1.0)

```js
const withAddReview = graphql(ADD_REVIEW_MUTATION, {
  props: ({ ownProps: { user }, mutate }) => ({
    addReview: (text, stars) => {
      mutate({
        …
        update: (store, { data: { createReview: newReview } }) => {
          const query = {
            query: REVIEWS_QUERY,
            variables: { limit: 10, orderBy: 'createdAt_DESC' }
          }

          const data = store.readQuery(query)
```

Now if we switch to "Oldest", add a review, and switch back to "Newest", it will show up at the top. Next is `withDeleteMutation`—from which list in the store do we want to remove the review that just got deleted? From both! (On the off chance the user has scrolled enough on both sort orders that the deleted item is in both lists.)

[`src/components/Review.js`](https://github.com/GraphQLGuide/guide/compare/17_0.1.0...18_0.1.0)

```js
const withDeleteMutation = graphql(DELETE_REVIEW_MUTATION, {
  props: ({ mutate }) => ({
    delete: id =>
      mutate({
        variables: { id },
        optimisticResponse: {
          removeReview: true
        },
        update: store => {
          const query = {
            query: REVIEWS_QUERY,
            variables: { limit: 10, orderBy: 'createdAt_DESC' }
          }

          let data = store.readQuery(query)
          remove(data.reviews, { id })
          store.writeQuery({ ...query, data })

          query.variables.orderBy = 'createdAt_ASC'

          try {
            data = store.readQuery(query)
            remove(data.reviews, { id })
            store.writeQuery({ ...query, data })
          } catch (e) { }
```

The tricky part here is that we don’t know if the list of reviews with `orderBy: 'createdAt_ASC'` is in the store, and if it’s not, we’ll get an error. So we have to wrap it in a try-catch.

---

That’s all we have for you for now! We’re currently working on more advanced React content and the server chapter. Please drop us a line if you have any suggestions for us 😊.

- <authors@graphql.guide>
- [GitHub issues: book text](https://github.com/GraphQLGuide/book/issues)
- [GitHub issues: code](https://github.com/GraphQLGuide/guide/issues)
